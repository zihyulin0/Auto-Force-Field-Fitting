#!/bin/env python                                                                                                                                                             
# Author: Brett Savoie (brettsavoie@gmail.com)

import os,sys,argparse,fnmatch,time,math
from numpy import *
from copy import copy
from math import sqrt,sin,cos,tan,factorial,acos
import ast
from scipy import *
from scipy.spatial.distance import *
from numpy.linalg import *
from shutil import move,copyfile
from pylab import *
import random
from copy import deepcopy

# Add TAFFY Lib to path
sys.path.append('/'.join(os.path.abspath(__file__).split('/')[:-2])+'/Lib')
from transify import *
from adjacency import *
from file_parsers import *
from id_types import *

def main(argv):

    parser = argparse.ArgumentParser(description='Reads in a .xyz file and generates orca inputs files to determine the intramolecular modes')

    #required (positional) arguments                                                                                                  
    parser.add_argument('coord_file', help = 'The input file. (currently must be either (i) an xyz with the atom types in the fourth column or (ii) a folder holding optimized fragments and mode '+\
                                             'information generated by frag_gen.py)')

    #optional arguments
    parser.add_argument('-atoms', dest='atoms', default='[]',
                        help = 'This arguement expects a list of integers passed as a string. The -by_index and -by_type flags determine whether the program interprets'\
                               ' these integers as atom indices or atom types. Only atoms,bonds,angles, and dihedrals with these atoms participating will generate input files.'\
                               ' 0-indexing is used for index based input. (default: [])') 

    parser.add_argument('-any', dest='any', default = 1,
                        help = 'Setting this argument to 1 generates calculations for all atoms,bonds,angles, and dihedrals with ANY of the atoms specified within the atoms list. (default: 1)')

    parser.add_argument('-all', dest='all', default = 0,
                        help = 'Setting this argument to 1 generates calculations for all atoms,bonds,angles, and dihedrals with ALL of the atoms specified within the atoms list. Overrides the any option. (default: 0)')

    parser.add_argument('-by_index', dest='by_index', default = 0,
                        help = 'Setting this argument to 1 causes the program to interpret the elements in the atoms list as atom indices (default: 1)')

    parser.add_argument('-by_type', dest='by_type', default = 1,
                        help = 'Setting this argument to 1 causes the program to interpret the elements in the atoms list as atom types rather than atom indices. This overrides the by_index option (default: 0)')

    parser.add_argument('-skip_H', dest='skip_H', default = 0,
                        help = 'Setting this argument to 1 skips calculations for all atoms,bonds,angles, and dihedrals with a Hydrogen participating, unless the hydrogen is explicitly'\
                               ' enumerated in the atoms list. For UA forcefields, these are coarse-grained over. (default: 0)')

    parser.add_argument('-qc_prog', dest='qc_prog', default='orca',
                        help = 'This variable holds the name of the quantum chemistry program used for calculating the forcefield parameters (default: orca)')

    parser.add_argument('-f', dest='functional', default='B3LYP',
                        help = 'Sets the functional for the calculation. (default: B3LYP; other typical options are WB97X-D3, and M062X)')

    parser.add_argument('-b', dest='basis', default='def2-TZVP',
                        help = 'Sets the basis set for the calculation. (default: def2-TZVP)')

    parser.add_argument('-o', dest='outputname', default=[],
                        help = 'Controls the output filename. By default the output filename is formed from the input filename and this option is left empty (default: [])')

    parser.add_argument('-p', dest='procs', default=8,
                        help = 'Controls the number of processors per job (default: 8)')

    parser.add_argument('-q', dest='charge', default=0,
                        help = 'Controls the charge configuration for the electronic structure calculations (default: 0)')

    parser.add_argument('-m', dest='multiplicity', default=1,
                        help = 'Controls the multiplicity of the electronic structure calculations (default: 1)')

    parser.add_argument('-overlap_thresh', dest='overlap_thresh', default=1.5,
                        help = 'This variable holds overlaps threshold for determining problematic geometries. (default: 1.5 angstroms)')

    parser.add_argument('-remove_coincident', dest='remove_coincident', default=1,
                        help = 'This variable determines if coincident dihedrals are processed effectively (1) or explicitly (0) (default: 1)')

    parser.add_argument('-avoid', dest='avoid_files', default=[],
                        help = 'This variable holds the filename of parameters database file(s) or molecular xyz files. When supplied, the program will avoid parametrizing any '+\
                               'modes that already exist in the supplied databases, or in the case of *.xyz files, any modes that exist in the molecule. It is often the case that only '+\
                               'a subset of modes are in need of parametrization, if the modes already exist in a database then supplying the database avoids redundant calculations, or if '+\
                               'the modes exist in a molecule that is being parametrized alongside the current molecule (i.e. the parameters do not exist yet but will) then the *.xyz of the '+\
                               'molecules(s) can be supplied to avoid redudant parametrization. Note, in the case of determination from a *.xyz file the script assumes default bond angle '+\
                               'and dihedral styles. (default: None)')

    parser.add_argument('-theory', dest='theory', default='DFT MP2',
                        help = 'Controls the calculations that are performed for the parametrizations. The argument should be supplied as a space delimited string (default: "DFT MP2")')

    parser.add_argument('-gens', dest='gens', default=2,
                        help = 'Controls the bond search depth for identifying unique groups (default: 2)')

    parser.add_argument('--no_harmonic_db', dest='no_harmonic_db', default=0, action='store_const', const=1,
                        help = 'Default behavior is to parametrize dihedrals with double-bonds between the central atoms with harmonic potentials. When this flag is enabled, the '+\
                               'full rotation is sampled and parametrization using the fourier potential. (default: off)')

    parser.add_argument('-c', dest='constraints', default=" ", 
                        help = 'Designates the contraints to apply during the mode scans. "bond" "angle" and "dihedral" are valid options. The -c argument should be supplied as a '+\
                               'space delimited string. Based of the supplied argument(s), the corresponding modes are constrained during the mode scans.') 

    parser.add_argument('-r', dest='random_factor', default=0.0, 
                        help = 'Designates the randomization factor for the initial coordinates of the molecule. All atoms are randomly displaced by this factor (default: 0.0)')

    parser.add_argument('-b_disp', dest='b_disp', default=0.001, 
                        help = 'Designates the +/- bond elongation for the scan (always 10 steps) (default: 0.001 ang)')

    parser.add_argument('-a_disp', dest='a_disp', default=0.5, 
                        help = 'Designates the +/- angle contraction for the scan (always 10 steps) (default: 0.5 degree)')

    parser.add_argument('-h_disp', dest='h_disp', default=0.5, 
                        help = 'Designates the +/- angle contraction for the harmonic dihedral scans (default: 0.5 degree)')

    parser.add_argument('-d_step', dest='d_step', default=5, 
                        help = 'Designates the step size for the fourier dihedral scans (default: 5 degrees)')

    parser.add_argument('-modes', dest='mode_list', default='bonds angles dihedrals', 
                        help = 'Holds a space-delimited list of mode types to be parametrized. By default all modes are parametrized. Options include, bonds, angles, and dihedrals. '+\
                               '(Default: "bonds angles dihedrals")')

    parser.add_argument('--skip_clashes', dest='skip_clashes', default=0, action='store_const',const=1,
                        help = 'This flag toggles the omission of geometries with clashes. The threshold used for determining if a geometry should be skipped is controlled by -overlap_thresh. '+\
                               'Default behavior is to keep clashes as they are discovered (if --constrain_dihedrals is present) or to perform rotations to correct clashes (if --constrain_dihedrals '+\
                               'is absent). (Default: off)')

    parser.add_argument('--local_relaxation', dest='local_relaxation', default=0, action='store_const',const=1,
                        help = 'This flag toggles the omission of constraints coincident with the dihedral modes being parametrized. For example, when performing the scan of a dihedral with -c '+\
                               '"bond angle dihedral" enabled, ordinarily all degrees of freedom are constrained. But with this flag enabled, bonds and angles involving any of the atoms in the '+\
                               'dihedral, and any coincident dihedrals, are allowed to relax. (Default: off)')

    parser.add_argument('--frag', dest='frag_opt', default=0, action='store_const',const=1,
                        help = 'This flag toggles the use of molecular fragments for the parametrizations. The smallest fragment consistent with each mode is retained for each parametrization. '+\
                               'For bonds and angles, the fragmentation is based upon the -gens flag. For dihedrals, one heavy atom beyond the 1 and 4 atoms is retained. Hydrogenation is used to '+\
                               'correct any dangling bonds. (Default: off)')

    parser.add_argument('--scan', dest='scan_opt', default=0, action='store_const',const=1,
                        help = 'This flag toggles the use of sequential scans for the parametrization. Default behavior is to run the scan in parallel, as separate geometries. For some modes, '+\
                               'espcially dihedrals and any modes generated with the --frag option enabled, the initial geometries generated this way are bad. This option scans the mode in a '+\
                               'single calculation, using the previous geometry as the initial guess in each step of the scan. (Default: off)')

    parser.add_argument('--no_D3', dest='D3_flag', default=1, action='store_const', const=0,
                        help = 'When this flag is present, the D3-dispersion correction is disabled. By default the dispersion correction is used.')

    # Initialize mass_dict (used as default values in several places).
    mass_dict = {'H':1.00794,'He':4.002602,'Li':6.941,'Be':9.012182,'B':10.811,'C':12.011,'N':14.00674,'O':15.9994,'F':18.9984032,'Ne':20.1797,\
                 'Na':22.989768,'Mg':24.3050,'Al':26.981539,'Si':28.0855,'P':30.973762,'S':32.066,'Cl':35.4527,'Ar':39.948,\
                 'K':39.0983,'Ca':40.078,'Sc':44.955910,'Ti':47.867,'V':50.9415,'Cr':51.9961,'Mn':54.938049,'Fe':55.845,'Co':58.933200,'Ni':58.6934,'Cu':63.546,'Zn':65.39,\
                 'Ga':69.723,'Ge':72.61,'As':74.92159,'Se':78.96,'Br':79.904,'Kr':83.80,\
                 'Rb':85.4678,'Sr':87.62,'Y':88.90585,'Zr':91.224,'Nb':92.90638,'Mo':95.94,'Tc':98.0,'Ru':101.07,'Rh':102.90550,'Pd':106.42,'Ag':107.8682,'Cd':112.411,\
                 'In':114.818,'Sn':118.710,'Sb':121.760,'Te':127.60,'I':126.90447,'Xe':131.29,\
                 'Cs':132.90545,'Ba':137.327,'La':138.9055,'Hf':178.49,'Ta':180.9479,'W':183.84,'Re':186.207,'Os':190.23,'Ir':192.217,'Pt':195.078,'Au':196.96655,'Hg':200.59,\
                 'Tl':204.3833,'Pb':207.2,'Bi':208.98038,'Po':209.0,'At':210.0,'Rn':222.0}

    # Set random seed
    random.seed(1234)

    # Make relevant inputs lowercase
    args=parser.parse_args(argv)

    # Parse inputs
    args.b_disp = float(args.b_disp)
    args.a_disp = float(args.a_disp)
    args.d_step = float(args.d_step)
    args.h_disp = float(args.h_disp)
    args.atoms = ast.literal_eval(args.atoms)
    args.atoms = [ int(i) for i in args.atoms ]
    args.any = int(args.any)
    args.all = int(args.all)
    args.skip_H = int(args.skip_H)
    args.charge = int(args.charge)
    args.overlap_thresh = float(args.overlap_thresh)
    args.multiplicity = int(args.multiplicity)
    args.procs = int(args.procs)
    args.remove_coincident = int(args.remove_coincident)
    args.gens = int(args.gens)
    args.theory = args.theory.split()
    args.random_factor = float(args.random_factor)
    args.constraints = args.constraints.split()
    args.mode_list = args.mode_list.split()

    # Automatically turn bond, angle, and dihedral into bonds, angles, and dihedrals.
    for count_i,i in enumerate(args.constraints):
        if args.constraints[count_i][-1] != "s": args.constraints[count_i] += "s"
    for count_i,i in enumerate(args.mode_list):
        if args.mode_list[count_i][-1] != "s": args.mode_list[count_i] += "s"

    # Consistency checks
    if False in [ i in ["bonds","angles","dihedrals"] for i in args.constraints ]: print("ERROR: only bonds, angles, and dihedrals are valid constraint options. Exiting..."); quit()
    if False in [ i in ["bonds","angles","dihedrals"] for i in args.mode_list ]: print("ERROR: only bonds, angles, and dihedrals are valid modes for parametrization. Exiting..."); quit()
    if args.avoid_files != []: 
        args.avoid_files = args.avoid_files.split()
        if False in [ os.path.isfile(i) for i in args.avoid_files ]: 
            print("ERROR: the supplied files to -avoid ({}) do not exist. Exiting...".format(", ".join([ j for j in args.avoid_files if os.path.isfile(j) == False ])))
            quit()

    # Check if the supplied "coord_file" is a folder or a geometry
    if os.path.isdir(args.coord_file):
        sys.stdout = Logger(args.coord_file)
        print("PROGRAM CALL: python paramgen.py {}\n".format(' '.join([ i for i in argv])))
        frag_mode_gen(args.coord_file,args.gens,args.charge,args.multiplicity,args.procs,args.theory,args.constraints,args.local_relaxation,args.scan_opt,args.functional,args.basis,args.D3_flag,args.mode_list,\
                      args.b_disp/5.0,args.b_disp,args.a_disp/5.0,args.a_disp,args.h_disp/5.0,args.h_disp,args.d_step,args.random_factor,0,args.no_harmonic_db,args.overlap_thresh,args.skip_clashes)
        return

    # Check that the input is an .xyz file.
    elif args.coord_file.split('.')[-1] != 'xyz':
        print("ERROR: Check to ensure that the input file is in .xyz format.")
        return

    # Check various parameters for consistency
    if int(args.any) not in [1,0]:
        print("ERROR: The -any option must be either 0 or 1, no other values are allowed.")
        return
    if int(args.all) not in [1,0]:
        print("ERROR: The -all option must be either 0 or 1, no other values are allowed.")
        return
    if int(args.skip_H) not in [1,0]:
        print("ERROR: The -all option must be either 0 or 1, no other values are allowed.")
        return
    if int(args.procs) > 8:
        print("ERROR: The -p option must be either less than 9, orca only allows 8 proc parallelization.")
        return

    # Generate filename and directory for output
    # Make directory to hold the output
    if args.outputname:
        Filename = args.outputname
    else:
        Filename = args.coord_file.split('/')[-1].split('.')[0]

    # Make the output directory if it doesn't already exist.
    if os.path.exists(Filename):
        print('The desired output folder ({}) already exists. Exiting to avoid overwriting data...'.format(Filename))
        return
    else:
        os.makedirs(Filename)
        os.makedirs(Filename+'/bonds')
        os.makedirs(Filename+'/angles')
        os.makedirs(Filename+'/dihedrals')
        os.makedirs(Filename+'/dihedrals_harmonic')
        os.makedirs(Filename+'/geoopt')
        sys.stdout = Logger(Filename)
        print("PROGRAM CALL: python paramgen.py {}\n".format(' '.join([ i for i in argv])))
            
    # Extract Element list and Coord list from the file
    Elements,Geometry = xyz_parse(args.coord_file)

    # Apply the randomization factor
    for i in range(len(Geometry)):
        Geometry[i,0] = ( random.random()*2.0 - 1.0 )*args.random_factor + Geometry[i,0] 
        Geometry[i,1] = ( random.random()*2.0 - 1.0 )*args.random_factor + Geometry[i,1] 
        Geometry[i,2] = ( random.random()*2.0 - 1.0 )*args.random_factor + Geometry[i,2] 

    # Generate adjacency table
    Adj_mat = Table_generator(Elements,Geometry)

    # Check the number of molecules
    Num_mol = mol_count(Adj_mat)
    if Num_mol > 1:
        print("ERROR: {} molecules were discovered. Check the geometry of the input file. Exiting...".format(Num_mol))
        quit()

    # Find linear, branched, and cyclic segments
    Structure = Structure_finder(Adj_mat)

    # Find backbone
    Backbone = Dijkstra(Adj_mat)

    # Find Hybridizations
    Hybridizations = Hybridization_finder(Elements,Adj_mat)

    # Find atom_types
    Atom_types = id_types(Elements,Adj_mat,args.gens,Hybridizations,Geometry)

    # If args.atoms is [] then all modes are to be parametrized
    if args.atoms == []:
        args.atoms = sorted(set(Atom_types))

    # Print diagnostic
    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Summary of Atom Types and Topology"))
    print("{}".format("*"*144))

    for count_i,i in enumerate(sorted(set(Atom_types))):
        print("{:80s} : {}".format(i,Atom_types.count(i)))    

    # Cyclic Properties
    Num_3 = int(ceil(len([ i for i in Structure if i == 3 ])/3.0))
    Num_4 = int(ceil(len([ i for i in Structure if i == 4 ])/4.0))
    Num_5 = int(ceil(len([ i for i in Structure if i == 5 ])/5.0))
    Num_6 = int(ceil(len([ i for i in Structure if i == 6 ])/6.0))
    Num_7 = int(ceil(len([ i for i in Structure if i == 7 ])/7.0))
    Num_8 = int(ceil(len([ i for i in Structure if i == 8 ])/8.0))

    Number_of_rings = Num_3 + Num_4 + Num_5 + Num_6 + Num_7 + Num_8

    print('\nRings: {}'.format(Number_of_rings))

    if Number_of_rings == 0:
        print(" ")
    if Num_3 > 0:
        print("3-membered rings: {}".format(Num_3))
    if Num_4 > 0:
        print("4-membered rings: {}".format(Num_4))
    if Num_5 > 0:
        print("5-membered rings: {}".format(Num_5))
    if Num_6 > 0:
        print("6-membered rings: {}".format(Num_6))
    if Num_7 > 0:
        print("7-membered rings: {}".format(Num_7))
    if Num_8 > 0:
        print("8-membered rings: {}".format(Num_8))

    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Searching for Intramolecular Modes"))
    print("{}".format("*"*144))
    
    # Look up the FF parameters: Angles Bonds and Dihedrals are a list of lists, holding 
    #the indices of the atoms participating in each object.
    Angles,Bonds,Dihedrals = Find_parameters(Adj_mat,Atom_types)

    # If FF_db is supplied read in database and search for redundant modes
    if args.avoid_files != []:

        # Read in parameters from database
        FF_Data = get_FF_data(args.avoid_files,gens=args.gens,no_harmonic_db=args.no_harmonic_db)

        # Search for bonds that already exist in the database and remove matches from Bonds list
        del_list = [ count_i for count_i,i in enumerate(Bonds) if (Atom_types[i[0]],Atom_types[i[1]],'harmonic') in list(FF_Data["bonds"].keys()) ]
        del_list += [ count_i for count_i,i in enumerate(Bonds) if (Atom_types[i[1]],Atom_types[i[0]],'harmonic') in list(FF_Data["bonds"].keys()) ]

        # Print diagnostic for removed bonds
        if len(del_list) > 0:
            print("\nThe following bond types were excluded because they already exist in the files(s) supplied to -avoid:\n")
            for i in sorted(set([ (Atom_types[j[0]],Atom_types[j[1]],"harmonic") for count_j,j in enumerate(Bonds) if count_j in del_list ])):
                print("\t{}".format(i))

        # Remove the redundant bonds from the Bonds list
        Bonds = [ i for count_i,i in enumerate(Bonds) if count_i not in del_list ]

        # Search for angles that already exist in the database and remove matches from Angles list
        del_list = [ count_i for count_i,i in enumerate(Angles) if (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],'harmonic') in list(FF_Data["angles"].keys()) ]
        del_list += [ count_i for count_i,i in enumerate(Angles) if (Atom_types[i[2]],Atom_types[i[1]],Atom_types[i[0]],'harmonic') in list(FF_Data["angles"].keys()) ]

        # Print diagnostic for removed angles
        if len(del_list) > 0:
            print("\nThe following angle types were excluded because they already exist in the files(s) supplied to -avoid:\n")
            for i in sorted(set([ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],"harmonic") for count_j,j in enumerate(Angles) if count_j in del_list ])):
                print("\t{}".format(i))

        # Remove the redundant angles from the Angles list
        Angles = [ i for count_i,i in enumerate(Angles) if count_i not in del_list ]

        # Search for dihedrals that already exist in the database and remove matches from Dihedrals list
        del_list = []
        for count_i,i in enumerate(Dihedrals):

            # Check conditions for harmonic dihedrals (i.e. the 2-3 atoms are part of a ring, or if the 2-3 atoms are part of a double bond)
            if "R" in Atom_types[i[1]].split('[')[0] and "R" in Atom_types[i[2]].split('[')[0]:
                dihedral_type = 'harmonic'
            elif args.no_harmonic_db == 0 and True in [ j in ["E","Z"] for j in Atom_types[i[1]].split('[')[0] ] and True in [ j in ["E","Z"] for j in Atom_types[i[2]].split('[')[0] ]:
                dihedral_type = 'harmonic'
            else:
                dihedral_type = 'opls'

            # Check if the current type is already in the FF data dictionary
            if (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]],dihedral_type) in list(FF_Data["dihedrals"].keys()):
                del_list += [count_i]
            if (Atom_types[i[3]],Atom_types[i[2]],Atom_types[i[1]],Atom_types[i[0]],dihedral_type) in list(FF_Data["dihedrals"].keys()):
                del_list += [count_i]
    
        # Print diagnostic for removed dihedrals
        if len(del_list) > 0:
            print("\nThe following dihedral types were excluded because they already exist in the files(s) supplied to -avoid:\n")
            for i in sorted(set([ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) for count_j,j in enumerate(Dihedrals) if count_j in del_list ])):

                # Find the type: check conditions for harmonic dihedrals (i.e. the 2-3 atoms are part of a ring, or if the 2-3 atoms are part of a double bond)
                if "R" in i[1].split('[')[0] and "R" in i[2].split('[')[0]:
                    dihedral_type = 'harmonic'
                elif args.no_harmonic_db == 0 and True in [ j in ["E","Z"] for j in i[1].split('[')[0] ] and True in [ j in ["E","Z"] for j in i[2].split('[')[0] ]:
                    dihedral_type = 'harmonic'
                else:
                    dihedral_type = 'opls'
                remove_type = (i[0],i[1],i[2],i[3],dihedral_type)

                print("\t{}".format(remove_type))

        # Remove the redundant dihedrals from the Dihedrals list
        Dihedrals = [ i for count_i,i in enumerate(Dihedrals) if count_i not in del_list ]

    ##########################################################
    # Only keep Angles, Bonds, and Dihedrals that have the 
    # user-selected atoms participating
    ##########################################################

    # Bonds loop
    del_list = []
    for count_i,i in enumerate(Bonds):

        # For ease, the current object's elements and types are saved to a
        # temporary list.
        Current_elements = [ Elements[i[0]], Elements[i[1]] ]
        Current_types = [ Atom_types[i[0]], Atom_types[i[1]] ] 

        # Delete entry if it includes an H that is not specified in args.atoms
        if args.skip_H == 1:
            for count_j,j in enumerate(Current_elements):
                if j == 'H' and i[count_j] not in args.atoms:
                    del_list = del_list + [count_i]

        # All atoms comprising the bond must be in the specified
        # set of types or indices.
        if args.all == 1:
            if args.by_type == 1:
                if ( Current_types[0] not in args.atoms ) or ( Current_types[1] not in args.atoms ):
                    del_list = del_list + [count_i]
            elif args.by_index == 1:
                if ( i[0] not in args.atoms ) or ( i[1] not in args.atoms ):                
                    del_list = del_list + [count_i]

        # At least one atom in the bond must be in the specified
        # set of types or indices.
        elif args.any == 1:
            if args.by_type == 1:
                if ( Current_types[0] not in args.atoms ) and ( Current_types[1] not in args.atoms ):
                    del_list = del_list + [count_i]
            elif args.by_index == 1:
                if ( i[0] not in args.atoms ) and ( i[1] not in args.atoms ):
                    del_list = del_list + [count_i]

    # Remove entries from Bonds
    Bonds = [ i for count_i,i in enumerate(Bonds) if count_i not in del_list ]
    Bond_types = [ (Atom_types[i[0]],Atom_types[i[1]]) for i in Bonds ]

    # Angles loop
    del_list = []
    for count_i,i in enumerate(Angles):

        # For ease, the current object's elements and types are saved to a
        # temporary list.
        Current_elements = [ Elements[i[0]], Elements[i[1]], Elements[i[2]] ]
        Current_types = [ Atom_types[i[0]], Atom_types[i[1]], Atom_types[i[2]] ] 

        # Delete entry if it includes an H that is not specified in args.atoms
        if args.skip_H == 1:
            for count_j,j in enumerate(Current_elements):
                if j == 'H' and i[count_j] not in args.atoms:
                    del_list = del_list + [count_i]

        # All atoms comprising the angle must be in the specified
        # set of types or indices.
        if args.all == 1:
            if args.by_type == 1:
                if ( Current_types[0] not in args.atoms ) or ( Current_types[1] not in args.atoms ) or ( Current_types[2] not in args.atoms ):
                    del_list = del_list + [count_i]
            elif args.by_index == 1:
                if ( i[0] not in args.atoms ) or ( i[1] not in args.atoms ) or ( i[2] not in args.atoms ):
                    del_list = del_list + [count_i]


        # At least one atom in the angle must be in the specified
        # set of types or indices.
        elif args.any == 1:
            if args.by_type == 1:
                if ( Current_types[0] not in args.atoms ) and ( Current_types[1] not in args.atoms ) and ( Current_types[2] not in args.atoms ):
                    del_list = del_list + [count_i]
            elif args.by_index == 1:
                if ( i[0] not in args.atoms ) and ( i[1] not in args.atoms ) and ( i[2] not in args.atoms ):
                    del_list = del_list + [count_i]
                
    # Remove entries from Angles
    Angles = [ i for count_i,i in enumerate(Angles) if count_i not in del_list ]
    Angle_types = [ (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]]) for i in Angles ]

    # Dihedrals loop
    del_list = []

    for count_i,i in enumerate(Dihedrals):

        # For ease, the current object's elements and types are saved to a
        # temporary list.
        Current_elements = [ Elements[i[0]], Elements[i[1]], Elements[i[2]], Elements[i[3]] ]
        Current_types = [ Atom_types[i[0]], Atom_types[i[1]], Atom_types[i[2]], Atom_types[i[3]] ] 

        # Delete entry if it includes an H that is not specified in args.atoms
        if args.skip_H == 1:
            for count_j,j in enumerate(Current_elements):
                if j == 'H' and i[count_j] not in args.atoms:
                    del_list = del_list + [count_i]

        # All atoms comprising the dihedral must be in the specified
        # set of types or indices.
        if args.all == 1:
            if args.by_type == 1:
                if ( Current_types[0] not in args.atoms ) or ( Current_types[1] not in args.atoms ) or ( Current_types[2] not in args.atoms ) or ( Current_types[3] not in args.atoms ):
                    del_list = del_list + [count_i]
            elif args.by_index == 1:
                if ( i[0] not in args.atoms ) or ( i[1] not in args.atoms ) or ( i[2] not in args.atoms ) or ( i[3] not in args.atoms ):
                    del_list = del_list + [count_i]

        # At least one atom in the dihedral must be in the specified
        # set of types or indices.
        elif args.any == 1:
            if args.by_type == 1:
                if ( Current_types[0] not in args.atoms ) and ( Current_types[1] not in args.atoms ) and ( Current_types[2] not in args.atoms ) and ( Current_types[3] not in args.atoms ):
                    del_list = del_list + [count_i]
            elif args.by_index == 1:
                if ( i[0] not in args.atoms ) and ( i[1] not in args.atoms ) and ( i[2] not in args.atoms ) and ( i[3] not in args.atoms ):
                    del_list = del_list + [count_i]        

    # Remove entries from Dihedrals
    Dihedrals = [ i for count_i,i in enumerate(Dihedrals) if count_i not in del_list ]
    Dihedral_types = [ (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]]) for i in Dihedrals ]

    # Identify unique dihedral groups. A group is defined by a set of coincident dihedrals about a give 2-3 bonds where
    # coincident dihedrals are defined as the collection of 1-2-3-4 dihedrals that can be formed using the 2-3 atoms. 
    # For parametrization, at most only one of each type of group needs to be parametrized. When args.remove_coincident == 1 then
    # only dihedral in each unique group is constrained and scanned in the QC calculation. When args.remove_coincident == 0
    # then each dihedral in each unique group is constratined and scanned in the QC calculation.     
    groups = []
    for count_i,i in enumerate(Dihedrals):
        if args.by_type == 1:
            coincident_dihedrals,coincident_dihedral_types = Find_coincident_dihedrals(i,args.atoms,Atom_types,Adj_mat,mode='type')
        elif args.by_index == 1:
            coincident_dihedrals,coincident_dihedral_types = Find_coincident_dihedrals(i,args.atoms,Atom_types,Adj_mat,mode='index')
        if set(coincident_dihedral_types) not in [ j[0] for j in groups ]:
            groups += [(set([Dihedral_types[count_i]]+coincident_dihedral_types),[i]+coincident_dihedrals)] # NOTE: Find_coincident_dihedrals omits the supplied dihedral so it is prepended here

    # Collect enough groups such that all dihedral types are found in at least one group
    # Part of the complication of this loop owes to the fact that the representative group(s)
    # of each dihedral type is chosen to maximize the number of coincident dihedrals. This 
    # minimizes the number of redudant scans that are performed at the QC level. 

    kept = []                                                                 # holds dihedral types that are represented within the kept_groups
    kept_groups = []                                                          # holds the groups that are being kept for qc scans                 
    for i in set(Dihedral_types):                                             # Loop over all unique dihedral types
        if i in kept: continue                                                # Skip types that are already represented within kept_groups
        max = 0                                                               # Reset counter
        for count_j,j in enumerate(groups):                                   # Loop over all unique groups
            if i in j[0]:                                                     # Loop over dihedrals within the group
                num_new = len(set([ k for k in j[0] if k not in kept ]))      # Calculate the number of new dihedrals that would be represented by this group (j)
                if num_new > max:                                             # Check if the number of new dihedrals exceeds the previous max
                    max = num_new                                             # Update number of new dihedrals for the current max
                    match = count_j                                           # Update the index of the best fitting group
        kept_groups += [groups[match]]                                        # Add the best fitting group to the kept_groups list
        kept += list(set([ j for j in groups[match][0] if j not in kept ]))   # Add the new dihedral types represented by groups[match] to the kept list
    groups = kept_groups 

    # Replace the set of dihedral types with a list of dihedral types indexed to the list of dihedral instances
    groups = [ ([(Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) for j in i[1] ],i[1]) for i in groups ]

    # At this point groups holds the dihedrals_types and dihedral instances of each 2-3 bond that needs to be parametrized
    # If args.remove_coincident == 1, then only one representative type from each group is explicitly scanned in the qc calculation.
    if args.remove_coincident == 1:

        # Initalize list of scanned dihedrals and those discarded owing to coincidence
        scanned_types   = []
        scanned_ind     = []

        # Loop over groups
        for i in range(len(groups)):
            
            # The the 2-3 atoms of the group are R or E/Z then all dihedrals are kept since they are harmonic paramtrizations
            if "R" in groups[i][0][0][1] and "R" in groups[i][0][0][2]:
                for count_j,j in enumerate(groups[i][1]):
                    scanned_types += [ groups[i][0][count_j] ]
                    scanned_ind   += [ groups[i][1][count_j] ]
                continue
            if args.no_harmonic_db == 0 and True in [ j in ["E","Z"] for j in groups[i][0][0][1].split('[')[0] ] and True in [ j in ["E","Z"] for j in groups[i][0][0][2].split('[')[0] ]:
                for count_j,j in enumerate(groups[i][1]):
                    scanned_types += [ groups[i][0][count_j] ]
                    scanned_ind   += [ groups[i][1][count_j] ]
                continue

            # If this is a non-harmonic dihedral then the scanned dihedral is determined on the basis of the summed masses of the 1-4 atoms
            max_mass = 0
            current_scan = 9999
            for count_j,j in enumerate(groups[i][1]):
                current_mass = (mass_dict[Elements[j[0]]]+mass_dict[Elements[j[3]]])
                if current_mass > max_mass and groups[i][0][count_j] not in scanned_types:
                    max_mass = current_mass
                    current_scan = count_j

            scanned_types += [ groups[i][0][current_scan] ]
            scanned_ind   += [ groups[i][1][current_scan] ]

        # Print diagnostic of the dihedrals that are being implicitly scanned
        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Coincident Dihedrals Removed"))
        print("{}".format("*"*144))
        removed = [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) for count_i,i in enumerate(groups) for count_j,j in enumerate(i[1]) if j not in scanned_ind ]
        for count_i,i in enumerate([ _ for _ in set(removed)]):
            print("{}".format("-".join([str(_) for _ in i])))

    # If coincident types are not being removed then the scanned_types and scanned_ind lists are populated with the group dihedral types and instances
    elif args.remove_coincident == 0:
        scanned_types = []
        scanned_ind   = []
        for i in groups:
            scanned_types += i[0]
            scanned_ind   += i[1]
        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Coincident Dihedrals Removed"))
        print("{}".format("*"*144))
            
    # Assign list of dihedrals_types and instances to the Dihedral_types and Dihedrals names respectively
    Dihedrals = scanned_ind
    Dihedral_types = scanned_types

    # Remove redundant types :
    # red_list gets populated with repeated elements over the course of 
    # the nested loops. Notes on loop structure:  Removal of all redundant 
    # elements occurs at the end; elements in red_list get skipped, the
    # first instance of any object is not placed in red_list.

    # Bond loop
    red_list = []
    for count_i,i in enumerate(Bond_types):
        if count_i in red_list:
            continue
        for count_j,j in enumerate(Bond_types):
            if count_i == count_j:
                continue
            if j == i:
                red_list = red_list + [count_j]
    Bonds = [ i for count_i,i in enumerate(Bonds) if count_i not in red_list ]
    Bond_types = [ i for count_i,i in enumerate(Bond_types) if count_i not in red_list ]

    # Angle loop
    red_list = []
    for count_i,i in enumerate(Angle_types):
        if count_i in red_list:
            continue
        for count_j,j in enumerate(Angle_types):
            if count_i == count_j:
                continue
            if j == i:
                red_list = red_list + [count_j]
    Angles = [ i for count_i,i in enumerate(Angles) if count_i not in red_list ]
    Angle_types = [ i for count_i,i in enumerate(Angle_types) if count_i not in red_list ]

    # Dihedral loop
    red_list = []
    for count_i,i in enumerate(Dihedral_types):
        if count_i in red_list:
            continue
        for count_j,j in enumerate(Dihedral_types):
            if count_i == count_j:
                continue
            if j == i:
                red_list = red_list + [count_j]            

    Dihedrals = [ i for count_i,i in enumerate(Dihedrals) if count_i not in red_list ]
    Dihedral_types = [ i for count_i,i in enumerate(Dihedral_types) if count_i not in red_list ]

    # Remove linear dihedrals
    linear_dihedrals = []
    del_list = []
    for count_i,i in enumerate(Dihedrals):
        # Check 0-1-2 
        if 180.0 - acos(dot(Geometry[i[0]]-Geometry[i[1]],Geometry[i[2]]-Geometry[i[1]])/(norm(Geometry[i[0]]-Geometry[i[1]])*norm(Geometry[i[2]]-Geometry[i[1]])))*180.0/pi < 5.0:
            linear_dihedrals += [i]
            del_list += [count_i]
        # Check 1-2-3
        elif 180.0 - acos(dot(Geometry[i[1]]-Geometry[i[2]],Geometry[i[3]]-Geometry[i[2]])/(norm(Geometry[i[1]]-Geometry[i[2]])*norm(Geometry[i[3]]-Geometry[i[2]])))*180.0/pi < 5.0:
            linear_dihedrals += [i]
            del_list += [count_i]            
    
    # Print diagnostic for removed dihedrals
    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Linear Dihedrals Removed"))
    print("{}".format("*"*144))
    for count_i,i in enumerate([ _ for _ in set(linear_dihedrals)]):
        print("{}".format("-".join([str(Atom_types[_]) for _ in i])))

    Dihedrals = [ i for count_i,i in enumerate(Dihedrals) if count_i not in del_list ]
    Dihedral_types = [ i for count_i,i in enumerate(Dihedral_types) if count_i not in del_list ]

    # Print diagnostics and generate orca input files
    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Bond List"))
    print("{}".format("*"*144))
    print("{:<80s} {:60s}".format("Bonds","Atom_Indices"))
    for count_i,i in enumerate(Bonds):
        print("{:<80s} {:<30s}".format(str(Bond_types[count_i][0])+'-'+str(Bond_types[count_i][1]),str(i[0])+'-'+str(i[1])))

    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Angle List"))
    print("{}".format("*"*144))
    print("{:<100s} {:60s}".format("Angles","Atom_Indices"))
    for count_i,i in enumerate(Angles):
        print("{:<100s} {:<30s}".format(str(Angle_types[count_i][0])+'-'+str(Angle_types[count_i][1])+'-'+str(Angle_types[count_i][2]),str(i[0])+'-'+str(i[1])+'-'+str(i[2])))

    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Dihedral List"))
    print("{}".format("*"*144))
    print("{:<120s} {:60s}".format("Dihedrals","Atom_Indices"))
    for count_i,i in enumerate(Dihedrals):
        print("{:<120s} {:<30s}".format(str(Dihedral_types[count_i][0])+'-'+str(Dihedral_types[count_i][1])+'-'+str(Dihedral_types[count_i][2])+'-'+str(Dihedral_types[count_i][3]),str(i[0])+'-'+str(i[1])+'-'+str(i[2])+'-'+str(i[3])))

    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Generating Geometries and QC Input Files"))
    print("{}".format("*"*144))

    print("\n\tScan details:")
    print("\n\t\tBond stretch/contraction by {} Angstrom(s), in steps of {} Angstrom(s)...".format(args.b_disp,args.b_disp/5.0))
    print("\t\tAngle dilation/contraction by {} degree(s), in steps of {} degree(s)...".format(args.a_disp,args.a_disp/5.0))
    print("\t\tFourier dihedral rotation by {} degree(s), in steps of {} degree(s)...".format(360.0,args.d_step))
    print("\t\tHarmonic dihedral rotation by {} degree(s), in steps of {} degree(s)...\n".format(args.h_disp,args.h_disp/5.0))

    # Generate globally optimized geometry job: 
    gen_global_opt(Filename+'/geoopt/'+Filename+"_geoopt",Adj_mat,Elements,Geometry,Atom_types,charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
                      theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,functional=args.functional,D3_flag=args.D3_flag)

    # Generate bond files: loop over each bond type and call the function gen_bond_files
    # to output a chained xyz file that allows the stretch to be viewed in vmd, and a
    # series of orca input files that generate the FF data.
    if "bonds" in args.mode_list:
        for count_b,b in enumerate(Bonds):        
            Current_name = Filename+'/bonds/'+Filename+'_'+'-'.join([ str(i) for i in Bond_types[count_b]])
            if args.scan_opt == 0:
                gen_bond_files(Current_name,args.gens,Adj_mat,b,Elements,Geometry,Atom_types,bond_step=args.b_disp/5.0,bond_disp=args.b_disp,\
                               charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
                               theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,functional=args.functional,D3_flag=args.D3_flag)

            else:
                gen_bond_scan_files(Current_name,args.gens,Adj_mat,b,Elements,Geometry,Atom_types,bond_step=args.b_disp/5.0,bond_disp=args.b_disp,\
                                    charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
                                    theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,functional=args.functional,D3_flag=args.D3_flag)

    # Generate angle files: loop over each angle type and call the function gen_angle_files
    # to output a chained xyz file that allows the bend to be viewed in vmd, and a
    # series of orca input files that generate the FF data.
    if "angles" in args.mode_list:
        for count_a,a in enumerate(Angles):
            Current_name = Filename+'/angles/'+Filename+'_'+'-'.join([ str(i) for i in Angle_types[count_a]])
            if args.scan_opt == 0:
                gen_angle_files(Current_name,args.gens,Adj_mat,a,Elements,Geometry,Atom_types,angle_step=args.a_disp/5.0,angle_disp=args.a_disp,\
                                charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
                                theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,functional=args.functional,D3_flag=args.D3_flag)
            else:
                gen_angle_scan_files(Current_name,args.gens,Adj_mat,a,Elements,Geometry,Atom_types,angle_step=args.a_disp/5.0,angle_disp=args.a_disp,\
                                     charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
                                     theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,functional=args.functional,D3_flag=args.D3_flag)

    # generate dihedral files: loop over each dihedral type and call the function gen_dihedral_files
    # to output a chained xyz file that allows the dihedral to viewed in vmd, and a series of orca
    # input files that generate the FF data.
    if "dihedrals" in args.mode_list:
        for count_d,d in enumerate(Dihedrals):
            
            # # Check for dihedral within a ring. NOTE: frag_opt is disabled for ring dihedrals. A more robust fragmentation algorithm might be developed in the future.
            # if "R" in Atom_types[d[1]].split('[')[0] and "R" in Atom_types[d[2]].split('[')[0]:
            #     Current_name = Filename+'/dihedrals_harmonic/'+Filename+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
            #     gen_harmonic_dihedral_files(Current_name,args.gens,Adj_mat,d,Elements,Geometry,Atom_types,charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
            #                                 theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,dihedral_disp=args.h_step)
            # elif args.no_harmonic_db == 0 and True in [ j in ["E","Z"] for j in Atom_types[d[1]].split('[')[0] ] and True in [ j in ["E","Z"] for j in Atom_types[d[2]].split('[')[0] ]:
            #     Current_name = Filename+'/dihedrals_harmonic/'+Filename+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
            #     gen_harmonic_dihedral_files(Current_name,args.gens,Adj_mat,d,Elements,Geometry,Atom_types,charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
            #                                 theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,dihedral_disp=args.h_step)

            # The fragment generation algorithm has been updated and should now be fully compatible with fragment based parameterizations (old loops are retained above)
            if args.no_harmonic_db == 0 and True in [ j in ["R","E","Z"] for j in Atom_types[d[1]].split('[')[0] ] and True in [ j in ["R","E","Z"] for j in Atom_types[d[2]].split('[')[0] ]:
                Current_name = Filename+'/dihedrals_harmonic/'+Filename+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                gen_harmonic_dihedral_files(Current_name,args.gens,Adj_mat,d,Elements,Geometry,Atom_types,charge=args.charge,multiplicity=args.multiplicity,procs=args.procs,\
                                            theory=args.theory,constraints=args.constraints,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,dihedral_disp=args.h_disp,dihedral_step=args.h_disp/5.0,functional=args.functional,D3_flag=args.D3_flag)

            else:
                if args.scan_opt == 0:
                    Current_name = Filename+'/dihedrals/'+Filename+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                    gen_fourier_dihedral_files(Current_name,args.gens,Adj_mat,d,Elements,Geometry,Atom_types,charge=args.charge,multiplicity=args.multiplicity,overlap_thresh=args.overlap_thresh,\
                    procs=args.procs,theory=args.theory,constraints=args.constraints,skip_clashes=args.skip_clashes,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,dihedral_step=args.d_step,functional=args.functional,D3_flag=args.D3_flag)
                else:
                    Current_name = Filename+'/dihedrals/'+Filename+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                    gen_fourier_dihedral_scan_files(Current_name,args.gens,Adj_mat,d,Elements,Geometry,Atom_types,charge=args.charge,multiplicity=args.multiplicity,overlap_thresh=args.overlap_thresh,\
                    procs=args.procs,theory=args.theory,constraints=args.constraints,skip_clashes=args.skip_clashes,local_relaxation=args.local_relaxation,frag_opt=args.frag_opt,dihedral_step=args.d_step,functional=args.functional,D3_flag=args.D3_flag)

    # Write master/globally optimized geometry with atom types to the parent directory
    with open(Filename+'/'+Filename+"_master.xyz",'w') as f:
        if args.by_type == 1:
            list_of_indices = sorted([ count_j for _ in set(args.atoms) for count_j,j in enumerate(Atom_types) if _ == j])
            f.write("{}\nIndices: {}\n".format(len(Elements),' '.join([ str(_) for _ in list_of_indices ])))
        elif args.by_index == 1:
            f.write("{}\nIndices: {}\n".format(len(Elements),' '.join([ str(_) for _ in args.atoms])))
        for count_i,i in enumerate(Elements):
            f.write("{:<12s} {:< 20.14f} {:< 20.14f} {:< 20.14f} {:s}\n".format(i,Geometry[count_i,0],Geometry[count_i,1],Geometry[count_i,2],Atom_types[count_i]))
        f.close()
    
    # If no parametrization is needed then write the FF.db file for the atom
    if len(Atom_types) == 1:
        print("Only a single atom in the geometry, no parametrizations needed. Writing parameters to {}...".format(Filename+'/'+Filename+".db"))
        write_single_params(Filename,Filename+".db",Elements[0],Atom_types[0],float(args.charge),Geometry[0])
    elif undefined_dihedrals != []:
        write_zero_params(Filename,"undefined.db",[],[],linear_dihedrals,Atom_types,Elements,Geometry)

    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Success! Have a nice day!"))
    print("{}".format("*"*144))
        
    return

# A subfunction that handles the special case of reading *.modes files and writing modes scans for collections of fragments
def frag_mode_gen(frag_folder,gens,charge,multiplicity,procs,theory,constraints,local_relaxation,scan_opt,functional,basis,D3_flag,mode_list,b_step,b_disp,a_step,a_disp,h_step,h_disp,d_step,\
                  random_factor,frag_opt=0,no_harmonic_db=0,overlap_thresh=1.5,skip_clashes=0):

    # Change directory into the fragment folder and collect the file names
    os.chdir(frag_folder)
    mode_files = [ i for i in os.listdir('.') if os.path.isdir(i) == False and fnmatch.fnmatch(i,"frag-*.modes") ]
    geo_files = [ '.'.join([ j for j in i.split('.')[:-1]])+'_geoopt/geo_opt.xyz' for i in mode_files ] 

    # Ensure that all of the files are in place
    if False in [ os.path.isfile(i) for i in mode_files ]:
        print("ERROR in frag_mode_gen: Expected {} to exist. Exiting...".format(" ".join([ i for i in mode_files if os.path.isfile(i) == False ])))
    if False in [ os.path.isfile(i) for i in geo_files ]:
        print("ERROR in frag_mode_gen: Expected {} to exist. Exiting...".format(" ".join([ i for i in geo_files if os.path.isfile(i) == False ])))

    # Loop over each fragment and generate the mode scans based on the contents of the frag-*.modes 
    for count_i,i in enumerate(geo_files):

        # Print diagnostic
        print("Parsing modes from {}".format(mode_files[count_i]))
        Folder = ".".join([ j for j in mode_files[count_i].split(".")[:-1] ]) + "_" + "_".join([ k for k in mode_list ])        
        print("Folder: {}".format(Folder))

        # Read in the modes being parametrized from the mode_files
        Bonds,Bond_types,Bond_atomtypes,\
        Angles,Angle_types,Angle_atomtypes,\
        Dihedrals,Dihedral_types,Dihedral_atomtypes = read_modes(mode_files[count_i])                

        # Print diagnostics and generate orca input files
        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Bond List"))
        print("{}".format("*"*144))
        print("{:<80s} {:60s}".format("Bonds","Atom_Indices"))
        for count_j,j in enumerate(Bonds):
            print("{:<80s} {:<30s}".format(str(Bond_types[count_j][0])+'-'+str(Bond_types[count_j][1]),str(j[0])+'-'+str(j[1])))

        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Angle List"))
        print("{}".format("*"*144))
        print("{:<100s} {:60s}".format("Angles","Atom_Indices"))
        for count_j,j in enumerate(Angles):
            print("{:<100s} {:<30s}".format(str(Angle_types[count_j][0])+'-'+str(Angle_types[count_j][1])+'-'+str(Angle_types[count_j][2]),str(j[0])+'-'+str(j[1])+'-'+str(j[2])))

        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Dihedral List"))
        print("{}".format("*"*144))
        print("{:<120s} {:60s}".format("Dihedrals","Atom_Indices"))
        for count_j,j in enumerate(Dihedrals):
            print("{:<120s} {:<30s}".format(str(Dihedral_types[count_j][0])+'-'+str(Dihedral_types[count_j][1])+'-'+str(Dihedral_types[count_j][2])+'-'+str(Dihedral_types[count_j][3]),str(j[0])+'-'+str(j[1])+'-'+str(j[2])+'-'+str(j[3])))

        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Generating Geometries and QC Input Files"))
        print("{}".format("*"*144))

        print("\n\tScan details:")
        print("\n\t\tBond stretch/contraction by {} Angstrom(s), in steps of {} Angstrom(s)...".format(b_disp,b_disp/5.0))
        print("\t\tAngle dilation/contraction by {} degree(s), in steps of {} degree(s)...".format(a_disp,a_disp/5.0))
        print("\t\tFourier dihedral rotation by {} degree(s), in steps of {} degree(s)...".format(360.0,d_step))
        print("\t\tHarmonic dihedral rotation by {} degree(s), in steps of {} degree(s)...\n".format(h_disp,h_disp/5.0))

        # Create the directories for parametrizing this run
        if os.path.isdir(Folder) is True:
            print("ERROR in paramgen.py: Folder {}/{} already exists. Exiting...".format(frag_folder,Folder))
            quit()            
        os.makedirs(Folder)
        os.makedirs(Folder+'/bonds')
        os.makedirs(Folder+'/angles')
        os.makedirs(Folder+'/dihedrals')
        os.makedirs(Folder+'/dihedrals_harmonic')
        os.makedirs(Folder+'/geoopt')

        # Extract Element list and Coord list from the file
        Elements,Geometry = xyz_parse(i)

        # Generate adjacency table
        Adj_mat = Table_generator(Elements,Geometry)

        # Find linear, branched, and cyclic segments
        Structure = Structure_finder(Adj_mat)

        # Find backbone
        Backbone = Dijkstra(Adj_mat)

        # Find Hybridizations
        Hybridizations = Hybridization_finder(Elements,Adj_mat)

        # Find atom_types
        Atom_types = id_types(Elements,Adj_mat,gens,Hybridizations,Geometry)

        # Apply the randomization factor
        for j in range(len(Geometry)):
            Geometry[j,0] = ( random.random()*2.0 - 1.0 )*random_factor + Geometry[j,0] 
            Geometry[j,1] = ( random.random()*2.0 - 1.0 )*random_factor + Geometry[j,1] 
            Geometry[j,2] = ( random.random()*2.0 - 1.0 )*random_factor + Geometry[j,2] 

        # Generate adjacency table
        Adj_mat = Table_generator(Elements,Geometry)

        # Generate bond matrix
        Bond_mats = find_lewis(Atom_types, Adj_mat, q_tot=charge, b_mat_only=True,verbose=False)        

        # Check the number of molecules
        Num_mol = mol_count(Adj_mat)
        if Num_mol > 1:
            print("ERROR in frag_mode_gen: {} molecules were discovered. Check the geometry of the input file. Exiting...".format(Num_mol))
            quit()

        # Remove cyclic angles
        cyclic_angles = []
        cyclic_angle_types = []
        del_list = []
        for count_i,i in enumerate(Angles):
            if Adj_mat[i[0],i[2]] == 1:

                # And the angle definition and index to appropriate lists
                cyclic_angles += [i]
                del_list += [count_i]

                # Add cyclic angle type that corresponds to the original mode
                cyclic_angle_types += [tuple(Angle_types[count_i])]

                # Add cycle angle type that corresponds to the actual model compound
                tmp = (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]])
                if tmp not in cyclic_angle_types and tmp[::-1] not in cyclic_angle_types:
                    cyclic_angle_types += [tmp]

        # Print diagnostic for removed angles
        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Cyclic Angles Removed"))
        print("{}".format("*"*144))
        for count_i,i in enumerate([ _ for _ in set(cyclic_angles)]):
            print("{}".format("-".join([str(Atom_types[_]) for _ in i])))
        print(" ")
        Angles = [ i for count_i,i in enumerate(Angles) if count_i not in del_list ]
        Angle_types = [ i for count_i,i in enumerate(Angle_types) if count_i not in del_list ]        
        Angle_atomtypes = [ i for count_i,i in enumerate(Angle_atomtypes) if count_i not in del_list ]        

        # Remove linear dihedrals (less than 5 degrees)
        linear_dihedrals = []
        linear_dihedral_types = []
        linear_atomtypes = []
        del_list = []
        for count_i,i in enumerate(Dihedrals):

            # Check 0-1-2 
            if 180.0 - acos(dot(Geometry[i[0]]-Geometry[i[1]],Geometry[i[2]]-Geometry[i[1]])/(norm(Geometry[i[0]]-Geometry[i[1]])*norm(Geometry[i[2]]-Geometry[i[1]])))*180.0/pi < 5.0:
                linear_dihedrals += [i]
                linear_dihedral_types += [tuple(Dihedral_types[count_i])] # Original mode
                linear_dihedral_types += [(Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]])] # Mode in model compound
                linear_atomtypes += [Dihedral_atomtypes[count_i]]
                del_list += [count_i]
            # Check 1-2-3
            elif 180.0 - acos(dot(Geometry[i[1]]-Geometry[i[2]],Geometry[i[3]]-Geometry[i[2]])/(norm(Geometry[i[1]]-Geometry[i[2]])*norm(Geometry[i[3]]-Geometry[i[2]])))*180.0/pi < 5.0:
                linear_dihedrals += [i]
                linear_dihedral_types += [tuple(Dihedral_types[count_i])] # Original mode
                linear_dihedral_types += [(Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]])] # Mode in model compound
                linear_atomtypes += [Dihedral_atomtypes[count_i]]
                del_list += [count_i]            

        # Remove coincident linear dihedrals that aren't already in the force field
        others = []
        for count_i,i in enumerate(linear_dihedrals):
            for j in [ count for count,_ in enumerate(Adj_mat[i[1]]) if _ == 1 and count != i[0] and count != i[2] ]:

                # Add linear type that corresponds to the actual model compound
                type_tmp = (Atom_types[j],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]] )
                if type_tmp not in linear_dihedral_types and type_tmp[::-1] not in linear_dihedral_types:
                    linear_dihedral_types += [type_tmp]
                    others += [ (j,i[1],i[2],i[3]) ]

                # Add linear type that corresponds to the original mode
                type_tmp = (linear_atomtypes[count_i][j].strip('link-'),linear_atomtypes[count_i][i[1]].strip('link-'),\
                            linear_atomtypes[count_i][i[2]].strip('link-'),linear_atomtypes[count_i][i[3]].strip('link-') )
                if type_tmp not in linear_dihedral_types and type_tmp[::-1] not in linear_dihedral_types:
                    linear_dihedral_types += [type_tmp]
                    others += [ (j,i[1],i[2],i[3]) ]

            for j in [ count for count,_ in enumerate(Adj_mat[i[2]]) if _ == 1 and count != i[3] and count != i[1] ]:            

                # Add linear type that corresponds to the actual model compound
                type_tmp = (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[j])
                if type_tmp not in linear_dihedral_types and type_tmp[::-1] not in linear_dihedral_types:
                    linear_dihedral_types += [type_tmp]
                    others += [ (i[0],i[1],i[2],j) ]

                # Add linear type that corresponds to the original mode
                type_tmp = (linear_atomtypes[count_i][i[0]].strip('link-'),linear_atomtypes[count_i][i[1]].strip('link-'),\
                            linear_atomtypes[count_i][i[2]],linear_atomtypes[count_i][j])
                if type_tmp not in linear_dihedral_types and type_tmp[::-1] not in linear_dihedral_types:
                    linear_dihedral_types += [type_tmp]
                    others += [ (i[0],i[1],i[2],j) ]

        # Add the coincident "others" to the linear_dihedrals list
        linear_dihedrals += others

        # Print diagnostic for removed dihedrals
        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Linear Dihedrals Removed"))
        print("{}".format("*"*144))
        for count_i,i in enumerate([ _ for _ in set(linear_dihedrals)]):
            print("{}".format("-".join([str(Atom_types[_]) for _ in i])))
        print(" ")        
        Dihedrals = [ i for count_i,i in enumerate(Dihedrals) if count_i not in del_list ]
        Dihedral_types = [ i for count_i,i in enumerate(Dihedral_types) if count_i not in del_list ]
        Dihedral_atomtypes = [ i for count_i,i in enumerate(Dihedral_atomtypes) if count_i not in del_list ]

        # Remove cyclic dihedrals
        cyclic_dihedrals = []
        cyclic_dihedral_types = []
        cyclic_atomtypes = []
        del_list = []
        for count_i,i in enumerate(Dihedrals):
            if i[3] in return_connected(Adj_mat,start=i[0],avoid=[i[1]]) and i[0] in return_connected(Adj_mat,start=i[3],avoid=[i[2]]):
                cyclic_dihedrals += [i]
                cyclic_dihedral_types += [tuple(Dihedral_types[count_i])] # Original mode
                cyclic_dihedral_types += [(Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]])] # Mode in model compound                
                cyclic_atomtypes += [Dihedral_atomtypes[count_i]]
                del_list += [count_i]

        # Remove coincident cyclic dihedrals
        others = []
        other_types = [ (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]] ) for i in cyclic_dihedrals+linear_dihedrals ]
        for count_i,i in enumerate(cyclic_dihedrals):

            for j in [ count for count,_ in enumerate(Adj_mat[i[1]]) if _ == 1 and count != i[0] ]:

                # Add linear type that corresponds to the actual model compound
                type_tmp = (Atom_types[j],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]] )
                if type_tmp not in cyclic_dihedral_types and type_tmp[::-1] not in cyclic_dihedral_types:
                    cyclic_dihedral_types += [type_tmp]
                    others += [ (j,i[1],i[2],i[3]) ]

                # Add linear type that corresponds to the original mode
                type_tmp = (cyclic_atomtypes[count_i][j].strip('link-'),cyclic_atomtypes[count_i][i[1]].strip('link-'),\
                            cyclic_atomtypes[count_i][i[2]],cyclic_atomtypes[count_i][i[3]])
                if type_tmp not in cyclic_dihedral_types and type_tmp[::-1] not in cyclic_dihedral_types:
                    cyclic_dihedral_types += [type_tmp]
                    others += [ (j,i[1],i[2],i[3]) ]

            for j in [ count for count,_ in enumerate(Adj_mat[i[2]]) if _ == 1 and count != i[3] ]:            

                # Add linear type that corresponds to the actual model compound
                type_tmp = (Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[j] )
                if type_tmp not in cyclic_dihedral_types and type_tmp[::-1] not in cyclic_dihedral_types:
                    cyclic_dihedral_types += [type_tmp]
                    others += [ (i[0],i[1],i[2],j) ]

                # Add linear type that corresponds to the original mode
                type_tmp = (cyclic_atomtypes[count_i][i[0]].strip('link-'),cyclic_atomtypes[count_i][i[1]].strip('link-'),\
                            cyclic_atomtypes[count_i][i[2]],cyclic_atomtypes[count_i][j])
                if type_tmp not in cyclic_dihedral_types and type_tmp[::-1] not in cyclic_dihedral_types:
                    cyclic_dihedral_types += [type_tmp]
                    others += [ (i[0],i[1],i[2],j) ]

        # Add the coincident "others" to the linear_dihedrals list
        cyclic_dihedrals += others
        
        # Print diagnostic for removed dihedrals
        print("\n{}".format("*"*144))
        print("* {:^140s} *".format("Cyclic Dihedrals Removed"))
        print("{}".format("*"*144))
        for count_i,i in enumerate([ _ for _ in set(cyclic_dihedrals)]):
            print("{}".format("-".join([str(Atom_types[_]) for _ in i])))
        print(" ")
        Dihedrals = [ i for count_i,i in enumerate(Dihedrals) if count_i not in del_list ]
        Dihedral_types = [ i for count_i,i in enumerate(Dihedral_types) if count_i not in del_list ]

        # Generate globally optimized geometry job: 
        gen_global_opt(Folder+'/geoopt/'+Folder+"_geoopt",Adj_mat,Elements,Geometry,Atom_types,charge=charge,multiplicity=multiplicity,procs=procs,\
                          theory=theory,constraints=constraints,local_relaxation=local_relaxation,functional=functional,basis=basis,D3_flag=D3_flag)

        # Generate bond files: loop over each bond type and call the function gen_bond_files
        # to output a chained xyz file that allows the stretch to be viewed in vmd, and a
        # series of orca input files that generate the FF data.
        if "bonds" in mode_list:
            for count_b,b in enumerate(Bonds):        
                Current_name = Folder+'/bonds/'+Folder+'_'+'-'.join([ str(j) for j in Bond_types[count_b]])
                if scan_opt == 0:
                    gen_bond_files(Current_name,gens,Adj_mat,b,Elements,Geometry,Bond_atomtypes[count_b],bond_step=b_disp/5.0,bond_disp=b_disp,\
                                   charge=charge,multiplicity=multiplicity,procs=procs,\
                                   theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,functional=functional,basis=basis,D3_flag=D3_flag)

                else:
                    gen_bond_scan_files(Current_name,gens,Adj_mat,b,Elements,Geometry,Bond_atomtypes[count_b],bond_step=b_disp/5.0,bond_disp=b_disp,\
                                        charge=charge,multiplicity=multiplicity,procs=procs,\
                                        theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,functional=functional,basis=basis,D3_flag=D3_flag)

        # Generate angle files: loop over each angle type and call the function gen_angle_files
        # to output a chained xyz file that allows the bend to be viewed in vmd, and a
        # series of orca input files that generate the FF data.
        if "angles" in mode_list:
            for count_a,a in enumerate(Angles):
                Current_name = Folder+'/angles/'+Folder+'_'+'-'.join([ str(i) for i in Angle_types[count_a]])
                if scan_opt == 0:
                    gen_angle_files(Current_name,gens,Adj_mat,a,Elements,Geometry,Angle_atomtypes[count_a],angle_step=a_disp/5.0,angle_disp=a_disp,\
                                    charge=charge,multiplicity=multiplicity,procs=procs,\
                                    theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,functional=functional,basis=basis,D3_flag=D3_flag)
                else:
                    gen_angle_scan_files(Current_name,gens,Adj_mat,a,Elements,Geometry,Angle_atomtypes[count_a],angle_step=a_disp/5.0,angle_disp=a_disp,\
                                         charge=charge,multiplicity=multiplicity,procs=procs,\
                                         theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,functional=functional,basis=basis,D3_flag=D3_flag)

        # generate dihedral files: loop over each dihedral type and call the function gen_dihedral_files
        # to output a chained xyz file that allows the dihedral to viewed in vmd, and a series of orca
        # input files that generate the FF data.
        if "dihedrals" in mode_list:
            for count_d,d in enumerate(Dihedrals):

                # The fragment generation algorithm has been updated and should now be fully compatible with fragment based harmonic dihedral parameterizations
#                 if no_harmonic_db == 0 and True in [ j in ["R","E","Z"] for j in Atom_types[d[1]].split('[')[0] ] and True in [ j in ["R","E","Z"] for j in Atom_types[d[2]].split('[')[0] ]:
#                     Current_name = Folder+'/dihedrals_harmonic/'+Folder+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
#                     gen_harmonic_dihedral_files(Current_name,gens,Adj_mat,d,Elements,Geometry,Dihedral_atomtypes[count_d],charge=charge,multiplicity=multiplicity,procs=procs,\
#                                                 theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,\
#                                                 dihedral_disp=h_disp,dihedral_step=h_disp/5.0,functional=functional,D3_flag=D3_flag)

                # # NEW ALGORITHM USES HYBRID FUNCTON
                # elif no_harmonic_db == 0 and Hybridization_of_type(Atom_types[d[1]]) == "sp2" and Hybridization_of_type(Atom_types[d[2]]) == "sp2":
                #     Current_name = Folder+'/dihedrals_harmonic/'+Folder+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                #     gen_harmonic_dihedral_files(Current_name,gens,Adj_mat,d,Elements,Geometry,Dihedral_atomtypes[count_d],charge=charge,multiplicity=multiplicity,procs=procs,\
                #                                 theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,\
                #                                 dihedral_disp=h_disp,dihedral_step=h_disp/5.0,functional=functional,D3_flag=D3_flag)


                # ( NEW CHECK USES BOND_MAT) If j is a harmonic dihedral then redundancy is assessed on the basis of all four mode 
                # indices matching (this is necessary beacuse of the way that harmonic dihedrals are scanned)
                if 2 in [ _[d[1],d[2]] for _ in Bond_mats ]:
                    Current_name = Folder+'/dihedrals_harmonic/'+Folder+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                    gen_harmonic_dihedral_files(Current_name,gens,Adj_mat,d,Elements,Geometry,Dihedral_atomtypes[count_d],charge=charge,multiplicity=multiplicity,procs=procs,\
                                                theory=theory,constraints=constraints,local_relaxation=local_relaxation,frag_opt=frag_opt,\
                                                dihedral_disp=h_disp,dihedral_step=h_disp/5.0,functional=functional,basis=basis,D3_flag=D3_flag)

                else:
                    if scan_opt == 0:
                        Current_name = Folder+'/dihedrals/'+Folder+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                        gen_fourier_dihedral_files(Current_name,gens,Adj_mat,d,Elements,Geometry,Dihedral_atomtypes[count_d],charge=charge,multiplicity=multiplicity,overlap_thresh=overlap_thresh,\
                        procs=procs,theory=theory,constraints=constraints,skip_clashes=skip_clashes,local_relaxation=local_relaxation,frag_opt=frag_opt,\
                        dihedral_step=d_step,functional=functional,basis=basis,D3_flag=D3_flag)
                    else:
                        Current_name = Folder+'/dihedrals/'+Folder+'_'+'-'.join([ str(i) for i in Dihedral_types[count_d]])
                        gen_fourier_dihedral_scan_files(Current_name,gens,Adj_mat,d,Elements,Geometry,Dihedral_atomtypes[count_d],charge=charge,multiplicity=multiplicity,overlap_thresh=overlap_thresh,\
                        procs=procs,theory=theory,constraints=constraints,skip_clashes=skip_clashes,local_relaxation=local_relaxation,frag_opt=frag_opt,\
                        dihedral_step=d_step,functional=functional,basis=basis,D3_flag=D3_flag)

        # Write master/globally optimized geometry with atom types to the parent directory
        atoms = sorted(set(Atom_types))
        with open(Folder+'/'+Folder+"_master.xyz",'w') as f:
            list_of_indices = sorted([ count_j for _ in set(atoms) for count_j,j in enumerate(Atom_types) if _ == j])
            f.write("{}\nIndices: {}\n".format(len(Elements),' '.join([ str(_) for _ in list_of_indices ])))
            for count_i,i in enumerate(Elements):
                f.write("{:<12s} {:< 20.14f} {:< 20.14f} {:< 20.14f} {:s}\n".format(i,Geometry[count_i,0],Geometry[count_i,1],Geometry[count_i,2],Atom_types[count_i]))
            f.close()

        # If no parametrization is needed then write the FF.db file for the atom
        undefined_params = linear_dihedrals + cyclic_dihedrals + cyclic_angles
        if len(Atom_types) == 1:
            print("Only a single atom in the geometry, no parametrizations needed. Writing parameters to {}...".format(Folder+'/'+Folder+".db"))
            write_single_params(Folder,Folder+".db",Elements[0],Atom_types[0],float(charge),Geometry[0])
        elif undefined_params != []:
            write_zero_params(Folder,"undefined.db",[],cyclic_angle_types,linear_dihedral_types+cyclic_dihedral_types,Atom_types,Elements,Geometry)

    print("\n{}".format("*"*144))
    print("* {:^140s} *".format("Success! Have a nice day!"))
    print("{}".format("*"*144))
    return

# Grab the modes being scanned from a -*.modes file
def read_modes(mode_file):

    Bonds                   = []
    Bond_types              = []
    Bond_atomtypes          = []
    Angles                  = []
    Angle_types             = []
    Angle_atomtypes         = []
    Dihedrals               = []
    Dihedral_types          = []
    Dihedral_atomtypes      = []
    bond_parse              = 0
    angle_parse             = 0
    dihedral_parse          = 0
    harmonic_dihedral_parse = 0
    with open(mode_file,'r') as f:
        for lines in f:
            fields = lines.split()

            # Commmands for parsing bonds are contained in this series of if/elif statements
            if  len(fields) == 2 and fields[0] == "bond" and fields[1] == "start":
                atom_types = []
                bond_parse = 1
                continue
            elif len(fields) == 2 and fields[0] == "bond" and fields[1] == "end":
                bond_parse = 0
                Bonds      += [ tuple(mode_ind) ]
                Bond_types += [ [ atom_types[i] for i in mode_ind ] ]
                Bond_atomtypes += [ atom_types ]
                continue
            elif bond_parse == 1:
                bond_parse += 1
                continue
            elif bond_parse == 2:
                mode_ind = [ int(i) for i in fields[0].split('_') ]
                bond_parse += 1
            elif bond_parse == 3:
                atom_types += [fields[0]]
                continue

            # Commmands for parsing angles are contained in this series of if/elif statements
            if  len(fields) == 2 and fields[0] == "angle" and fields[1] == "start":
                atom_types = []
                angle_parse = 1
                continue
            elif len(fields) == 2 and fields[0] == "angle" and fields[1] == "end":
                angle_parse = 0
                Angles      += [ tuple(mode_ind) ]
                Angle_types += [ [ atom_types[i] for i in mode_ind ] ]
                Angle_atomtypes += [ atom_types ]
                continue
            elif angle_parse == 1:
                angle_parse += 1
                continue
            elif angle_parse == 2:
                mode_ind = [ int(i) for i in fields[0].split('_') ]
                angle_parse += 1
            elif angle_parse == 3:
                atom_types += [fields[0]]
                continue

            # Commmands for parsing dihedrals are contained in this series of if/elif statements
            if  len(fields) == 2 and fields[0] == "dihedral" and fields[1] == "start":
                atom_types = []
                dihedral_parse = 1
                continue
            elif len(fields) == 2 and fields[0] == "dihedral" and fields[1] == "end":
                dihedral_parse = 0
                Dihedrals      += [ tuple(mode_ind) ]
                Dihedral_types += [ [ atom_types[i] for i in mode_ind ] ]
                Dihedral_atomtypes += [ atom_types ]
                continue
            elif dihedral_parse == 1:
                dihedral_parse += 1
                continue
            elif dihedral_parse == 2:
                mode_ind = [ int(i) for i in fields[0].split('_') ]
                dihedral_parse += 1
            elif dihedral_parse == 3:
                atom_types += [fields[0]]
                continue

            # Commmands for parsing harmonic dihedrals are contained in this series of if/elif statements
            if  len(fields) == 2 and fields[0] == "harmonic_dihedral" and fields[1] == "start":
                atom_types = []
                harmonic_dihedral_parse = 1
                continue
            elif len(fields) == 2 and fields[0] == "harmonic_dihedral" and fields[1] == "end":
                harmonic_dihedral_parse = 0
                Dihedrals      += [ tuple(mode_ind) ]
                Dihedral_types += [ [ atom_types[i] for i in mode_ind ] ]
                Dihedral_atomtypes += [ atom_types ]
                continue
            elif harmonic_dihedral_parse == 1:
                harmonic_dihedral_parse += 1
                continue
            elif harmonic_dihedral_parse == 2:
                mode_ind = [ int(i) for i in fields[0].split('_') ]
                harmonic_dihedral_parse += 1
            elif harmonic_dihedral_parse == 3:
                atom_types += [fields[0]]
                continue

    return Bonds,Bond_types,Bond_atomtypes,Angles,Angle_types,Angle_atomtypes,Dihedrals,Dihedral_types,Dihedral_atomtypes 

# Description: Calculates the dihedral angle (in radians) for
#              a quadruplet of atoms
#
# Inputs:      xyz: a 4x3 numpy array, where each row holds the 
#                   cartesian position of each atom and row indices
#                   determine placement in the dihedral ( i.e, which
#                   atoms correspond to 1-2-3-4 in the dihedral )
# 
# Returns:    angle: dihedral angle in radians
#
def dihedral_calc(xyz):
    
    # Calculate the 2-1 vector           
    v1 = (xyz[1]-xyz[0]) 
                                                             
    # Calculate the 3-2 vector           
    v2 = (xyz[2]-xyz[1]) 
                                                             
    # Calculate the 4-3 bond vector      
    v3 = (xyz[3]-xyz[2]) 

    # Calculate dihedral (funny arctan2 formula avoids the use of arccos and retains the sign of the angle)
    angle = arctan2( dot(v1,cross(v2,v3))*(dot(v2,v2))**(0.5) , dot(cross(v1,v2),cross(v2,v3)) )
    
    return angle

# Description: finds the number of disconnected subnetworks in the 
#              adjacency matrix, which corresponds to the number of 
#              separate molecules.
#
# Inputs:      adj_mat: numpy array holding a 1 in the indices of bonded
#                        atom types. 
#
# Returns:     mol_count: scalar, the number of molecules in the adj_mat
def mol_count(adj_mat):
    
    # Initialize list of atoms assigned to molecules and a counter for molecules
    placed_idx = []    
    mol_count = 0

    # Continue the search until all the atoms have been assigned to molecules
    while len(placed_idx)<len(adj_mat):

        # Use sequential elements of the adj_mat as seeds for the spanning network search
        for count_i,i in enumerate(adj_mat):

            # Only proceed with search if the current atom hasn't been placed in a molecule
            if count_i not in placed_idx:

                # Increment mol_count for every new seed and add the seed to the list of placed atoms
                mol_count += 1               
                placed_idx += [count_i]
                
                # Find connections
                idx = [ count_j for count_j,j in enumerate(i) if j==1 and count_j not in placed_idx ]
                
                # Continue until no new atoms are found
                while len(idx) > 0:
                    current = idx.pop(0)
                    if current not in placed_idx:
                        placed_idx += [current]
                        idx += [ count_k for count_k,k in enumerate(adj_mat[current]) if k == 1 and count_k not in placed_idx ]
    return mol_count

# # Generates the adjacency matrix 
# def Table_generator(Elements,Geometry):

#     # Initialize UFF parameters (tuple corresponds to eps,sigma pairs for each element)
#     # Taken from UFF (Rappe et al. JACS 1992)
#     # Note: LJ parameters in the table are specificed in the eps,r_min form rather than eps,sigma
#     #       the conversion between r_min and sigma is sigma = r_min/2^(1/6)
#     # Note: Units for sigma = angstroms and eps = kcal/mol 
#     Radii = {  'H':2.57, 'He':2.10,\
#               'Li':2.18, 'Be':2.45,                                                                                                                'B':3.64,  'C':3.43,  'N':3.26,  'O':3.12,  'F':3.00, 'Ne':2.89,\
#               'Na':2.66, 'Mg':2.69,                                                                                                               'Al':4.01, 'Si':3.83,  'P':3.69,  'S':3.59, 'Cl':3.52, 'Ar':3.45,\
#                'K':3.40, 'Ca':3.03, 'Sc':2.94, 'Ti':2.83,  'V':2.80, 'Cr':2.69, 'Mn':2.64, 'Fe':2.59, 'Co':2.56, 'Ni':2.52, 'Cu':3.11, 'Zn':2.46, 'Ga':3.90, 'Ge':3.81, 'As':3.77, 'Se':3.75, 'Br':3.73, 'Kr':3.69,\
#               'Rb':3.67, 'Sr':3.24,  'Y':2.98, 'Zr':2.78, 'Nb':2.82, 'Mo':2.72, 'Tc':2.67, 'Ru':2.64, 'Rh':2.61, 'Pd':2.58, 'Ag':2.80, 'Cd':2.54, 'In':3.98, 'Sn':3.91, 'Sb':3.94, 'Te':3.98,  'I':4.01, 'Xe':3.92,\
#               'Cs':4.02, 'Ba':3.30, 'La':2.80, 'Hf':2.80, 'Ta':2.82,  'W':2.73, 'Re':2.63, 'Os':2.78, 'Ir':2.53, 'Pt':2.45, 'Au':2.93, 'Hg':2.41, 'Tl':3.87, 'Pb':3.83, 'Bi':3.89, 'Po':4.20, 'At':4.23, 'Rn':4.25,\
#               'default' : 1.8 }
    
#     # Scale factor is used for determining the bonding threshold. The heuristic 0.6 is used
#     scale_factor = 0.55

#     # Print warning for uncoded elements.
#     for i in Elements:
#         if i not in Radii.keys():
#             print "ERROR: The geometry contains an element ({}) that the Table_generator function doesn't have bonding information for. This needs to be directly added to the Radii".format(i)+\
#                   " dictionary before proceeding. Exiting..."
#             quit()


#     # Generate distance matrix holding atom-atom separations (only save upper right)
#     Dist_Mat = triu(cdist(Geometry,Geometry))
    
#     # Find plausible connections
#     x_ind,y_ind = where( (Dist_Mat > 0.0) & (Dist_Mat < max([ Radii[i]*scale_factor for i in Radii.keys() ])) )

#     # Initialize Adjacency Matrix
#     Adj_mat = zeros([len(Geometry),len(Geometry)])

#     # Iterate over plausible connections and determine actual connections
#     for count,i in enumerate(x_ind):
        
#         # Assign connection if the ij separation is less than the UFF-sigma value times the scaling factor
#         if Dist_Mat[i,y_ind[count]] < (Radii[Elements[i]]+Radii[Elements[y_ind[count]]])/2.0*scale_factor:
#             Adj_mat[i,y_ind[count]]=1

#     # Hermitize Adj_mat
#     Adj_mat=Adj_mat + Adj_mat.transpose()

#     return Adj_mat

# def xyz_parse(input):

#     # Open file and read contents into variable
#     with open(input,'r') as f:
#             content=f.readlines()

#     # Find number of atoms and initialize various matrices
#     Atom_Number = int(content[0].split()[0])
#     Elements = ['']*Atom_Number
#     Geometry = zeros([Atom_Number,3])
#     Atom_types = [0]*Atom_Number

#     # Iterate over the remainder of contents and read the
#     # geometry and elements into variable. Note that the
#     # first two lines are considered a header
#     count=0
#     for lines in content[2:]:
#         fields=lines.split()

#         # Skip empty lines
#         if len(fields) == 0:
#             continue

#         # Write geometry containing lines to variable
#         if len(fields) > 3:
#             Elements[count]=fields[0]
#             Geometry[count,:]=array([float(fields[1]),float(fields[2]),float(fields[3])])

#             # If atom type information is stored in the fifth column it is saved to variable
#             if len(fields) >= 5:
#                 Atom_types[count] = fields[4]

#             # If the nuclear charge is stored in the sixth column it is saved to variable
#             if len(fields) >= 6:
#                 Charges[count]=float(fields[5])
#             count = count + 1

#     return Elements,Geometry,Atom_types

def Structure_finder(Adj_mat):

    # The Structure variable holds the highest structure factor for each atom
    # (atoms might be part of several rings, only the largest is documented)
    # Values correspond to the following structural features:
    # 0: terminal (e.g. hydrogens)
    # 1: chain (e.g. methylene)
    # 2: branch point (e.g. Carbon attached to 3 or more other carbons; -2 indicates a possible chiral center based on coordination)
    # 3: 3-membered ring
    # 4: 4-membered ring
    # 5: 5-membered ring
    # 6: 6-membered ring
    # 7: 7-membered ring
    # 8: 8-membered ring
    Structure = array([-1]*len(Adj_mat))
    # Remove terminal sites (sites with only a single length 2
    # self walk). Continue until all of the terminal structure 
    # has been removed from the topology. NOTE: THIS VERSION DIFFERS FROM POLYGEN BY ITS INDIFFERENCE TO HEAD AND TAIL
    Adj_trimmed = copy(Adj_mat)
    ind_trim = [ count for count,i in enumerate(diag(dot(Adj_trimmed,Adj_trimmed))) if i == 1 ]
    Structure[ind_trim]=0

    # Remove terminal sites
    Adj_trimmed[:,ind_trim] = 0
    Adj_trimmed[ind_trim,:] = 0
    ind_trim = []

    # Find branch points (at this point all hydrogens have been removed, all remaining atoms with
    # over two connected neighbors are at least branches)
    branch_ind = [ count for count,i in enumerate(diag(dot(Adj_trimmed,Adj_trimmed))) if i > 2 ]

    while( len(ind_trim) > 0 ):

        # Remove remaining terminal sites to reveal cyclic structures (This time, the head and tail can be removed
        ind_trim = ind_trim + [ count for count,i in enumerate(diag(dot(Adj_trimmed,Adj_trimmed))) if i == 1 ]
        Structure[ind_trim] = 1

        # Remove terminal sites
        Adj_trimmed[:,ind_trim] = 0
        Adj_trimmed[ind_trim,:] = 0
        ind_trim = []

    # Label branches. This has to be done here otherwise it would get overwritten during the while loop
    Structure[branch_ind] = 2

    # Label possible chiral centers (narrow down to 4-centered branch sites (remove sp2 carbon type branches))
    Chiral_ind = [ i for i in branch_ind if sum(Adj_mat[i]) == 4 ]
    Structure[Chiral_ind] = -2

    # Find non-repeating looping walks of various lengths to identify rings
    # Algorithm: Non-repeating walks are conducted over the trimmed adjacency matrix to 
    tmp=zeros([len(Adj_trimmed),len(Adj_trimmed)])
    for i in range(len(Adj_trimmed)):

        # If the structure of the current atom is already known, then it is skipped
#        if Structure[i] in [1,2]:
#            continue

        # Instantiate generation lists. These hold tupels where the first entry is the connected
        # vertex and the second site is the previous vertex) 
        Gen_1 = []
        Gen_2 = []
        Gen_3 = []
        Gen_4 = []
        Gen_5 = []
        Gen_6 = []
        Gen_7 = []
        Gen_8 = []

        # Find 1st generation connections to current atom. (connection site, previous site)
        Gen_1 = [ (count_z,i) for count_z,z in enumerate(Adj_trimmed[i,:]) if z == 1 ]

        # Loop over the 1st generation connections and find the connected atoms. Avoid back hops using the previous site information 
        for j in Gen_1:
            Gen_2 = Gen_2 +  [ (count_z,j[0],j[1]) for count_z,z in enumerate(Adj_trimmed[j[0],:]) if (z == 1 and count_z not in j[0:-1]) ]
            
        # Loop over the 2nd generation connections and find the connected atoms. Avoid back hops using the previous site information
        for k in Gen_2:
            Gen_3 = Gen_3 + [ (count_z,k[0],k[1],k[2]) for count_z,z in enumerate(Adj_trimmed[k[0],:]) if (z == 1 and count_z not in k[0:-1]) ]
        # Find complete loops, store structure factor, and remove looping sequences from Gen_3 (avoids certain fallacious loops)
        del_ind = [ count_k for count_k,k in enumerate(Gen_3) if k[0] == i ]
        if len(del_ind) > 0:
            if Structure[i] in [1,2]:
                Structure[i] = int(str(Structure[i])+str(3))
            else:
                Structure[i]=3
            Gen_3 = [ z for count_z,z in enumerate(Gen_3) if count_z not in del_ind ]

        # Loop over the 3rd generation connections and find the connected atoms. Avoid back hops using the previous site information        
        for l in Gen_3:
            Gen_4 = Gen_4 + [ (count_z,l[0],l[1],l[2],l[3]) for count_z,z in enumerate(Adj_trimmed[l[0],:]) if (z == 1 and count_z not in l[0:-1]) ]
        # Find complete loops, store structure factor, and remove looping sequences from Gen_3 (avoids certain fallacious loops)
        del_ind = [ count_l for count_l,l in enumerate(Gen_4) if l[0] == i ]
        if len(del_ind) > 0:
            if Structure[i] in [1,2]:
                Structure[i] = int(str(Structure[i])+str(4))
            else:
                Structure[i]=4
            Gen_4 = [ z for count_z,z in enumerate(Gen_4) if count_z not in del_ind ]

        # Loop over the 4th generation connections and find the connected atoms. Avoid back hops using the previous site information
        for m in Gen_4:
            Gen_5 = Gen_5 + [ (count_z,m[0],m[1],m[2],m[3],m[4]) for count_z,z in enumerate(Adj_trimmed[m[0],:]) if (z == 1 and count_z not in m[0:-1]) ]
        # Find complete loops, store structure factor, and remove looping sequences from Gen_3 (avoids certain fallacious loops)
        del_ind = [ count_m for count_m,m in enumerate(Gen_5) if m[0] == i ]
        if len(del_ind) > 0:
            if Structure[i] in [1,2]:
                Structure[i] = int(str(Structure[i])+str(5))
            else:
                Structure[i]=5
            Gen_5 = [ z for count_z,z in enumerate(Gen_5) if count_z not in del_ind ]

        # Loop over the 5th generation connections and find the connected atoms. Avoid back hops using the previous site information
        for n in Gen_5:
            Gen_6 = Gen_6 + [ (count_z,n[0],n[1],n[2],n[3],n[4],n[5]) for count_z,z in enumerate(Adj_trimmed[n[0],:]) if (z == 1 and count_z not in  n[0:-1]) ]
        # Find complete loops, store structure factor, and remove looping sequences from Gen_3 (avoids certain fallacious loops)
        del_ind = [ count_n for count_n,n in enumerate(Gen_6) if n[0] == i ]
        if len(del_ind) > 0:
            if Structure[i] in [1,2]:
                Structure[i] = int(str(Structure[i])+str(6))
            else:
                Structure[i]=6
            Gen_6 = [ z for count_z,z in enumerate(Gen_6) if count_z not in del_ind ]

        # Loop over the 6th generation connections and find the connected atoms. Avoid back hops using the previous site information
        for o in Gen_6:
            Gen_7 = Gen_7 + [ (count_z,o[0],o[1],o[2],o[3],o[4],o[5],o[6]) for count_z,z in enumerate(Adj_trimmed[o[0],:]) if (z == 1 and count_z not in o[0:-1]) ]
        # Find complete loops, store structure factor, and remove looping sequences from Gen_3 (avoids certain fallacious loops)
        del_ind = [ count_o for count_o,o in enumerate(Gen_7) if o[0] == i ]
        if len(del_ind) > 0:
            if Structure[i] in [1,2]:
                Structure[i] = int(str(Structure[i])+str(7))
            else:
                Structure[i]=7
            Gen_7 = [ z for count_z,z in enumerate(Gen_7) if count_z not in del_ind ]

        # Loop over the 7th generation connections and find the connected atoms. Avoid back hops using the previous site information
        for p in Gen_7:
            Gen_8 = Gen_8 + [ (count_z,p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]) for count_z,z in enumerate(Adj_trimmed[p[0],:]) if (z == 1 and count_z not in p[0:-1]) ]
        # Find complete loops, store structure factor, and remove looping sequences from Gen_3 (avoids certain fallacious loops)
        del_ind = [ count_p for count_p,p in enumerate(Gen_7) if p[0] == i ]
        if len(del_ind) > 0:
            if Structure[i] in [1,2]:
                Structure[i] = int(str(Structure[i])+str(8))
            else:
                Structure[i]=8
            Gen_8 = [ z for count_z,z in enumerate(Gen_8) if count_z not in del_ind ]

    # Any remaining atoms with unassigned structure must be chain atoms connecting cyclic units. 
    Structure[Structure==-1] = 1 

    return Structure

# Description: This subprogram finds the chirality of bond-priority ordering of the 
# various branch points in the topology
def Find_centers(Elements,Adj_mat,Structure):

    # Dictionary of masses are needed to apply the CIP rules 
    Masses = {'H':1.00794,'He':4.002602,'Li':6.941,'Be':9.012182,'B':10.811,'C':12.011,'N':14.00674,'O':15.9994,'F':18.9984032,'Ne':20.1797,\
            'Na':22.989768,'Mg':24.3050,'Al':26.981539,'Si':28.0855,'P':30.973762,'S':32.066,'Cl':35.4527,'Ar':39.948,'Ge':72.61,'As':74.92159,\
             'Se':78.96,'Br':79.904,'I':126.90447}

    # Find branches based on Structure variable
    Chiral_indices = [ count_i for count_i,i in enumerate(Structure) if i == 2 ]
    
    # Narrow down to 4-centered branch sites (remove sp2 carbon type branches)
    Chiral_indices = [ i for i in Chiral_indices if sum(Adj_mat[i] == 4) ]
        
    # The hybridization of each atom is needed to determine priority ordering
    # According to CIP rules, double bonded atoms are listed twice.
    Hybridizations = ['X']*len(Adj_mat)

    # At each step in the chirality finding algorithm it is necessary to write the 
    # Neighboring elements to variable. For convenience a list of len(Adj_mat) is 
    # used for that the elements can be stored to their
    Finished = [0]*len(Chiral_indices)
    
    for i in Chiral_indices:

        # Find connected atoms and coordination number
        Coord_ind = [ count_k for count_k,k in enumerate(Adj_mat[j]) if k == 1 ]
        Coord_number = len(Coord_ind)

        # The algorithm follows each of the four branches and records their
        # priority lists (i.e. first element, followed by coordinated elements
        # in order of priority). 
        Priority_list_1 = [Elements[Coord_ind[0]]]
        Priority_list_2 = [Elements[Coord_ind[1]]]
        Priority_list_3 = [Elements[Coord_ind[2]]]
        Priority_list_4 = [Elements[Coord_ind[3]]]

        for chain in range(4):

            

            while (completion_flag == 0):

                # Find the hybridization of the current atom                                                      
                # based upon element and coordination number
                if Elements[i] in ['C','Si','Ge']:
                    if Coord_number == 2:
                        Hybridizations[i] = 'sp'
                    elif Coord_number == 3:
                        Hybridizations[i] = 'sp2'
                    elif Coord_number == 4:
                        Hybridizations[i] = 'sp3'

                elif Elements[i] in ['N','P','As']:
                    if Coord_number == 1:
                        Hybridizations[i] = 'sp'
                    elif Coord_number == 2:
                        Hybridizations[i] = 'sp2'
                    elif Coord_number == 3:
                        Hybridizations[i] = 'sp3'

                elif Elements[i] in ['O','S','Se']:
                    if Coord_number == 1:
                        Hybridizations[i] = 'sp2'
                    elif Coord_number == 2:
                        Hybridizations[i] = 'sp3'

                elif Elements[i] in ['H']:
                    if Coord_number == 1:
                        Hybridizations[i] = 's' 

                    else: 
                        print("ERROR: hybridization of {} atom could not be determined! Exiting...".format(j))


        
        neighbors = [ count_j for count_j,j in enumerate(Adj_mat[i]) if j == 1 ]
        
        # Arrange in order of priority
        neighbors =  neighbors[array([ Masses[Elements[j]] for j in neighbors ]).argsort()]

        # Find ties
        if Masses[Elements[neighbors[0]]] != Masses[Elements[neighbors[1]]]:
            Finished[0] = 1
        if Masses[Elements[neighbors[1]]] != Masses[Elements[neighbors[2]]]:
            Finished[1] = 1
        if Masses[Elements[neighbors[2]]] != Masses[Elements[neighbors[3]]]:
            Finished[2] = 1
        if Masses[Elements[neighbors[3]]] != Masses[Elements[neighbors[4]]]:
            Finished[3] = 1

# Description: This is a simple implementation of the Dijkstra algorithm for 
#              finding the backbone of a polymer 
def Dijkstra(Adj_mat):

    # Remove terminal sites (sites with only a single length 2
    # self walk). Continue until all of the terminal structure 
    # has been removed from the topology.
    Adj_trimmed = copy(Adj_mat)
    ind_trim = [ count for count,i in enumerate(diag(dot(Adj_trimmed,Adj_trimmed))) if i == 1 ]

    # Remove terminal sites
    Adj_trimmed[:,ind_trim] = 0
    Adj_trimmed[ind_trim,:] = 0
    ind_trim = []

    # Initialize Distances, Previous, and Visited lists    
    Distances = array([0] + [100000]*(len(Adj_mat)-1)) # Holds shortest distance to origin from each site
    Previous = array([0]*len(Adj_mat)) # Holds the previous site on the short distance to origin
    Visited = [0]*len(Adj_mat) # Holds which sites have been visited

    # Initialize current site and neighbors list
    i = 0 # current site
    neighbors = []

    # Iterate through sites. At each step find the shortest distance between all of hte 
    # current sites neighbors and the START. Update the shortest distances of all sites
    # and choose the next site to iterate on based on which has the shortest distance of
    # among the UNVISITED set of sites. Once the terminal site is identified the shortest
    # path has been found
    while( 0 in Visited):

        # If the current site is the terminal site, then the algorithm is finished
        if i == len(Adj_trimmed)-1:
            break

        # Add new neighbors to the list
        neighbors = [ count_j for count_j,j in enumerate(Adj_trimmed[i]) if j == 1 ]

        # Remove the current site from the list of unvisited
        Visited[i] = 1

        # Iterate over neighbors and update shortest paths
        for j in neighbors:

            # Update distances for current generation of connections
            if Distances[i] + Adj_trimmed[j,i] < Distances[j]:
                Distances[j] = Distances[i] + Adj_trimmed[j,i]
                Previous[j] = i
        
        # Find new site 
        tmp = min([ j for count_j,j in enumerate(Distances) if Visited[count_j] == 0])
        i = [ count_j for count_j,j in enumerate(Distances) if j == tmp and Visited[count_j] == 0 ][0]
        
    # Find shortest path by iterating backwards
    # starting with the end site.
    Shortest_path = [len(Adj_trimmed)-1]    
    i=len(Adj_trimmed)-1

    while( i != 0):
        Shortest_path = Shortest_path + [Previous[i]]    
        i = Previous[i]

    # Reverse order of the list to go from start to finish
    Shortest_path = Shortest_path[::-1]
    return Shortest_path

def gen_global_opt(Name,Adj_mat,Elements,Geometry,Atom_types,output='orca',charge=0,multiplicity=1,procs=8,theory=['DFT','MP2'],constraints=" ",local_relaxation=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating global optimization calculation")
    
    N_Geometry = copy(Geometry)                       # Copy the geometry
    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(Adj_mat)
    if "angles" in constraints:
        Angle_list = Find_all_angles(Adj_mat)
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(Adj_mat)

    # Write xyz for viewing
    with open(Save_Folder+'/'+Save_Name+'.xyz','w') as f:
        f.write('{}\n\n'.format(len(N_Geometry)))
        for count_j,j in enumerate(N_Geometry):
            f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(Elements[count_j],j[0],j[1],j[2]))

    # Write Orca file
    if output == 'orca':

        # Open file
        with open(Save_Folder+'/'+Save_Name+'.in','w') as f:

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "geoopt"\n'.format(functional,basis))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt CHELPG\n\n%base "geoopt"\n'.format(functional,basis))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "geoopt"\n'.format(functional,basis))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt CHELPG\n\n%base "geoopt"\n'.format(functional,basis))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "geoopt"\n'.format(functional,basis,procs))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "geoopt"\n'.format(functional,basis,procs))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "geoopt"\n'.format(functional,basis,procs))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "geoopt"\n'.format(functional,basis,procs))

            # Increase default max number of geometry iterations
            f.write("\n%geom MaxIter 500\nend\n")

            # Write Geometry constraint(s)    
            if len(Bond_list) + len(Angle_list) + len(Dihedral_list) > 0:
                f.write('\n%geom\n  Constraints\n')
                for j in Bond_list:
                    f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
                for j in Angle_list:
                    f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
                for j in Dihedral_list:
                    f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
                f.write('  end\nend\n')

            # Increase default max scf iterations
            f.write('\n%scf\nMaxIter 1000\nend\n')

            # Add print statements for different charge definitions
            f.write('\n%output\n')
            f.write('  {}\n  {}\n  {}\n  {}\n  {}\nend\n'.format('Print[ P_Mayer ] 1','Print[ P_NatPop ] 1','Print[ P_Hirshfeld ] 1', 'Print[ P_Mulliken ] 1','Print [ P_Loewdin ] 1'))

            # Write Coordinate header
            f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

            # Write Geometry
            for count_j,j in enumerate(N_Geometry):
                f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(Elements[count_j],j[0],j[1],j[2]))
            f.write('*\n')

            # Write RI-MP2 single point calculation
            if "mp2" in [ j.lower() for j in theory ]: 
                if charge < 0:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "geoopt_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n')
                else:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "geoopt_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n')
                f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

    return

# Generates run files for parallel scanning of bond modes
def gen_bond_files(Name,gens,Adj_mat,B,Elements,Geometry,Atom_types,bond_step=0.02,bond_disp=0.1,output='orca',charge=0,multiplicity=1,procs=8,\
                   theory=['DFT','MP2'],constraints=" ",local_relaxation=0,frag_opt=0,functional='B3LYP',basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating parametrization calculations for bond: {}-{}".format(Atom_types[B[0]],Atom_types[B[1]]))

    if frag_opt == 1:
        B,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(B,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                       # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                        # Copy the adj_mat
        N_Elements = copy(Elements)
        N_Atom_types = copy(Atom_types)

    # Calculate some prerequisites for generating the scan
    disp_vec = N_Geometry[B[0]]-N_Geometry[B[1]]      # Calculate the bond vector
    disp_vec = disp_vec/norm(disp_vec)                # Normalize the displacement vector
    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Make subdirectory to hold the current bond stretch files
    os.makedirs(Save_Folder+'/{}_{}'.format(N_Atom_types[B[0]],N_Atom_types[B[1]]))   

    # Check if the symmetric elongation protocol can be used (i.e. if the bond separates the molecule into
    # two halves then each halve can move as a whole during the elongation/contraction generation.
    set_0 = return_connected(Adj_mat,start=B[0],avoid=[B[1]])
    set_1 = return_connected(Adj_mat,start=B[1],avoid=[B[0]])
    if set_0.isdisjoint(set_1):
        use_sym = True
    else:
        use_sym = False

    # symmetrically elongate the bond to its longest (bond_disp + r_eq)
    if use_sym == False:
        N_Geometry[B[0]] += bond_disp/2*disp_vec 
        N_Geometry[B[1]] -= bond_disp/2*disp_vec     
    else:
        for i in set_0:
            N_Geometry[i] += bond_disp/2*disp_vec
        for i in set_1:
            N_Geometry[i] -= bond_disp/2*disp_vec

    # Initialize the number of steps
    steps = int(ceil(bond_disp/bond_step)*2+1)

    # For local relaxations all bonds and angles involving B-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(B,N_Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:        
        Bond_list = Find_all_bonds(N_Adj_mat)
        if B in Bond_list: Bond_list.remove(B)
        else: Bond_list.remove((B[1],B[0]))
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(N_Adj_mat)
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(N_Adj_mat)
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]

    # Generate bond files
    for i in range(steps):
        
        # Append linked xyz for viewing the stretch in VMD
        with open(Save_Folder+'/'+Save_Name+'.xyz','a') as f:
            f.write('{}\n\n'.format(len(N_Geometry)))
            for count_j,j in enumerate(N_Geometry):
                f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))

        # Write Orca file
        if output == 'orca':
            
            # Make sub-subdir for current file
            os.makedirs(Save_Folder+'/{}_{}/{}'.format(N_Atom_types[B[0]],N_Atom_types[B[1]],i))

            # Write geometry for the current configuration
            write_mode_geo(Save_Folder+'/{}_{}/{}/'.format(N_Atom_types[B[0]],N_Atom_types[B[1]],i)+Save_Name+'_'+str(i)+'.xyz',N_Elements,N_Geometry,N_Atom_types)

            # Open file
            with open(Save_Folder+'/{}_{}/{}/'.format(N_Atom_types[B[0]],N_Atom_types[B[1]],i)+Save_Name+'_'+str(i)+'.in','w') as f:
                
                # Write DFT Header
                if procs == 1:
                    if charge < 0:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                    else:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                else:
                    if charge < 0:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                    else:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))

                # Increase default max number of geometry iterations
                f.write("\n%geom MaxIter 500\nend\n")

                # Write Geometry constraint(s)    
                f.write('\n%geom\n  Constraints\n    {{ B {} {} C }}\n'.format(B[0],B[1]))
                for j in Bond_list:
                    f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
                for j in Angle_list:
                    f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
                for j in Dihedral_list:
                    f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
                f.write('  end\nend\n\n')

                # Write Coordinate header
                f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

                # Write Geometry
                for count_j,j in enumerate(N_Geometry):
                    f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
                f.write('*\n')

                # Write RI-MP2 single point calculation
                if "mp2" in [ j.lower() for j in theory ]: 
                    if charge < 0:
                        f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format(i))
                    else:
                        f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format(i))
                    f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

        # Symmetrically contract the bond (this is applied here so that the first loop 
        # writes the fully elongated geometry.)
        if use_sym == False:
            N_Geometry[B[0]] -= bond_step/2*disp_vec 
            N_Geometry[B[1]] += bond_step/2*disp_vec     
        else:
            for i in set_0:
                N_Geometry[i] -= bond_step/2*disp_vec
            for i in set_1:
                N_Geometry[i] += bond_step/2*disp_vec

    return

# Generates run files for continuously scanned bond modes
# This version performs a preliminary unconstrained geometry relaxation then performed the constrained mode scan
def gen_bond_scan_files(Name,gens,Adj_mat,B,Elements,Geometry,Atom_types,bond_step=0.02,bond_disp=0.1,output='orca',charge=0,multiplicity=1,procs=8,\
                          theory=['DFT','MP2'],constraints=" ",local_relaxation=0,frag_opt=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating parametrization calculations for bond: {}-{}".format(Atom_types[B[0]],Atom_types[B[1]]))

    if frag_opt == 1:
        B,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(B,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                       # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                        # Copy the adj_mat
        N_Elements = copy(Elements)
        N_Atom_types = copy(Atom_types)

    # Calculate some prerequisites for generating the scan
    disp_vec = N_Geometry[B[0]]-N_Geometry[B[1]]          # Calculate the bond vector
    disp_vec = disp_vec/norm(disp_vec)                # Normalize the displacement vector
    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Make subdirectory to hold the current bond stretch files
    os.makedirs(Save_Folder+'/{}_{}'.format(N_Atom_types[B[0]],N_Atom_types[B[1]]))   
    
    # calculate mode details
    initial_value = norm(N_Geometry[B[0]]-N_Geometry[B[1]]) - bond_disp
    final_value   = initial_value+2.0*bond_disp
    steps         = int(round(2.0*bond_disp/bond_step))+1
    
    # For local relaxations all bonds and angles involving B-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(B,N_Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(N_Adj_mat)
        if B in Bond_list: Bond_list.remove(B)
        else: Bond_list.remove((B[1],B[0]))
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(N_Adj_mat)
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(N_Adj_mat)
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]

    ######################
    # Generate bond scan #
    ######################
        
    # Append linked xyz for viewing the stretch in VMD
    with open(Save_Folder+'/'+Save_Name+'.xyz','a') as f:
        f.write('{}\n\n'.format(len(N_Geometry)))
        for count_j,j in enumerate(N_Geometry):
            f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))

    # Write Orca file
    if output == 'orca':

        # Make sub-subdir for current file
        os.makedirs(Save_Folder+'/{}_{}/{}'.format(N_Atom_types[B[0]],N_Atom_types[B[1]],"scan"))

        # Write geometry for the current configuration
        write_mode_geo(Save_Folder+'/{}_{}/{}/'.format(N_Atom_types[B[0]],N_Atom_types[B[1]],"scan")+Save_Name+'_scan.xyz',N_Elements,N_Geometry,N_Atom_types)

        # Open file
        with open(Save_Folder+'/{}_{}/{}/'.format(N_Atom_types[B[0]],N_Atom_types[B[1]],"scan")+Save_Name+'_scan.in','w') as f:

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))

            # Write Coordinate header
            f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

            # Write Geometry
            for count_j,j in enumerate(N_Geometry):
                f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
            f.write('*\n\n')

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run bond scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))

            # Increase default max number of geometry iterations
            f.write("\n%geom MaxIter 500\nend\n")

            # Write scan constraint
            f.write('\n\n%geom Scan\n')
            f.write('    B {} {} = {}, {}, {}\n'.format(B[0],B[1],final_value,initial_value,steps))
            f.write('end\n')
            f.write('end\n')

            # Write Geometry constraint(s)    
            f.write('\n%geom\n  Constraints\n    {{ B {} {} C }}\n'.format(B[0],B[1]))
            for j in Bond_list:
                f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
            for j in Angle_list:
                f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
            for j in Dihedral_list:
                f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
            f.write('  end\nend\n\n')

            # Write geometry read line
            f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

            # Write RI-MP2 single point calculation
            if "mp2" in [ j.lower() for j in theory ]: 
                if charge < 0:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan"))
                else:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan"))
                f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

    return

# Generates run files for parallel scanning of angle modes        
def gen_angle_files(Name,gens,Adj_mat,A,Elements,Geometry,Atom_types,angle_step=1,angle_disp=5,output='orca',charge=0,multiplicity=1,procs=8,\
                    theory=['DFT','MP2'],constraints=" ",local_relaxation=0,frag_opt=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating parametrization calculations for angle: {}-{}-{}".format(Atom_types[A[0]],Atom_types[A[1]],Atom_types[A[2]]))

    # Generate fragment geometry if the option is enabled, else make local copies of the relevant lists.
    if frag_opt == 1:
        A,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(A,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                   # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                    # Copy the adj_mat
        N_Elements = copy(Elements)                   # Copy the Elements list 
        N_Atom_types = copy(Atom_types)               # Copy the Atom_types list
    
    v1 = Geometry[A[0]]-Geometry[A[1]]                # Calculate the vector connecting the first and second atoms
    v1 = v1/norm(v1)                                  # Normalize the vector
    v2 = Geometry[A[2]]-Geometry[A[1]]                # Calculate the vector connecting the second and third atoms
    v2 = v2/norm(v2)                                  # Normalize the vector
    v3 = cross(v1,v2)                                 # The cross product is used to define the rotation vector
    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Make subdirectory to hold the current angle bend files
    os.makedirs(Save_Folder+'/{}_{}_{}'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]]))   

    # symmetrically contract the angle to its most acute (angle_disp + r_eq)
    N_Geometry[A[0]] = axis_rot(N_Geometry[A[0]],v3,N_Geometry[A[1]],-angle_disp/2.0)
    N_Geometry[A[2]] = axis_rot(N_Geometry[A[2]],v3,N_Geometry[A[1]],angle_disp/2.0)
        
    # Symmetrically expand the angle
    steps = int(ceil(angle_disp/angle_step)*2+1)

    # For local relaxations all bonds and angles involving B-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(A,N_Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(N_Adj_mat)
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(N_Adj_mat)
        if A in Angle_list: Angle_list.remove(A)
        else: Angle_list.remove((A[2],A[1],A[0]))
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(N_Adj_mat)
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]

    # Generate angle files
    for i in range(steps):
        
        # Write linked xyz for viewing in vmd or similar program
        with open(Name+'.xyz','a') as f:
            f.write('{}\n\n'.format(len(N_Geometry)))
            for count_j,j in enumerate(N_Geometry):
                f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))

        # Write Orca file
        if output == 'orca':
            
            # Make sub-subdir for current file
            os.makedirs(Save_Folder+'/{}_{}_{}/{}'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]],i))   

            # Write geometry for the current configuration
            write_mode_geo(Save_Folder+'/{}_{}_{}/{}/'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]],i)+Save_Name+'_'+str(i)+'.xyz',N_Elements,N_Geometry,N_Atom_types)

            # Open file
            with open(Save_Folder+'/{}_{}_{}/{}/'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]],i)+Save_Name+'_'+str(i)+'.in','w') as f:

                # Write DFT Header
                if procs == 1:
                    if charge < 0:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                    else:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                else:
                    if charge < 0:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                    else:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))

                # Increase default max number of geometry iterations
                f.write("\n%geom MaxIter 500\nend\n")

                # Write Geometry constraint(s)    
                f.write('\n%geom\n  Constraints\n    {{ A {} {} {} C }}\n'.format(A[0],A[1],A[2]))
                for j in Bond_list:
                    f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
                for j in Angle_list:
                    f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
                for j in Dihedral_list:
                    f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
                f.write('  end\nend\n\n')

                # Write Coordinate header
                f.write('\n* xyz {} {}\n'.format(charge,multiplicity))
                
                # Write Geometry 
                for count_j,j in enumerate(N_Geometry):
                    f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
                f.write('*\n')

                # Write RI-MP2 single point calculation
                if "mp2" in [ j.lower() for j in theory ]: 
                    if charge < 0:
                        f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format(i))
                    else:
                        f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format(i))
                    f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

        # Apply the angle contraction (it is applied at the end of the loop so that on
        # the first pass the most obtuse geometry gets written). 
        N_Geometry[A[0]] = axis_rot(N_Geometry[A[0]],v3,N_Geometry[A[1]],angle_step/2.0)
        N_Geometry[A[2]] = axis_rot(N_Geometry[A[2]],v3,N_Geometry[A[1]],-angle_step/2.0)

    return

# Generates run files for continuously scanned angle modes
# This version performs an unconstrained geometry scan first then calculates the mode scan
def gen_angle_scan_files(Name,gens,Adj_mat,A,Elements,Geometry,Atom_types,angle_step=1,angle_disp=5,output='orca',charge=0,multiplicity=1,procs=8,\
                         theory=['DFT','MP2'],constraints=" ",local_relaxation=0,frag_opt=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating parametrization calculations for angle: {}-{}-{}".format(Atom_types[A[0]],Atom_types[A[1]],Atom_types[A[2]]))

    # Generate fragment geometry if the option is enabled, else make local copies of the relevant lists.
    if frag_opt == 1:
        A,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(A,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                   # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                    # Copy the adj_mat
        N_Elements = copy(Elements)                   # Copy the Elements list 
        N_Atom_types = copy(Atom_types)               # Copy the Atom_types list
    
    v1 = Geometry[A[0]]-Geometry[A[1]]                # Calculate the vector connecting the first and second atoms
    v1 = v1/norm(v1)                                  # Normalize the vector
    v2 = Geometry[A[2]]-Geometry[A[1]]                # Calculate the vector connecting the second and third atoms
    v2 = v2/norm(v2)                                  # Normalize the vector
    v3 = cross(v1,v2)                                 # The cross product is used to define the rotation vector
    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Make subdirectory to hold the current angle bend files
    os.makedirs(Save_Folder+'/{}_{}_{}'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]]))   

    # calculate mode details
    initial_value = acos(dot(N_Geometry[A[0]]-N_Geometry[A[1]],N_Geometry[A[2]]-N_Geometry[A[1]])/( norm(N_Geometry[A[0]]-N_Geometry[A[1]])*norm(N_Geometry[A[2]]-N_Geometry[A[1]]) ))*180.0/pi\
                   -angle_disp
    final_value   = initial_value+2.0*angle_disp
    steps         = int(round(2.0*angle_disp/angle_step))+1

    # For local relaxations all bonds and angles involving B-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(A,N_Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(N_Adj_mat)
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(N_Adj_mat)
        if A in Angle_list: Angle_list.remove(A)
        else: Angle_list.remove((A[2],A[1],A[0]))
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(N_Adj_mat)
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]

    #######################
    # Generate angle scan #
    #######################

    # Write linked xyz for viewing in vmd or similar program
    with open(Name+'.xyz','a') as f:
        f.write('{}\n\n'.format(len(N_Geometry)))
        for count_j,j in enumerate(N_Geometry):
            f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))

    # Write Orca file
    if output == 'orca':

        # Make sub-subdir for current file
        os.makedirs(Save_Folder+'/{}_{}_{}/{}'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]],"scan"))   

        # Write geometry for the current configuration
        write_mode_geo(Save_Folder+'/{}_{}_{}/{}/'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]],"scan")+Save_Name+'_scan.xyz',N_Elements,N_Geometry,N_Atom_types)

        # Open file
        with open(Save_Folder+'/{}_{}_{}/{}/'.format(N_Atom_types[A[0]],N_Atom_types[A[1]],N_Atom_types[A[2]],"scan")+Save_Name+'_scan.in','w') as f:

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_cycle_1"'.format(functional,basis,"scan"))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_cycle_1"'.format(functional,basis,procs,"scan"))

            # Write Coordinate header
            f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

            # Write Geometry 
            for count_j,j in enumerate(N_Geometry):
                f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
            f.write('*\n\n')

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
                    else:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan"))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))
                else:
                    if D3_flag == 1:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))
                    else:
                        f.write('#Run angle scan\n$new_job\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan"))

            # Increase default max number of geometry iterations
            f.write("\n%geom MaxIter 500\nend\n")

            # Write scan constraint
            f.write('\n\n%geom Scan\n')
            f.write('    A {} {} {} = {}, {}, {}\n'.format(A[0],A[1],A[2],final_value,initial_value,steps))
            f.write('end\n')
            f.write('end\n')

            # Write Geometry constraint(s)    
            f.write('\n%geom\n  Constraints\n    {{ A {} {} {} C }}\n'.format(A[0],A[1],A[2]))
            for j in Bond_list:
                f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
            for j in Angle_list:
                f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
            for j in Dihedral_list:
                f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
            f.write('  end\nend\n\n')

            # Write geometry read line
            f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

            # Write RI-MP2 single point calculation
            if "mp2" in [ j.lower() for j in theory ]: 
                if charge < 0:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan"))
                else:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan"))
                f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

    return

def gen_fourier_dihedral_files(Name,gens,Adj_mat,D,Elements,Geometry,Atom_types,dihedral_step=10,dihedral_disp=360,output='orca',charge=0,multiplicity=1,overlap_thresh=1.5,procs=8,\
                               theory=['DFT','MP2'],constraints=" ",skip_clashes=0,local_relaxation=0,frag_opt=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating fourier parametrization calculations for dihedral: {}-{}-{}-{}".format(Atom_types[D[0]],Atom_types[D[1]],Atom_types[D[2]],Atom_types[D[3]]))

    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Generate fragment geometry if the option is enabled, else make local copies of the relevant lists.
    if frag_opt == 1:
        D,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(D,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                   # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                    # Copy the adj_mat
        N_Elements = copy(Elements)                   # Copy the Elements list 
        N_Atom_types = copy(Atom_types)               # Copy the Atom_types list

    # Make subdirectory to hold the current angle bend files
    os.makedirs(Save_Folder+'/{}_{}_{}_{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]]))   

    ###################################################################################################
    # Find the two molecular halves, separated by the dihedral (cyclical structures trigger an error) #
    ###################################################################################################
    #
    #  dihedral       0     3
    #  labeling         1 2   
    #
    # Find atoms that can be reached from atom 1 without passing through atom 2 (used generating the rotated dihedral configurations)
    # group1 group2 group1_clash group2_clash
    group1 = [D[1]]
    new_connections = [ count_i for count_i,i in enumerate(N_Adj_mat[D[1]]) if ( i == 1 and count_i != D[2] ) ]
    while (new_connections):

        # Update the group with the atom currently being checked
        group1 = group1 + [new_connections[-1]]
        
        # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
        current  = [ count_i for count_i,i in enumerate(N_Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in group1 and count_i != D[1] ) ]

        # Update new connections and group members
        new_connections = new_connections + [ i for i in current if i not in group1 ]

    # Remove any double additions (they sometimes happen with cyclic topologies)
    group1 = list(set(group1))
        
    # Find atoms that can be reached from atom 2 without passing through atom 1 (used generating the rotated dihedral configurations)
    group2 = [D[2]]
    new_connections = [ count_i for count_i,i in enumerate(N_Adj_mat[D[2]]) if ( i == 1 and count_i != D[1] ) ]
    while (new_connections):

        # Update the group with the atom currently being checked
        group2 = group2 + [new_connections[-1]]
        
        # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
        current  = [ count_i for count_i,i in enumerate(N_Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in group2 and count_i != D[2] ) ]

        # Update new connections and group members
        new_connections = new_connections + [ i for i in current if i not in group2 ]

    # Remove any double additions (they sometimes happen with cyclic topologies)
    group2 = list(set(group2))

    # TMP (6/9/17: I don't know why this is called TMP now)
    with open(Name+'.xyz','w') as f:
        f.write('{}\n\n'.format(len(N_Geometry)))
        for count_j,j in enumerate(N_Geometry):
            f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))            

    # Remove clashes (the function performs rotations about the 1-2 and 2-3 bonds until a configuration is found where all
    # configurations in the scan satisfy the overlap threshold)
    status,N_Geometry = remove_clashes(N_Geometry,group1,group2,D,N_Adj_mat,overlap_thresh,dihedral_step)

    # Print message if the clash algorithm failed.
    if status == 1:
        print("\tWarning: unable to find a non-overlapping geometry for this dihedral. Defaulting to skipping clashes...")
        skip_clashes=1        

    # Check for cyclic structure (NOTE: this is no longer required because cyclic dihedrals are checked for outside of this function)
    cyclic_flag = 0
    #     for i in group1:
    #         if i in group2:
    #             cyclic_flag = 1
    #             break

    # For local relaxations all bonds and angles involving D-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(D,N_Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    # Parse constrained modes
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(N_Adj_mat)
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(N_Adj_mat)
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(N_Adj_mat)
        if D in Dihedral_list: Dihedral_list.remove(D)
        else: Dihedral_list.remove((D[3],D[2],D[1],D[0]))
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]
        
    # Print message if the structure is cyclic
    if cyclic_flag == 1:
        print("\n******************************************************************************************")
        print("* Warning: cyclic structure identified about the dihedral {:^20s}. Skipping... *".format("{}-{}-{}-{}".format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]])))
        print("******************************************************************************************\n")
        return

    # Generate fourier-dihedral files
    else:

        # Calculate rotation vector
        v1 = N_Geometry[D[1]]-N_Geometry[D[2]]
        v1 = v1/norm(v1)

        # Incrementally perform dihedral rotations and write the results 
        steps = int(ceil(dihedral_disp/dihedral_step))
        for i in range(steps):

            # Perform the dihedral rotation by rotating group1 atoms about the 1-2 bond of the dihedral
            # The starting geometry (0) is unperturbed
            if i != 0:
                for a in group1:
                    N_Geometry[a] = axis_rot(N_Geometry[a],v1,N_Geometry[D[1]],dihedral_step)
                
            # Check the geometry for overlap conditions between non-bonded atoms
            distances = cdist(N_Geometry,N_Geometry)
            overlaps = []

            # Current thresh is the baseline, whatever is supplied to overlap thresh is incrementally approached (i.e.
            # the program tries to satisfy the more stringent baseline criteria and works its way down to the more relaxed
            # criteria if necessary)
            # NOTE: overlaps are only calculated for non-bonded atoms.
            for count_d,d in enumerate(distances):
                overlaps = overlaps + [ (count_d,count_j,distances[count_d,count_j]) for count_j,j in enumerate(d) if count_j > count_d and N_Adj_mat[count_d,count_j] == 0 and j < overlap_thresh ]

            # If overlaps exist and skip_clashes is on (1) then this geometry is omitted from the dihedral scan
            if overlaps != [] and skip_clashes == 1:
                continue

            # Write linked xyz for viewing in vmd or a similar program
            if i == -1:
                with open(Name+'.xyz','w') as f:
                    f.write('{}\n\n'.format(len(N_Geometry)))
                    for count_j,j in enumerate(N_Geometry):
                        f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))            
            else:
                with open(Name+'.xyz','a') as f:
                    f.write('{}\n\n'.format(len(N_Geometry)))
                    for count_j,j in enumerate(N_Geometry):
                        f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))            

            # Write Orca file
            if output == 'orca':

                # Make sub-subdir for current file            
                os.makedirs(Save_Folder+'/{}_{}_{}_{}/{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],i))   

                # Write geometry for the current configuration
                write_mode_geo(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],i)+Save_Name+'_'+str(i)+'.xyz',\
                               N_Elements,N_Geometry,N_Atom_types)

                # Open file
                with open(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],i)+Save_Name+'_'+str(i)+'.in','w') as f:

                    # Write DFT Header
                    if procs == 1:
                        if charge < 0:
                            if D3_flag == 1:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                            else:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            if D3_flag == 1:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                            else:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                    else:
                        if charge < 0:
                            if D3_flag == 1:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                            else:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            if D3_flag == 1:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                            else:
                                f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))

                    # Increase default max number of geometry iterations
                    f.write("\n%geom MaxIter 500\nend\n")

                    # Write Geometry constraint(s)    
                    f.write('\n%geom\n  Constraints\n    {{ D {} {} {} {} C }}\n'.format(D[0],D[1],D[2],D[3]))
                    for j in Bond_list:
                        f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
                    for j in Angle_list:
                        f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
                    for j in Dihedral_list:
                        f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
                    f.write('  end\nend\n\n')

                    # Write Coordinate header
                    f.write('\n* xyz {} {}\n'.format(charge,multiplicity))
                    
                    # Write Geometry
                    for count_j,j in enumerate(N_Geometry):
                        f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
                    f.write('*\n')

                    # Write RI-MP2 single point
                    if 'mp2' in [ j.lower() for j in theory ]:
                        if charge < 0:
                            f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format(str(i)))
                        else:
                            f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format(str(i)))
                        f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))
                        
    return

# Generates input file for a dihedral mode scan. Includes an initial geometry optimization followed by a scan.
def gen_fourier_dihedral_scan_files(Name,gens,Adj_mat,D,Elements,Geometry,Atom_types,dihedral_step=10,dihedral_disp=360.0,output='orca',charge=0,multiplicity=1,overlap_thresh=1.5,procs=8,\
                                    theory=['DFT','MP2'],constraints=" ",skip_clashes=0,local_relaxation=0,frag_opt=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating fourier parametrization calculations for dihedral: {}-{}-{}-{}".format(Atom_types[D[0]],Atom_types[D[1]],Atom_types[D[2]],Atom_types[D[3]]))

    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Generate fragment geometry if the option is enabled, else make local copies of the relevant lists.
    if frag_opt == 1:
        D,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(D,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                   # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                    # Copy the adj_mat
        N_Elements = copy(Elements)                   # Copy the Elements list 
        N_Atom_types = copy(Atom_types)               # Copy the Atom_types list

    # Make subdirectory to hold the current angle bend files
    os.makedirs(Save_Folder+'/{}_{}_{}_{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]]))   

    # calculate mode details
    atom_1 = N_Geometry[D[0]]
    atom_2 = N_Geometry[D[1]]
    atom_3 = N_Geometry[D[2]]
    atom_4 = N_Geometry[D[3]]
    v1 = atom_2-atom_1
    v2 = atom_3-atom_2
    v3 = atom_4-atom_3

    initial_value        = arctan2( dot(v1,cross(v2,v3))*(dot(v2,v2))**(0.5) , dot(cross(v1,v2),cross(v2,v3)) ) * 180.0/pi
    final_value_forward  = initial_value+dihedral_disp-dihedral_step  # Avoid redundant evaluation at 360 degrees
    final_value_reverse  = initial_value-dihedral_disp+dihedral_step  # Avoid redundant evaluation at 360 degrees
    steps         = int(round(dihedral_disp/dihedral_step))

    ###################################################################################################
    # Find the two molecular halves, separated by the dihedral (cyclical structures trigger an error) #
    ###################################################################################################
    #
    #  dihedral       0     3
    #  labeling         1 2   
    #
    # Find atoms that can be reached from atom 1 without passing through atom 2 (used generating the rotated dihedral configurations)
    # group1 group2 group1_clash group2_clash
    group1 = [D[1]]
    new_connections = [ count_i for count_i,i in enumerate(N_Adj_mat[D[1]]) if ( i == 1 and count_i != D[2] ) ]
    while (new_connections):

        # Update the group with the atom currently being checked
        group1 = group1 + [new_connections[-1]]
        
        # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
        current  = [ count_i for count_i,i in enumerate(N_Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in group1 and count_i != D[1] ) ]

        # Update new connections and group members
        new_connections = new_connections + [ i for i in current if i not in group1 ]

    # Remove any double additions (they sometimes happen with cyclic topologies)
    group1 = list(set(group1))
        
    # Find atoms that can be reached from atom 2 without passing through atom 1 (used generating the rotated dihedral configurations)
    group2 = [D[2]]
    new_connections = [ count_i for count_i,i in enumerate(N_Adj_mat[D[2]]) if ( i == 1 and count_i != D[1] ) ]
    while (new_connections):

        # Update the group with the atom currently being checked
        group2 = group2 + [new_connections[-1]]
        
        # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
        current  = [ count_i for count_i,i in enumerate(N_Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in group2 and count_i != D[2] ) ]

        # Update new connections and group members
        new_connections = new_connections + [ i for i in current if i not in group2 ]

    # Remove any double additions (they sometimes happen with cyclic topologies)
    group2 = list(set(group2))

    # Check for cyclic structure
    cyclic_flag = 0
    for i in group1:
        if i in group2:
            cyclic_flag = 1
            break

    # For local relaxations all bonds and angles involving D-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(D,N_Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    # Parse constrained modes
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(N_Adj_mat)
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(N_Adj_mat)
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(N_Adj_mat)
        if D in Dihedral_list: Dihedral_list.remove(D)
        else: Dihedral_list.remove((D[3],D[2],D[1],D[0]))
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]
        
    # Print message if the structure is cyclic
    if cyclic_flag == 1:
        print("\n******************************************************************************************")
        print("* Warning: cyclic structure identified about the dihedral {:^20s}. Skipping... *".format("{}-{}-{}-{}".format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]])))
        print("******************************************************************************************\n")
        return

    # Write linked xyz for viewing in vmd or similar program
    with open(Name+'.xyz','a') as f:
        f.write('{}\n\n'.format(len(N_Geometry)))
        for count_j,j in enumerate(N_Geometry):
            f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))

    # Write Orca file
    if output == 'orca':

        #########################################
        ##### Write forward scan input file #####
        #########################################

        # Make sub-subdir for current file            
        os.makedirs(Save_Folder+'/{}_{}_{}_{}/{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],"scan-forward"))   

        # Write geometry for the current configuration
        write_mode_geo(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],"scan-forward")+Save_Name+'_scan-forward.xyz',\
                       N_Elements,N_Geometry,N_Atom_types)

        # Open file
        with open(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],"scan-forward")+Save_Name+'_scan-forward.in','w') as f:

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-forward"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-forward"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-forward"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-forward"))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-forward"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-forward"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-forward"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-forward"))

            # Increase default max number of geometry iterations
            f.write("\n%geom MaxIter 500\nend\n")

            # Write scan constraint
            f.write('\n\n%geom Scan\n')
            f.write('    D {} {} {} {} = {}, {}, {}\n'.format(D[0],D[1],D[2],D[3],initial_value,final_value_forward,steps))
            f.write('end\n')
            f.write('end\n')

            # Write Geometry constraint(s)    
            f.write('\n%geom\n  Constraints\n    {{ D {} {} {} {} C }}\n'.format(D[0],D[1],D[2],D[3]))
            for j in Bond_list:
                f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
            for j in Angle_list:
                f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
            for j in Dihedral_list:
                f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
            f.write('  end\nend\n\n')

            # Write Coordinate header
            f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

            # Write Geometry
            for count_j,j in enumerate(N_Geometry):
                f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
            f.write('*\n')

            # Write RI-MP2 single point
            if 'mp2' in [ j.lower() for j in theory ]:
                print("ERROR: mp2 option is not compatible with frag option. The coding isn't finished. There are complications owing to the use of the %geom Scan option. Exiting...")
                quit()
                if charge < 0:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan-forward"))
                else:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan-forward"))
                f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

        #########################################
        ##### Write reverse scan input file #####
        #########################################

        # Make sub-subdir for current file            
        os.makedirs(Save_Folder+'/{}_{}_{}_{}/{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],"scan-reverse"))   

        # Write geometry for the current configuration
        write_mode_geo(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],"scan-reverse")+Save_Name+'_scan-reverse.xyz',\
                       N_Elements,N_Geometry,N_Atom_types)

        # Open file
        with open(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],"scan-reverse")+Save_Name+'_scan-reverse.in','w') as f:

            # Write DFT Header
            if procs == 1:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-reverse"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-reverse"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-reverse"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,"scan-reverse"))
            else:
                if charge < 0:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-reverse"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-reverse"))
                else:
                    if D3_flag == 1:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-reverse"))
                    else:
                        f.write('#Run DFT dihedral scan\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,"scan-reverse"))

            # Increase default max number of geometry iterations
            f.write("\n%geom MaxIter 500\nend\n")

            # Write scan constraint
            f.write('\n\n%geom Scan\n')
            f.write('    D {} {} {} {} = {}, {}, {}\n'.format(D[0],D[1],D[2],D[3],initial_value,final_value_reverse,steps))
            f.write('end\n')
            f.write('end\n')

            # Write Geometry constraint(s)    
            f.write('\n%geom\n  Constraints\n    {{ D {} {} {} {} C }}\n'.format(D[0],D[1],D[2],D[3]))
            for j in Bond_list:
                f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
            for j in Angle_list:
                f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
            for j in Dihedral_list:
                f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
            f.write('  end\nend\n\n')

            # Write Coordinate header
            f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

            # Write Geometry
            for count_j,j in enumerate(N_Geometry):
                f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
            f.write('*\n')

            # Write RI-MP2 single point
            if 'mp2' in [ j.lower() for j in theory ]:
                print("ERROR: mp2 option is not compatible with frag option. The coding isn't finished. There are complications owing to the use of the %geom Scan option. Exiting...")
                quit()
                if charge < 0:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan-reverse"))
                else:
                    f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format("scan-reverse"))
                f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))


                        
    return

# Wrapper for generating geometries for a harmonic dihedral scan
def gen_harmonic_dihedral_files(Name,gens,Adj_mat,D,Elements,Geometry,Atom_types,dihedral_step=1.0,dihedral_disp=5,output='orca',charge=0,multiplicity=1,procs=8,\
                                theory=['DFT','MP2'],constraints=" ",local_relaxation=0,frag_opt=0,functional="B3LYP",basis="def2-TZVP",D3_flag=1):

    # Print diagnostic message
    print("Generating harmonic parametrization calculations for dihedral: {}-{}-{}-{}".format(Atom_types[D[0]],Atom_types[D[1]],Atom_types[D[2]],Atom_types[D[3]]))

    Save_Folder = '/'.join(Name.split('/')[0:-1])     # Returns the path less the filename
    Save_Name = Name.split('/')[-1]                   # Returns the filename

    # Generate fragment geometry if the option is enabled, else make local copies of the relevant lists.
    if frag_opt == 1:
        D,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types = mode_frag(D,Geometry,Adj_mat,Elements,Atom_types,gens)
    else:
        N_Geometry = copy(Geometry)                   # Copy the geometry
        N_Adj_mat  = copy(Adj_mat)                    # Copy the adj_mat
        N_Elements = copy(Elements)                   # Copy the Elements list 
        N_Atom_types = copy(Atom_types)               # Copy the Atom_types list

    # Make subdirectory to hold the current harmonic dihedral files
    os.makedirs(Save_Folder+'/{}_{}_{}_{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]]))   

    ###################################################################################################
    # Rotate the geometry +/- dihedral_disp
    ###################################################################################################
    #
    #  dihedral       0     3
    #  labeling         1 2   
    #
    # Generate dihedral rotation

    # Calculate rotation vector
    v1 = N_Geometry[D[1]]-N_Geometry[D[2]]
    v1 = v1/norm(v1)

    # Distort initial geometry to the full -dihedral_disp + one step
    N_Geometry[D[0]] = axis_rot(N_Geometry[D[0]],v1,N_Geometry[D[1]],-dihedral_disp/2.0-dihedral_step/2.0)
    N_Geometry[D[3]] = axis_rot(N_Geometry[D[3]],v1,N_Geometry[D[1]],dihedral_disp/2.0+dihedral_step/2.0)

    # Incrementally perform dihedral rotations and write the results (-1 in the
    # steps is to avoid a redudant run at 360 degrees).
    steps = int(ceil(2*dihedral_disp/dihedral_step)+2.0)

    # For local relaxations all bonds and angles involving D-atoms are allowed to relax
    # as well as any coincident dihedrals.
    if local_relaxation == 1:
        relax_list = find_local_modes(D,Adj_mat)
    else:
        relax_list = []

    # Generate lists of all constrained modes
    # with the omission of the scanned dihedral (this mode is already constrained by default in the input file)
    # Parse constrained modes and remove modes protected by relax_list
    Bond_list = []
    Angle_list = []
    Dihedral_list = []
    if "bonds" in constraints:
        Bond_list = Find_all_bonds(Adj_mat)
        Bond_list = [ i for i in Bond_list if i not in relax_list ]
    if "angles" in constraints:
        Angle_list = Find_all_angles(Adj_mat)
        Angle_list = [ i for i in Angle_list if i not in relax_list ]
    if "dihedrals" in constraints:
        Dihedral_list = Find_all_dihedrals(Adj_mat)
        if D in Dihedral_list: Dihedral_list.remove(D)
        else: Dihedral_list.remove((D[3],D[2],D[1],D[0]))
        Dihedral_list = [ i for i in Dihedral_list if i not in relax_list ]

    # Generate harmonic-dihedral files
    for i in range(steps-1):

        # Perform increment the position of the 1-4 atoms        
        N_Geometry[D[0]] = axis_rot(N_Geometry[D[0]],v1,N_Geometry[D[1]],dihedral_step/2.0)
        N_Geometry[D[3]] = axis_rot(N_Geometry[D[3]],v1,N_Geometry[D[1]],-dihedral_step/2.0)

        # Write linked xyz for viewing in vmd or a similar program
        with open(Name+'.xyz','a') as f:
            f.write('{}\n\n'.format(len(N_Geometry)))
            for count_j,j in enumerate(N_Geometry):
                f.write('{:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))            

        # Write Orca file
        if output == 'orca':

            # Make sub-subdir for current file            
            os.makedirs(Save_Folder+'/{}_{}_{}_{}/{}'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],i))   

            write_mode_geo(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],i)+Save_Name+'_'+str(i)+'.xyz',\
                           N_Elements,N_Geometry,N_Atom_types)

            # Open file
            with open(Save_Folder+'/{}_{}_{}_{}/{}/'.format(N_Atom_types[D[0]],N_Atom_types[D[1]],N_Atom_types[D[2]],N_Atom_types[D[3]],i)+Save_Name+'_'+str(i)+'.in','w') as f:

                # Write DFT Header
                if procs == 1:
                    if charge < 0:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                    else:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG\n\n%base "{}_geo_opt"'.format(functional,basis,i))
                else:
                    if charge < 0:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                    else:
                        if D3_flag == 1:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt D3BJ CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))
                        else:
                            f.write('#Run DFT geometry optimization\n! {} {} TIGHTSCF TIGHTOPT Grid5 FinalGrid6 Opt CHELPG PAL{}\n\n%base "{}_geo_opt"'.format(functional,basis,procs,i))

                # Increase default max number of geometry iterations
                f.write("\n%geom MaxIter 500\nend\n")

                # Write Geometry constraint(s)    
                f.write('\n%geom\n  Constraints\n    {{ D {} {} {} {} C }}\n'.format(D[0],D[1],D[2],D[3]))
                for j in Bond_list:
                    f.write('    {{ B {} {} C }}\n'.format(j[0],j[1]))
                for j in Angle_list:
                    f.write('    {{ A {} {} {} C }}\n'.format(j[0],j[1],j[2]))
                for j in Dihedral_list:
                    f.write('    {{ D {} {} {} {} C }}\n'.format(j[0],j[1],j[2],j[3]))
                f.write('  end\nend\n\n')

                # Write Coordinate header
                f.write('\n* xyz {} {}\n'.format(charge,multiplicity))

                # Write Geometry
                for count_j,j in enumerate(N_Geometry):
                    f.write('  {:<20s} {: <20.6f} {: <20.6f} {: <20.6f}\n'.format(N_Elements[count_j],j[0],j[1],j[2]))
                f.write('*\n')

                # Write RI-MP2 single point
                if 'mp2' in [ j.lower() for j in theory ]:
                    if charge < 0:
                        f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 aug-cc-pVTZ aug-cc-pVTZ/C TIGHTSCF CHELPG\n'.format(str(i)))
                    else:
                        f.write('\n#Run RI-MP2 single point and calculate CHELPG charges\n$new_job\n%base "{}_RI-MP2"\n! RI-MP2 cc-pVTZ cc-pVTZ/C TIGHTSCF CHELPG\n'.format(str(i)))
                    f.write('\n* xyzfile {} {}\n'.format(charge,multiplicity))

    return

# Remove clashes (the function performs rotations about the 1-2 and 2-3 bonds until a configuration is found where all
# configurations in the scan satisfy the overlap threshold)
def remove_clashes(geometry,group1,group2,D,Adj_mat,overlap_thresh,dihedral_step):

    # Calculate main rotation vector
    v1 = geometry[D[1]]-geometry[D[2]]
    v1 = v1/norm(v1)

    # Calculate the number of steps (-1 avoids the redundant configuration at 360)
    steps = int(ceil(360.0/dihedral_step))-1

    # Generate a list of all dihedrals (used for bond awareness when identifying clashes)
    mode_list = Find_all_dihedrals(Adj_mat) + Find_all_angles(Adj_mat) + Find_all_bonds(Adj_mat)

    # Check for clashes using the initial geometry
    overlaps = []
    N_geometry = copy(geometry)
    for i in range(steps):

        # Perform the dihedral rotation by rotating group1 atoms about the 1-2 bond of the dihedral
        for a in group1:
            N_geometry[a] = axis_rot(N_geometry[a],v1,N_geometry[D[1]],dihedral_step)
                
        # Check the geometry for overlap conditions between non-bonded atoms
        distances = cdist(N_geometry,N_geometry)

        # Current thresh is the baseline, whatever is supplied to overlap thresh is incrementally approached (i.e.
        # the program tries to satisfy the more stringent baseline criteria and works its way down to the more relaxed
        # criteria if necessary)
        # NOTE: overlaps are only calculated for non-bonded atoms.
        for count_d,d in enumerate(distances):
            mode_ind = list(set([ n for m in mode_list for n in m if count_d in m ]))
            overlaps += [ (count_d,count_m,distances[count_d,count_m]) for count_m,m in enumerate(d) if count_m > count_d and count_m not in mode_ind and m < overlap_thresh ]

    # If no alteration is needed, then the original geometry is returned and a success status
    if overlaps == []: 
        return 0,geometry

    # Calculate 1-2 and 3-4 rotation vector(s) (NOTE: for coincident dihedrals there are sometimes multiple 1-2 and 3-4 bonds that can be relaxed about)
    v2_list = [ geometry[count_i]-geometry[D[1]] for count_i,i in enumerate(Adj_mat[D[1]]) if count_i != D[2] and i == 1 ]
    v3_list = [ geometry[count_i]-geometry[D[2]] for count_i,i in enumerate(Adj_mat[D[2]]) if count_i != D[1] and i == 1 ]
    v2_pairs = [ (D[1],count_i) for count_i,i in enumerate(Adj_mat[D[1]]) if count_i != D[2] and i == 1 ]
    v3_pairs = [ (D[2],count_i) for count_i,i in enumerate(Adj_mat[D[2]]) if count_i != D[1] and i == 1 ]

    # Find atoms that can be reached from atom 0 without passing through atom 1 (used for gracefully correcting clashes)
    # NOTE: atom 0 changes depending on the v2 vector
    v2_clash_lists = [ [] for i in v2_pairs ]
    for count_v,v in enumerate(v2_pairs):
        v2_clash_lists[count_v] += [v[1]]
        new_connections = [ count_i for count_i,i in enumerate(Adj_mat[v[1]]) if ( i == 1 and count_i != v[0] ) ]
        while (new_connections):

            # Update the group with the atom currently being checked
            v2_clash_lists[count_v] += [new_connections[-1]]

            # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
            current  = [ count_i for count_i,i in enumerate(Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in v2_clash_lists[count_v] and count_i != v[0] ) ]

            # Update new connections and group members
            new_connections = new_connections + [ i for i in current if i not in v2_clash_lists[count_v] ]
        
    # Find atoms that can be reached from atom 3 without passing through atom 2 (used for gracefully correcting clashes)
    v3_clash_lists = [ [] for i in v3_pairs ]
    for count_v,v in enumerate(v3_pairs):
        v3_clash_lists[count_v] = [v[1]]
        new_connections = [ count_i for count_i,i in enumerate(Adj_mat[v[1]]) if ( i == 1 and count_i != v[0] ) ]
        while (new_connections):

            # Update the group with the atom currently being checked
            v3_clash_lists[count_v] += [new_connections[-1]]

            # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
            current  = [ count_i for count_i,i in enumerate(Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in v3_clash_lists[count_v] and count_i != v[0] ) ]

            # Update new connections and group members
            new_connections = new_connections + [ i for i in current if i not in v3_clash_lists[count_v] ]

#     # Find atoms that can be reached from atom 0 without passing through atom 1 (used for gracefully correcting clashes)
#     group1_clash = [D[0]]
#     new_connections = [ count_i for count_i,i in enumerate(Adj_mat[D[0]]) if ( i == 1 and count_i != D[1] ) ]
#     while (new_connections):

#         # Update the group with the atom currently being checked
#         group1_clash = group1_clash + [new_connections[-1]]
        
#         # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
#         current  = [ count_i for count_i,i in enumerate(Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in group1_clash and count_i != D[1] ) ]

#         # Update new connections and group members
#         new_connections = new_connections + [ i for i in current if i not in group1_clash ]
        
#     # Find atoms that can be reached from atom 3 without passing through atom 2 (used for gracefully correcting clashes)
#     group2_clash = [D[3]]
#     new_connections = [ count_i for count_i,i in enumerate(Adj_mat[D[3]]) if ( i == 1 and count_i != D[2] ) ]
#     while (new_connections):

#         # Update the group with the atom currently being checked
#         group2_clash = group2_clash + [new_connections[-1]]
        
#         # Find current connections (exclude discovered connections leading to atoms that are already included in the set)
#         current  = [ count_i for count_i,i in enumerate(Adj_mat[new_connections.pop()]) if ( i == 1 and count_i not in group2_clash and count_i != D[2] ) ]

#         # Update new connections and group members
#         new_connections = new_connections + [ i for i in current if i not in group2_clash ]

    # Else: the program will attempt to resolve clashes by performing rotations about the 1-2 and 3-4 bonds of the dihedral 
    # (these preserve the dihedral.) There are 4 possibilities, rotating symmetrically clockwise and counterclockwise, and 
    # antisymmetrically clockwise and counterclockwise. All four are performed and the result of the one that perturbs the
    # original geometry the least is used. 
    step_count = 500
    for count_v2,v2 in enumerate(v2_list):
        for count_v3,v3 in enumerate(v3_list):
            for i in [-1.0,1.0]:
                for j in [-1.0,1.0]:

                    # Rotations through 360 degrees are attempted
                    for k in range(360):

                        # Refresh the geometry
                        N_geometry = copy(geometry)

                        # Perform the clockwise and counter-clockwise rotations about the v2 and v3 vectors (these 
                        # preserve the dihedral angle) until a minimal overlap condition is found.
                        for a in v2_clash_lists[count_v2]:
                            N_geometry[a] = axis_rot(N_geometry[a],v2,N_geometry[D[1]],i*float(k))
                        for a in v3_clash_lists[count_v3]:
                            N_geometry[a] = axis_rot(N_geometry[a],v3,N_geometry[D[2]],j*float(k))

                        # Initialize overlaps list
                        overlaps = []

                        for m in range(steps):

                            # Perform the dihedral rotation by rotating group1 atoms about the 1-2 bond of the dihedral
                            for a in group1:
                                N_geometry[a] = axis_rot(N_geometry[a],v1,N_geometry[D[1]],dihedral_step)

                            # Check the geometry for overlap conditions between non-bonded atoms
                            distances = cdist(N_geometry,N_geometry)

                            # Current thresh is the baseline, whatever is supplied to overlap thresh is incrementally approached (i.e.
                            # the program tries to satisfy the more stringent baseline criteria and works its way down to the more relaxed
                            # criteria if necessary)
                            # NOTE: overlaps are only calculated for atoms separated by more than 3 bonds (mode_ind returns the indices of all atoms sharing a bond/angle/dihedral with
                            #       atom count_d and the overlaps list syntax avoids adding any atoms contained in the mode_ind list.
                            for count_d,d in enumerate(distances):
                                mode_ind = list(set([ n for m in mode_list for n in m if count_d in m ]))
                                overlaps += [ (count_d,count_m,distances[count_d,count_m]) for count_m,m in enumerate(d) if count_m > count_d and count_m not in mode_ind and m < overlap_thresh ]

                            # If overlaps exist break and try the next incremental step
                            if overlaps != []: break

                        # If all configurations were generated without producing an overlap then the minimally perturbation for this
                        # combination of rotations has been found.
                        if overlaps == [] and k < step_count:
                            step_count = k
                            rot = [i*float(k),j*float(k)] # Angle tuples for the least-perturbative rotation
                            v_final = [count_v2,count_v3]
                            break
                        elif k >= step_count:
                            break

    # If a non-clashing geometry was obtained, then return the least perturbed non-clash geometry and a successful status
    if step_count != 500:

        print("\tRelaxation performed to avoid clashes...")
        # Refresh the geometry
        N_geometry = copy(geometry)

        # Perform the clockwise and counter-clockwise rotations about the v2 and v3 vectors (these 
        # preserve the dihedral angle) until a minimal overlap condition is found.
        for a in v2_clash_lists[v_final[0]]:
            N_geometry[a] = axis_rot(N_geometry[a],v2_list[v_final[0]],geometry[D[1]],rot[0])
        for a in v3_clash_lists[v_final[1]]:
            N_geometry[a] = axis_rot(N_geometry[a],v3_list[v_final[1]],geometry[D[2]],rot[1])
        return 0,N_geometry
    
    # If no non-clashing geometry was obtained, then return the original geometry and a failure status
    else:
        return 1,geometry

    return status,geometry

# # Find local modes (finds the coincident bonds, angles, and dihedrals
# # with a given mode; only coincident dihedrals for dihedral modes are
# # allowed to relax)
# def find_local_modes(mode,Adj_mat):

#     local_list = []
    
#     # Find all bonds involving the mode-atoms
#     bond_list = Find_all_bonds(Adj_mat)
#     for i in mode:
#         local_list += [ j for j in bond_list if i in j ]

#     # Find all angles involving the mode-atoms
#     angle_list = Find_all_angles(Adj_mat)
#     for i in mode:
#         local_list += [ j for j in angle_list if i in j ]

#     # Find all coincident dihedrals (dihedrals sharing their 2-3 atoms)
#     if len(mode) == 4:
#         dihedral_list = Find_all_dihedrals(Adj_mat)
#         local_list += [ j for j in dihedral_list if ( j[1] == mode[1] and j[2] == mode[2] ) or ( j[1] == mode[2] and j[2] == mode[1] ) ]

#     return local_list

# # Find local modes (same previous function find_local_modes except that dihedrals involved in the 
# # 1-2 and 3-4 bonds are also included and dihedrals coincident with angle and bond modes are also allowed
# # to relax
# def find_local_modes(mode,Adj_mat):

#     local_list = []
    
#     # Find all bonds involving the mode-atoms
#     bond_list = Find_all_bonds(Adj_mat)
#     for i in mode:
#         local_list += [ j for j in bond_list if i in j ]

#     # Find all angles involving the mode-atoms
#     angle_list = Find_all_angles(Adj_mat)
#     for i in mode:
#         local_list += [ j for j in angle_list if i in j ]

#     # Find all coincident dihedrals
#     dihedral_list = Find_all_dihedrals(Adj_mat)

#     # For a bond, only one coincident search is performed (0-1)
#     local_list += [ j for j in dihedral_list if ( j[1] == mode[0] and j[2] == mode[1] ) or ( j[1] == mode[1] and j[2] == mode[0] ) ]

#     # For an angle, two coincident searches are performed (0-1 and 1-2)
#     if len(mode) > 2:
#         local_list += [ j for j in dihedral_list if ( j[1] == mode[1] and j[2] == mode[2] ) or ( j[1] == mode[2] and j[2] == mode[1] ) ]

#     # For a dihedral, three coincident searches are performed (0-1, 1-2, and 2-3)
#     if len(mode) > 3:
#         local_list += [ j for j in dihedral_list if ( j[1] == mode[2] and j[2] == mode[3] ) or ( j[1] == mode[3] and j[2] == mode[2] ) ]

#     return local_list

# Find local modes (all bonds and angles that share atoms with the mode are allowed to relax
# and all dihedrals that share a 2 or a 3 atom (central atoms) with the mode atoms)
def find_local_modes(mode,Adj_mat):

    local_list = []
    
    # Find all bonds involving the mode-atoms
    bond_list = Find_all_bonds(Adj_mat)
    for i in mode:
        local_list += [ j for j in bond_list if i in j ]

    # Find all angles involving the mode-atoms
    angle_list = Find_all_angles(Adj_mat)
    for i in mode:
        local_list += [ j for j in angle_list if i in j ]

    # Find all coincident dihedrals
    dihedral_list = Find_all_dihedrals(Adj_mat)

    # For a bond, only one coincident search is performed (0-1)
    local_list += [ j for j in dihedral_list if ( j[1] == mode[0] or j[2] == mode[0] or j[1] == mode[1] or j[2] == mode[1] ) ]

    # For an angle, two coincident searches are performed (0-1 and 1-2)
    if len(mode) > 2:
        local_list += [ j for j in dihedral_list if ( j[1] == mode[2] or j[2] == mode[2] ) ]

    # For a dihedral, three coincident searches are performed (0-1, 1-2, and 2-3)
    if len(mode) > 3:
        local_list += [ j for j in dihedral_list if ( j[1] == mode[3] or j[2] == mode[3] ) ]

    return local_list

    
# This function identifies all bonds based on 1-bond deep walks within the adjacency matrix
def Find_all_bonds(adj_mat):

    bonds = []
    
    # Each row in the adjacency matrix is used to seed a 2-bond deep search
    for count_i,i in enumerate(adj_mat):

        # tmp holds the bonds to the i-th atom
        tmp = [ [count_i,count_j] for count_j,j in enumerate(i) if j == 1 ]

        # Only add new bonds
        bonds += [ j for j in tmp if ( j not in bonds and [j[1],j[0]] not in bonds ) ]

    bond_atoms = [ tuple(i) for i in bonds ]

    return bond_atoms

# This function identifies all angles based on 2-bond deep walks within the adjacency matrix
def Find_all_angles(adj_mat):

    angles = []
    
    # Each row in the adjacency matrix is used to seed a 2-bond deep search
    for count_i,i in enumerate(adj_mat):

        # current holds the angle seedlings
        current = [ [count_i,count_j] for count_j,j in enumerate(i) if j == 1 ]

        # new holds the updated list of angles at the end of each bond search
        new = []
        iteration = 0 

        # recursively add bonds to new until no new bonds are found
        while new != current:
            if iteration == 0: new = deepcopy(current)
            current = deepcopy(new)

            # Iterate over the seedlings and add connections/spawn new seedlings
            for count_j,j in enumerate(current):
                if len(j) == 3: continue                                                                            # avoid adding new elements to full angles
                connections = [ count_k for count_k,k in enumerate(adj_mat[j[-1]]) if k == 1 and count_k not in j ] # add new connections not already in the angle
                for count_k,k in enumerate(connections):
                    if count_k == 0: new[count_j] += [k]                                                            # add the first connection to the existing seedling
                    else: new += [ j + [k] ]                                                                        # add the rest as new elements
            iteration += 1             

        # Only add full angles and new angles to the angles list
        tmp = [ j for j in new if len(j) == 3 ]
        angles += [ j for j in tmp if ( j not in angles and [j[2],j[1],j[0]] not in angles ) ]

    angle_atoms = [ tuple(i) for i in angles ]

    return angle_atoms

# This function identifies all dihedrals based on 3-bond deep walks within the adjacency matrix
def Find_all_dihedrals(adj_mat):

    dihedrals = []
    
    # Each row in the adjacency matrix is used to seed a 3-bond deep search
    for count_i,i in enumerate(adj_mat):

        # current holds the dihedral seedlings
        current = [ [count_i,count_j] for count_j,j in enumerate(i) if j == 1 ]

        # new holds the updated list of dihedrals at the end of each bond search
        new = []
        iteration = 0 

        # recursively add bonds to new until no new bonds are found
        while new != current:
            if iteration == 0: new = deepcopy(current)
            current = deepcopy(new)

            # Iterate over the seedlings and add connections/spawn new seedlings
            for count_j,j in enumerate(current):
                if len(j) == 4: continue                                                                            # avoid adding new elements to full dihedrals
                connections = [ count_k for count_k,k in enumerate(adj_mat[j[-1]]) if k == 1 and count_k not in j ] # add new connections not already in the dihedral
                for count_k,k in enumerate(connections):
                    if count_k == 0: new[count_j] += [k]                                                            # add the first connection to the existing seedling
                    else: new += [ j + [k] ]                                                                        # add the rest as new elements
            iteration += 1             

        # Only add full dihedrals and new dihedrals to the dihedrals list
        tmp = [ j for j in new if len(j) == 4 ]
        dihedrals += [ j for j in tmp if ( j not in dihedrals and [j[3],j[2],j[1],j[0]] not in dihedrals ) ]

    dihedral_atoms = [ tuple(i) for i in dihedrals ]

    return dihedral_atoms


# Description:
# Rotate Point by an angle, theta, about the vector with an orientation of v1 passing through v2. 
# Performs counter-clockwise rotations (i.e., if the direction vector were pointing
# at the spectator, the rotations would appear counter-clockwise)
# For example, a 90 degree rotation of a 0,0,1 about the canonical 
# y-axis results in 1,0,0.
#
# Point: 1x3 array, coordinates to be rotated
# v1: 1x3 array, point the rotation passes through
# v2: 1x3 array, rotation direction vector
# theta: scalar, magnitude of the rotation (defined by default in degrees)
def axis_rot(Point,v1,v2,theta,mode='angle'):

    # Temporary variable for performing the transformation
    rotated=array([Point[0],Point[1],Point[2]])

    # If mode is set to 'angle' then theta needs to be converted to radians to be compatible with the
    # definition of the rotation vectors
    if mode == 'angle':
        theta = theta*pi/180.0

    # Rotation carried out using formulae defined here (11/22/13) http://inside.mines.edu/fs_home/gmurray/ArbitraryAxisRotation/)
    # Adapted for the assumption that v1 is the direction vector and v2 is a point that v1 passes through
    a = v2[0]
    b = v2[1]
    c = v2[2]
    u = v1[0]
    v = v1[1]
    w = v1[2]
    L = u**2 + v**2 + w**2

    # Rotate Point
    x=rotated[0]
    y=rotated[1]
    z=rotated[2]

    # x-transformation
    rotated[0] = ( a * ( v**2 + w**2 ) - u*(b*v + c*w - u*x - v*y - w*z) )\
             * ( 1.0 - cos(theta) ) + L*x*cos(theta) + L**(0.5)*( -c*v + b*w - w*y + v*z )*sin(theta)

    # y-transformation
    rotated[1] = ( b * ( u**2 + w**2 ) - v*(a*u + c*w - u*x - v*y - w*z) )\
             * ( 1.0 - cos(theta) ) + L*y*cos(theta) + L**(0.5)*(  c*u - a*w + w*x - u*z )*sin(theta)

    # z-transformation
    rotated[2] = ( c * ( u**2 + v**2 ) - w*(a*u + b*v - u*x - v*y - w*z) )\
             * ( 1.0 - cos(theta) ) + L*z*cos(theta) + L**(0.5)*( -b*u + a*v - v*x + u*y )*sin(theta)

    rotated = rotated/L
    return rotated

def Sub_UA(Elements,Adj_mat,N_geometry,Atom_types,Charges,Structure,Groups=[]):

    # List of united atom types. Hydrogens are removed for atom types belonging to this list. 
    UA_types = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
    
    UA_idx = [ count_i for count_i,i in enumerate(Atom_types) if i in UA_types ]
    Delete_list = []
    for i in UA_idx:
        Delete_list = Delete_list + [ count_j for count_j,j in enumerate(Adj_mat[i]) if j == 1 and Elements[count_j] == 'H' ]
        
    # Perform deletions
    Elements = [ Elements[m] for m in range(len(Elements)) if m not in Delete_list ]
    N_geometry = N_geometry[[ m for m in range(len(N_geometry)) if m not in Delete_list ],:]
    Atom_types = [ Atom_types[m] for m in range(len(Atom_types)) if m not in Delete_list ]
    Charges = [ Charges[m] for m in range(len(Charges)) if m not in Delete_list ]
    Structure = [ Structure[m] for m in range(len(Structure)) if m not in Delete_list ]
    Adj_mat = Adj_mat[[ m for m in range(len(Adj_mat[:,0])) if m not in Delete_list ],: ]
    Adj_mat = Adj_mat[:,[ m for m in range(len(Adj_mat[0,:])) if m not in Delete_list ]]                

    # Center new geometry at origin
    Centroid = array([mean(N_geometry[:,0]),mean(N_geometry[:,1]),mean(N_geometry[:,2])])
    for count_i,i in enumerate(N_geometry):
        N_geometry[count_i] = i-Centroid
    
    
    # Custom substitutions are also supported based upon user-defined patterns. These are more cumbersome, 
    # since they have to define the bonding configuration of the atom to be substituted. 
    #
    # Loop over the groups that need to be substituted
    for i in Groups:

        # Current pattern
        Find_pattern = i[0].split('-')
        try:
            Find_pattern = [ int(j) for j in Find_pattern ]
        except ValueError:
            Find_pattern = [ str(j) for j in Find_pattern ]

        # Find indices matching first elements in Groups
        Possibles  = [ count_j for count_j,j in enumerate(Elements) if ( j == Find_pattern[0] or Atom_types[count_j] == Find_pattern[0] ) ]

        # Reduce possibles to atoms with the proper number of connections
        Possibles = [ j for j in Possibles if sum(Adj_mat[j]) == len(Find_pattern)-1 ]

        # Loop over conditions removing incompatibles from Possibles
        for j in Find_pattern[1:]:
            
            # Match number is determined by the number of times a certain connection is 
            # required. For example, 2 and only 2 hydrogens, would be specified as something
            # like ('C','H','H') and match_number would be 2 for this condition.
            match_number = len([ k for k in Find_pattern[1:] if k == j ])
            for k in Possibles:

                # If conditions are not met the current possible (k) is removed from consideration.
                if int(sum([ m for count_m,m in enumerate(Adj_mat[k]) if m == 1 and (Elements[count_m] == j or Atom_types[count_m] == j) ])) != match_number:
                    Possibles = [ m for m in Possibles if m != k ]

        # Replacement pattern
        Sub_pattern = i[1].split('-')
        try:
            Sub_pattern = [ int(j) for j in Sub_pattern ]
        except:
            print("Replacement patterns for UA substitutions must be specified by atom_type, not element.")

        # Loop over centers performing substitutions and deletions
        Delete_list = []
        for j in Possibles:
            
            # Perform substitution on current site
            Atom_types[j] = Sub_pattern[0]

            # Iterate over connections to the current site
            for k in [ count_m for count_m,m in enumerate(Adj_mat[j]) if m == 1 ]:
                
                # Find the index in Sub_pattern corresponding to the current connection
                idx = [ count_n for count_n,n in enumerate(Find_pattern) if n == Atom_types[k] or n == Elements[k] ][0]

                # Add to Delete_list if deletion required
                if Sub_pattern[idx] == 0:
                    Delete_list = Delete_list + [k]
                else:
                    Atom_types[k] = Sub_pattern[idx]

        # Perform deletions
        Elements = [ Elements[m] for m in range(len(Elements)) if m not in Delete_list ]
        N_geometry = N_geometry[[ m for m in range(len(N_geometry)) if m not in Delete_list ],:]
        Atom_types = [ Atom_types[m] for m in range(len(Atom_types)) if m not in Delete_list ]
        Charges = [ Charges[m] for m in range(len(Charges)) if m not in Delete_list ]
        Structure = [ Structure[m] for m in range(len(Structure)) if m not in Delete_list ]
        Adj_mat = Adj_mat[[ m for m in range(len(Adj_mat[:,0])) if m not in Delete_list ],: ]
        Adj_mat = Adj_mat[:,[ m for m in range(len(Adj_mat[0,:])) if m not in Delete_list ]]                

        # Center new geometry at origin
        Centroid = array([mean(N_geometry[:,0]),mean(N_geometry[:,1]),mean(N_geometry[:,2])])
        for count_i,i in enumerate(N_geometry):
            N_geometry[count_i] = i-Centroid

    return Elements,Adj_mat,N_geometry,Atom_types,Charges,Structure

#def Find_parameters(Filename, Adj_mat, Atom_types, VDW_ij=0):
def Find_parameters(Adj_mat, Atom_types, verbose=1):

    # Initialize lists of each instance and type of FF object.
    # instances are stored as tuples of the atoms involved 
    # (e.g., bonds between atoms 1 and 13 and 17 and 5 would be stored as [(1,13),(17,5)] 
    # Similarly, types are stored as tuples of atom types.
    Bonds = []
    Bond_types = []
    Angles = []
    Angle_types = []
    Dihedrals = []
    Dihedral_types = []
    VDW_types = []

    # Find bonds #
    if verbose == 1:
        print("Parsing bonds...")
    for count_i,i in enumerate(Adj_mat):        
        Tmp_Bonds = [ (count_i,count_j) for count_j,j in enumerate(i) if j == 1 and count_j > count_i ]

        # Store bond tuple so that lowest atom *type* between the first and the second atom is placed first
        # and avoid redundant placements
        for j in Tmp_Bonds:
            if Atom_types[j[1]] < Atom_types[j[0]] and (j[1],j[0]) not in Bonds and (j[0],j[1]) not in Bonds:
                Bonds = Bonds + [ (j[1],j[0]) ]
                Bond_types = Bond_types + [ (Atom_types[j[1]],Atom_types[j[0]]) ]
            elif (j[0],j[1]) not in Bonds and (j[1],j[0]) not in Bonds:
                Bonds = Bonds + [ (j[0],j[1]) ]
                Bond_types = Bond_types + [ (Atom_types[j[0]],Atom_types[j[1]]) ]


    # Find angles #
    if verbose == 1:
        print("Parsing angles...")
    for i in Bonds:        

        # Find angles based on connections to first index of Bonds
        Tmp_Angles = [ (count_j,i[0],i[1]) for count_j,j in enumerate(Adj_mat[i[0]]) if j == 1 and count_j != i[1] ]

        # Store angle tuple so that lowest atom *type* between the first and the third is placed first
        # and avoid redundant placements
        for j in Tmp_Angles:
            if Atom_types[j[2]] < Atom_types[j[0]] and (j[2],j[1],j[0]) not in Angles and (j[0],j[1],j[2]) not in Angles:
                Angles = Angles + [(j[2],j[1],j[0])]
                Angle_types = Angle_types + [ (Atom_types[j[2]],Atom_types[j[1]],Atom_types[j[0]]) ]
            elif (j[0],j[1],j[2]) not in Angles and (j[2],j[1],j[0]) not in Angles:
                Angles = Angles + [(j[0],j[1],j[2])]
                Angle_types = Angle_types + [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]]) ]

        # Find angles based on connections to second index of Bonds
        Tmp_Angles = [ (i[0],i[1],count_j) for count_j,j in enumerate(Adj_mat[i[1]]) if j == 1 and count_j != i[0] ]

        # Store angle tuple so that lowest atom *type* between the first and the third is placed first
        # and avoid redundant placements
        for j in Tmp_Angles:
            if Atom_types[j[2]] < Atom_types[j[0]] and (j[2],j[1],j[0]) not in Angles and (j[0],j[1],j[2]) not in Angles:
                Angles = Angles + [(j[2],j[1],j[0])]
                Angle_types = Angle_types + [ (Atom_types[j[2]],Atom_types[j[1]],Atom_types[j[0]]) ]
            elif (j[0],j[1],j[2]) not in Angles and (j[2],j[1],j[0]) not in Angles:
                Angles = Angles + [(j[0],j[1],j[2])]
                Angle_types = Angle_types + [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]]) ]

        
    # Find dihedrals #
    if verbose == 1:
        print("Parsing dihedrals...")
    for i in Angles:
        
        # Find atoms attached to first atom of each angle
        Tmp_Dihedrals = [ (count_j,i[0],i[1],i[2]) for count_j,j in enumerate(Adj_mat[i[0]]) if j == 1 and count_j not in [i[1],i[2]] ]
        
        # Store dihedral tuple so that the lowest atom *type* between the first and fourth is placed first
        # and avoid redundant placements        
        for j in Tmp_Dihedrals:

            # If the first and fourth atoms are equal, then sorting is based on the second and third
            if Atom_types[j[3]] == Atom_types[j[0]] and (j[3],j[2],j[1],j[0]) not in Dihedrals and (j[0],j[1],j[2],j[3]) not in Dihedrals:
                if Atom_types[j[2]] < Atom_types[j[1]]:
                    Dihedrals = Dihedrals + [(j[3],j[2],j[1],j[0])]
                    Dihedral_types = Dihedral_types + [ (Atom_types[j[3]],Atom_types[j[2]],Atom_types[j[1]],Atom_types[j[0]]) ]
                else:
                    Dihedrals = Dihedrals + [(j[0],j[1],j[2],j[3])]
                    Dihedral_types = Dihedral_types + [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) ]

            elif Atom_types[j[3]] < Atom_types[j[0]] and (j[3],j[2],j[1],j[0]) not in Dihedrals and (j[0],j[1],j[2],j[3]) not in Dihedrals:
                Dihedrals = Dihedrals + [(j[3],j[2],j[1],j[0])]
                Dihedral_types = Dihedral_types + [ (Atom_types[j[3]],Atom_types[j[2]],Atom_types[j[1]],Atom_types[j[0]]) ]
            elif (j[0],j[1],j[2],j[3]) not in Dihedrals and (j[3],j[2],j[1],j[0]) not in Dihedrals:
                Dihedrals = Dihedrals + [(j[0],j[1],j[2],j[3])]
                Dihedral_types = Dihedral_types + [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) ]

        # Find atoms attached to the third atom of each angle
        Tmp_Dihedrals = [ (i[0],i[1],i[2],count_j) for count_j,j in enumerate(Adj_mat[i[2]]) if j == 1 and count_j not in [i[0],i[1]] ]
        
        # Store dihedral tuple so that the lowest atom *type* between the first and fourth is placed first
        # and avoid redundant placements        
        for j in Tmp_Dihedrals:

            # If the first and fourth atoms are equal, then sorting is based on the second and third
            if Atom_types[j[3]] == Atom_types[j[0]] and (j[3],j[2],j[1],j[0]) not in Dihedrals and (j[0],j[1],j[2],j[3]) not in Dihedrals:
                if Atom_types[j[2]] < Atom_types[j[1]]:
                    Dihedrals = Dihedrals + [(j[3],j[2],j[1],j[0])]
                    Dihedral_types = Dihedral_types + [ (Atom_types[j[3]],Atom_types[j[2]],Atom_types[j[1]],Atom_types[j[0]]) ]
                else:
                    Dihedrals = Dihedrals + [(j[0],j[1],j[2],j[3])]
                    Dihedral_types = Dihedral_types + [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) ]

            elif Atom_types[j[3]] < Atom_types[j[0]] and (j[3],j[2],j[1],j[0]) not in Dihedrals and (j[0],j[1],j[2],j[3]) not in Dihedrals:
                Dihedrals = Dihedrals + [(j[3],j[2],j[1],j[0])]
                Dihedral_types = Dihedral_types+ [ (Atom_types[j[3]],Atom_types[j[2]],Atom_types[j[1]],Atom_types[j[0]]) ]
            elif (j[0],j[1],j[2],j[3]) not in Dihedrals and (j[3],j[2],j[1],j[0]) not in Dihedrals:
                Dihedrals = Dihedrals + [(j[0],j[1],j[2],j[3])]
                Dihedral_types = Dihedral_types + [ (Atom_types[j[0]],Atom_types[j[1]],Atom_types[j[2]],Atom_types[j[3]]) ]
            
    # Find non-bonded interactions #
#    print "Parsing VDW interactions..."

    # Note that LAMMPS easily calculates cross VDW parameters on the fly
    # using the pair_modify keyword, so usually cross terms do not need to 
    # be included explicitly.
#     if VDW_ij == 1:
#         for i in set(Atom_types):
#             for j in set(Atom_types):
#                 if i<=j and (i,j) not in VDW_types:
#                     VDW_types = VDW_types + [(i,j)]

#                 elif j<i and (j,i) not in VDW_types:
#                     VDW_types = VDW_types + [(j,i)]
#     else:
#         for i in set(Atom_types):
#             VDW_types = VDW_types + [(i,i)]

    # Reduce the type lists down to unique entries
    Bond_types = [ i for i in set(Bond_types) ]
    Angle_types = [ i for i in set(Angle_types) ]
    Dihedral_types = [ i for i in set(Dihedral_types) ]
        
    # Print System characteristics
    if verbose == 1:
        print("\nSystem characteristics (look over for anything suspicious):")
        print("\nAtom_types ({}):\n".format(len(set(Atom_types))))
        for i in sorted(set(Atom_types)):
            print("\t{}".format(i))
        print("\nBond types ({}):\n".format(len(set(Bond_types))))
        for i in sorted(set(Bond_types)):
            print("\t{}".format(i))
        print("\nAngle types ({}):\n".format(len(set(Angle_types))))
        for i in sorted(set(Angle_types)):
            print("\t{}".format(i))
        print("\nDihedral types ({}):\n".format(len(set(Dihedral_types))))
        for i in sorted(set(Dihedral_types)):
            print("\t{}".format(i))

    ##############################################################
    # Read in parameters: Here the stretching, bending, dihedral #
    # and non-bonding interaction parameters are read in from    #
    # parameters file. Mass and charge data is also included.    #
    # The program looks for a simple match for the first entry   #
    # in each line with one of the bond or angle types.          #
    # INPUT: param_file, BOND_TYPES_LIST, ANGLE_TYPES_LIST       #
    #        DIHEDRAL_TYPES_LIST, ELEMENTS                       #
    # OUTPUT: CHARGES, MASSES, BOND_PARAMS, ANGLE_PARAMS,        #
    #         DIHERAL_PARAMS, PW_PARAMS                          #
    ##############################################################

    return Angles,Bonds,Dihedrals

# Uses the adjacency matrix to determine which dihedrals share 1-2 atoms. These are considered
# coicident and only one rotation about the bond is needed to parametrize all of the coincident modes.
def Find_coincident_dihedrals(dihedral_atoms,keep_ind,atom_types,adj_mat,mode='type'):

    # Find all dihedrals (and types) being sampled about this rotation. Leave out dihedrals
    # involving atoms not listed in keep_ind (usually hydrogens if united atom FF params are desired.)
    if mode == 'type':
        left_atoms = [ count_a for count_a,a in enumerate(adj_mat[dihedral_atoms[1],:]) if a == 1 and count_a != dihedral_atoms[2] and atom_types[count_a] in keep_ind ]
        right_atoms = [ count_a for count_a,a in enumerate(adj_mat[dihedral_atoms[2],:]) if a == 1 and count_a != dihedral_atoms[1] and atom_types[count_a] in keep_ind ]
    elif mode == 'index':
        left_atoms = [ count_a for count_a,a in enumerate(adj_mat[dihedral_atoms[1],:]) if a == 1 and count_a != dihedral_atoms[2] and count_a in keep_ind ]
        right_atoms = [ count_a for count_a,a in enumerate(adj_mat[dihedral_atoms[2],:]) if a == 1 and count_a != dihedral_atoms[1] and count_a in keep_ind ]

    coincident_dihedrals = []
    coincident_dihedral_types = []
    for l in left_atoms:
        for r in right_atoms:

            # Skip current dihedral
            if tuple([l,dihedral_atoms[1],dihedral_atoms[2],r]) == dihedral_atoms or tuple([r,dihedral_atoms[2],dihedral_atoms[1],l]) == dihedral_atoms:
                continue

            # dihedral types are written so that the lesser *atom_type* between 1 and 4 is first.
            # In the event that 1 and 4 are of the same type, then the lesser of 2 and 3 goes first
            if atom_types[l] == atom_types[r]:
                if atom_types[dihedral_atoms[1]] <= atom_types[dihedral_atoms[2]]:
                    coincident_dihedral_types += [(atom_types[l],atom_types[dihedral_atoms[1]],atom_types[dihedral_atoms[2]],atom_types[r])]
                    coincident_dihedrals += [(l,dihedral_atoms[1],dihedral_atoms[2],r)]        
                else:
                    coincident_dihedral_types += [(atom_types[r],atom_types[dihedral_atoms[2]],atom_types[dihedral_atoms[1]],atom_types[l])]
                    coincident_dihedrals += [(r,dihedral_atoms[2],dihedral_atoms[1],l)]        
            elif atom_types[l] < atom_types[r]:
                coincident_dihedral_types += [(atom_types[l],atom_types[dihedral_atoms[1]],atom_types[dihedral_atoms[2]],atom_types[r])]
                coincident_dihedrals += [(l,dihedral_atoms[1],dihedral_atoms[2],r)]        
            else:
                coincident_dihedral_types += [(atom_types[r],atom_types[dihedral_atoms[2]],atom_types[dihedral_atoms[1]],atom_types[l])]            
                coincident_dihedrals += [(r,dihedral_atoms[2],dihedral_atoms[1],l)]                            

    return coincident_dihedrals,coincident_dihedral_types

# This is a messy wrapper for FF_dict write commands.
def write_single_params(folder,name,element,atomtype,charge,geo):

    #####################
    #  Process Masses   #
    #####################

    # Initialize mass_dict and van der waals dictionaries (used as default values in several places).
    mass_dict = {'H':1.00794,'He':4.002602,'Li':6.941,'Be':9.012182,'B':10.811,'C':12.011,'N':14.00674,'O':15.9994,'F':18.9984032,'Ne':20.1797,\
                 'Na':22.989768,'Mg':24.3050,'Al':26.981539,'Si':28.0855,'P':30.973762,'S':32.066,'Cl':35.4527,'Ar':39.948,\
                 'K':39.0983,'Ca':40.078,'Sc':44.955910,'Ti':47.867,'V':50.9415,'Cr':51.9961,'Mn':54.938049,'Fe':55.845,'Co':58.933200,'Ni':58.6934,'Cu':63.546,'Zn':65.39,\
                 'Ga':69.723,'Ge':72.61,'As':74.92159,'Se':78.96,'Br':79.904,'Kr':83.80,\
                 'Rb':85.4678,'Sr':87.62,'Y':88.90585,'Zr':91.224,'Nb':92.90638,'Mo':95.94,'Tc':98.0,'Ru':101.07,'Rh':102.90550,'Pd':106.42,'Ag':107.8682,'Cd':112.411,\
                 'In':114.818,'Sn':118.710,'Sb':121.760,'Te':127.60,'I':126.90447,'Xe':131.29,\
                 'Cs':132.90545,'Ba':137.327,'La':138.9055,'Hf':178.49,'Ta':180.9479,'W':183.84,'Re':186.207,'Os':190.23,'Ir':192.217,'Pt':195.078,'Au':196.96655,'Hg':200.59,\
                 'Tl':204.3833,'Pb':207.2,'Bi':208.98038,'Po':209.0,'At':210.0,'Rn':222.0}

    ##########################
    #  Write FF information  #
    ##########################

    # The formatting of this database file is compatible 
    # with the input for the polygen.py program.
    f = open(folder+'/'+name, 'w')

    # Write atom type definitions
    f.write("\n# Atom type definitions\n#\n{:10s} {:40s} {:40s} {:19s}\n".format("#","Atom_type","Label","Mass"))        
    f.write("{:10s} {:40s} {:39s} {:< 20.6f}\n".format("atom",atomtype,element+'-'+atomtype,mass_dict[element]))
    f.write("{:10s} {:40s} {:39s} {:< 20.6f}\n".format("atom",atomtype+'-UA',element+'-'+atomtype,mass_dict[element]))

    # Write charge definitions
    f.write("\n# Charge definitions\n#\n{:10s} {:41s} {:20s}\n".format("#","Atom_type","Charge"))
    f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",atomtype,charge))
    f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",atomtype+'-UA',charge))

    # Write examples of each molecule in the sim to a molecule.db file. This is used when
    # adding the parameters to the master database. Each parameter in the master is linked
    # to the molecule(s) used to generate it. In the case of intramolecular params, the globally optimized
    # geometry is saved to the db.
    with open(folder+'/molecules.db','w') as f:
        f.write("\nmol {:6d} start\n".format(1))
        # Save an xyz for viewing the configuration in VMD
        f.write('1\n\n'.format(len(geo)))
        f.write('  {:<10s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 12.6f} {:<60s}\n'.format(element,geo[0],geo[1],geo[2],charge,atomtype))
        f.write("mol {:6d} end\n".format(1))

    return

# This is a messy wrapper for FF_dict write commands.
def write_zero_params(folder,name,bonds,angles,dihedrals,atomtypes,elements,geo):

    ##########################
    #  Write FF information  #
    ##########################

    # The formatting of this database file is compatible 
    # with the input for the polygen.py program.
    f = open(folder+'/'+name, 'w')

    # Write bond definitions
    f.write("\n# Bond type definitions\n#\n{:10s} {:40s} {:40s} {:21s} {:20s} {:20s}\n".format("#","Atom_type","Atom_type","style","k (kcal/mol ang^-2)","R0 (ang)"))        
    for i in set(bonds):
        # f.write("{:10s} {:40s} {:40s} {:20s} {:< 20.6f} {:< 20.6f}\n".format("bond",atomtypes[i[0]],atomtypes[i[1]],"harmonic",0.0,1.0))
        f.write("{:10s} {:40s} {:40s} {:20s} {:< 20.6f} {:< 20.6f}\n".format("bond",i[0],i[1],"harmonic",0.0,1.0))

    # Write angle definitions
    f.write("\n# Angle type definitions\n#\n{:10s} {:40s} {:40s} {:40s} {:21s} {:20s} {:20s}\n"\
            .format("#","Atom_type","Atom_type","Atom_type","style","k (kcal/mol rad^-2)","Theta_0 (degrees)"))        
    for i in set(angles):
#         f.write("{:10s} {:40s} {:40s} {:40s} {:20s} {:< 20.6f} {:< 20.6f}\n"\
#                 .format("angle",atomtypes[i[0]],atomtypes[i[1]],atomtypes[i[2]],"harmonic",0.0,180.0))
        f.write("{:10s} {:40s} {:40s} {:40s} {:20s} {:< 20.6f} {:< 20.6f}\n"\
                .format("angle",i[0],i[1],i[2],"harmonic",0.0,180.0))

    # Write dihedral definitions
    f.write("\n# Dihedral/Torsional type definitions\n#\n{:10s} {:40s} {:40s} {:40s} {:40s} {:21s} {:20s}\n".format("#","Atom_type","Atom_type","Atom_type","Atom_type","style","Params"))
    for i in set(dihedrals):
#        f.write("{:10s} {:40s} {:40s} {:40s} {:40s} {:20s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 20.6f}\n"\
#         .format("torsion",atomtypes[i[0]],atomtypes[i[1]],atomtypes[i[2]],atomtypes[i[3]],"opls",0.0,0.0,0.0,0.0))
        f.write("{:10s} {:40s} {:40s} {:40s} {:40s} {:20s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 20.6f}\n"\
         .format("torsion",i[0],i[1],i[2],i[3],"opls",0.0,0.0,0.0,0.0))

    # Write examples of each molecule in the sim to a molecule.db file. This is used when
    # adding the parameters to the master database. Each parameter in the master is linked
    # to the molecule(s) used to generate it. In the case of intramolecular params, the globally optimized
    # geometry is saved to the db.
    with open(folder+'/molecules.db','w') as f:
        f.write("\nmol {:6d} start\n".format(1))
        # Save an xyz for viewing the configuration in VMD
        f.write('{}\n\n'.format(len(geo)))
        for count_i,i in enumerate(geo):
            f.write('  {:<10s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 12.6f} {:<60s}\n'.format(elements[count_i],i[0],i[1],i[2],-99999,atomtypes[count_i]))
        f.write("mol {:6d} end\n".format(1))

    return

# Description: Reads in the FF
def get_FF_data(avoid_files,gens=2,no_harmonic_db=0,keep_types=[ "atom", "vdw", "bond", "angle", "torsion", "dihedral", "charge" ]):

    Data = {"atoms":{},"bonds":{},"angles":{},"dihedrals":{},"vdws":{},"charges":{}}
    
    for avoid in avoid_files:
        
        # Parse as a *.xyz file
        if avoid.split('.')[-1] == "xyz":

            Elements,Geometry = xyz_parse(avoid)                             # Extract Element list and Coord list from the file
            Adj_mat = Table_generator(Elements,Geometry)                      # Generate adjacency table

            # Check the number of molecules
            Num_mol = mol_count(Adj_mat)
            if Num_mol > 1:
                print("ERROR: {} molecules were discovered in a file supplied to -avoid ({}). Check the geometry of the file. Exiting...".format(avoid))
                quit()

            # Find linear, branched, and cyclic segments
            Structure = Structure_finder(Adj_mat)

            # Find backbone
            Backbone = Dijkstra(Adj_mat)

            # Find Hybridizations
            Hybridizations = Hybridization_finder(Elements,Adj_mat)

            # Find atom_types
            Atom_types = id_types(Elements,Adj_mat,gens,Hybridizations,Geometry)

            # Update Atom_types if any are in rings
            for count_i,i in enumerate(Atom_types):
                if Structure[count_i]>2:
                    Atom_types[count_i] = "R"+i

            # Look up the FF parameters: Angles Bonds and Dihedrals are a list of lists, holding 
            # the indices of the atoms participating in each object.
            Angles,Bonds,Dihedrals = Find_parameters(Adj_mat,Atom_types,verbose=0)

            for i in Bonds:
                Data["bonds"][(Atom_types[i[0]],Atom_types[i[1]],'harmonic')]=["IN PROGRESS"]
                Data["bonds"][(Atom_types[i[1]],Atom_types[i[0]],'harmonic')]=["IN PROGRESS"]

            for i in Angles:
                Data["angles"][(Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],'harmonic')]=["IN PROGRESS"]
                Data["angles"][(Atom_types[i[2]],Atom_types[i[1]],Atom_types[i[0]],'harmonic')]=["IN PROGRESS"]

            for i in Dihedrals:

                # Check conditions for harmonic dihedrals (i.e. the 2-3 atoms are part of a ring, or if the 2-3 atoms are part of a double bond)
                if "R" in Atom_types[i[1]].split('[')[0] and "R" in Atom_types[i[2]].split('[')[0]:
                    dihedral_type = 'harmonic'
                elif no_harmonic_db == 0 and True in [ j in ["E","Z"] for j in Atom_types[i[1]].split('[')[0] ] and True in [ j in ["E","Z"] for j in Atom_types[i[2]].split('[')[0] ]:
                    dihedral_type = 'harmonic'
                else:
                    dihedral_type = 'opls'
                Data["dihedrals"][(Atom_types[i[0]],Atom_types[i[1]],Atom_types[i[2]],Atom_types[i[3]],dihedral_type)]=["IN PROGRESS"]
                Data["dihedrals"][(Atom_types[i[3]],Atom_types[i[2]],Atom_types[i[1]],Atom_types[i[0]],dihedral_type)]=["IN PROGRESS"]

        # Parse as a *.db file
        else:

            # Read in parameters from FF file
            with open(avoid,'r') as f:
                for lines in f:
                    fields = lines.split()

                    if len(fields) == 0: continue
                    if fields[0] == "atom" and "atom" in keep_types:
                        Data["atoms"][fields[1]] = fields[1:]
                    if fields[0] == "vdw" and "vdw" in keep_types:
                        Data["vdws"][(fields[1],fields[2],fields[3])] = fields[1:]
                    if fields[0] == "bond" and "bond" in keep_types:
                        Data["bonds"][(fields[1],fields[2],fields[3])] = fields[1:]
                    if fields[0] == "angle" and "angle" in keep_types:
                        Data["angles"][(fields[1],fields[2],fields[3],fields[4])] = fields[1:]
                    if fields[0] == "dihedral" or fields[0] == "torsion" and ( "dihedral" in keep_types or "torsion" in keep_types ):
                        Data["dihedrals"][(fields[1],fields[2],fields[3],fields[4],fields[5])] = fields[1:]
                    if fields[0] == "charge" and "charge" in keep_types:
                        Data["charges"][fields[1]] = fields[1:]
        
    return Data

# Returns the geometry and relevant property lists corresponding to the smallest fragment
# that is consistent with the bond being parametrized.
# If the 1 or 4 atom is a ring, then the entire ring is included. 
def mode_frag(M,Geometry,Adj_mat,Elements,Atom_types,gens):

    # Create copies of input lists/arrays
    N_Elements = copy(Elements)
    N_Atom_types = deepcopy(Atom_types)
    N_Geometry = copy(Geometry)
    N_Adj_mat = copy(Adj_mat)

    if len(M) < 4:
        current = list(M)             # Holds the atoms found in each generation (seeded with the mode atoms)
        atoms = list(M)               # Holds the total set of included atoms (seeded with the mode atoms)
    else:
        current = [M[1],M[2]]         # Holds the atoms found in each generation (seeded with the 2-3 atoms)
        atoms = [M[1],M[2]]           # Holds the total set of included atoms (seeded with the 2-3 atoms)


    # Perform a depth search based on the gens argument
    for i in range(gens):

        # Initialize an empty list to hold the indices of atoms discovered in this generation
        new = []

        # Iterate over the atoms discovered in the previous generation (seeded initially with the bond atoms)
        for j in current:

            # Add bonded atoms to the new generation
            new += [ count_k for count_k,k in enumerate(N_Adj_mat[j]) if k == 1 and count_k not in atoms ]

        # Update the current and atoms lists with the atoms discovered in this generation
        # NOTE: the current list is overwritten while the atoms list is appended. The set call avoids double additions (sometimes occurs with cyclic topologies)
        current = list(set(new))
        atoms += list(set(new))

    # Finish any rings that were included in the initial gens-bond deep search
    rings = set([ i for i in new if "R" in Atom_types[i].split(']')[0].split('[')[0] ])
    while len(rings) > 0:
        atoms += [ i for i in rings if i not in atoms ]
        for i in rings:
            tmp = list(set([ count_j for count_j,j in enumerate(N_Adj_mat[i]) if j == 1 and "R" not in Atom_types[count_j].split(']')[0].split('[')[0] and count_j not in atoms ])) # Add non-ring atoms connected one deep from the ring atoms  
            new += tmp
            atoms += tmp
        rings = set([ count_j for i in rings for count_j,j in enumerate(N_Adj_mat[i]) if j == 1 and "R" in Atom_types[count_j].split(']')[0].split('[')[0] and count_j not in atoms ]) # Add unique ring atoms

    # For the last generation, hydrogenate non-terminal bonds of heavy atoms, terminal bonded atoms are kept as is
    for i in new:
        ind = [ count_k for count_k,k in enumerate(N_Adj_mat[i]) if k == 1 and count_k not in atoms ]
        term = [ k for k in ind if sum(N_Adj_mat[k]) == 1 ]
        atoms += ind
        for j in ind:

            # Replace non-terminal link atoms with hydrogens
            if j not in term: 
                N_Elements[j] = "H"
                N_Geometry[j] = N_Geometry[i] + ( N_Geometry[j] - N_Geometry[i] ) / norm( N_Geometry[j] - N_Geometry[i] ) * 1.1

            # Assign link atom type. In the FF, 0 is reserved for dummy atoms. Atom types are prepended with a "-link" so that the 
            # the script for extracting parameters can use the proper charges/vdw for these types.
#            N_Atom_types[j] = "[0]" 
            N_Atom_types[j] = 'link-'+N_Atom_types[j]

    # Update lists/arrays based on atoms
    N_M          = tuple([ atoms.index(i) for i in M ])
    N_Geometry   = N_Geometry[atoms]
    N_Adj_mat    = N_Adj_mat[atoms]
    N_Adj_mat    = N_Adj_mat[:,atoms]
    N_Elements   = [ N_Elements[i] for i in atoms ]
    N_Atom_types = [ N_Atom_types[i] for i in atoms ]
    return N_M,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types


# Returns the geometry and relevant property lists corresponding to the smallest fragment
# that is consistent with the dihedral being parametrized (1-4 atoms only receive a gen-1 depth search)
def dihedral_frag(M,Geometry,Adj_mat,Elements,Atom_types,gens):

    # Create copies of input lists/arrays
    N_Elements = copy(Elements)
    N_Atom_types = copy(Atom_types)
    N_Geometry = copy(Geometry)
    N_Adj_mat = copy(Adj_mat)

    current = [M[1],M[2]]         # Holds the atoms found in each generation (seeded with the 2-3 atoms)
    atoms = [M[1],M[2]]           # Holds the total set of included atoms (seeded with the 2-3 atoms)

    # Perform a depth search based on the gens argument
    for i in range(gens):

        # Initialize an empty list to hold the indices of atoms discovered in this generation
        new = []

        # Iterate over the atoms discovered in the previous generation (seeded initially with the bond atoms)
        for j in current:

            # Add bonded atoms to the new generation
            new += [ count_k for count_k,k in enumerate(N_Adj_mat[j]) if k == 1 and count_k not in atoms ]

        # Update the current and atoms lists with the atoms discovered in this generation
        # NOTE: the current list is overwritten while the atoms list is appended.
        current = new
        atoms += new

    # For the last generation, hydrogenate bonds of heavy atoms
    for i in new:
        ind = [ count_k for count_k,k in enumerate(N_Adj_mat[i]) if k == 1 and count_k not in atoms ]
        atoms += ind
        for j in ind:
            N_Elements[j] = "H"
            N_Atom_types[j] = "[0]" # in the FF [0] is reserved for dummy atoms
            N_Geometry[j] = N_Geometry[i] + ( N_Geometry[j] - N_Geometry[i] ) / norm( N_Geometry[j] - N_Geometry[i] ) * 1.1

    # Update lists/arrays based on atoms
    N_M          = tuple([ atoms.index(i) for i in M ])
    N_Geometry   = N_Geometry[atoms]
    N_Adj_mat    = N_Adj_mat[atoms]
    N_Adj_mat    = N_Adj_mat[:,atoms]
    N_Elements   = [ N_Elements[i] for i in atoms ]
    N_Atom_types = [ N_Atom_types[i] for i in atoms ]

    return N_M,N_Geometry,N_Adj_mat,N_Elements,N_Atom_types

def write_mode_geo(name,Elements,Geometry,Atom_types):

    # Used for indexing the first instance of each unique atom type
    atoms = sorted(set(Atom_types))

    # Write master/globally optimized geometry with atom types to the parent directory
    with open(name,'w') as f:
        list_of_indices = sorted([ count_j for _ in set(atoms) for count_j,j in enumerate(Atom_types) if _ == j])
        f.write("{}\nIndices: {}\n".format(len(Elements),' '.join([ str(_) for _ in list_of_indices ])))

        for count_i,i in enumerate(Elements):
            f.write("{:<12s} {:< 20.14f} {:< 20.14f} {:< 20.14f} {:s}\n".format(i,Geometry[count_i,0],Geometry[count_i,1],Geometry[count_i,2],Atom_types[count_i]))
        f.close()

# Create logger to save stdout to logfile
class Logger(object):

    def __init__(self,folder):
        self.terminal = sys.stdout
        self.log = open(folder+"/paramgen.log", "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)  

    def flush(self):
        pass

if __name__ == "__main__":
   main(sys.argv[1:])
