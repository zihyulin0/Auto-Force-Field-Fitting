#!/bin/env python
# Author: Brett Savoie (brettsavoie@gmail.com)

import sys,argparse,os,re,fnmatch
from scipy.optimize import leastsq
from scipy.optimize import minimize
import scipy.optimize
from scipy.spatial.distance import cdist
import math
import numpy as np #from numpy import *
from numpy.linalg import norm
from copy import deepcopy
import time
from itertools import combinations

# Add TAFFY Lib to path
sys.path.append('/'.join(os.path.abspath(__file__).split('/')[:-2])+'/Lib')
from transify import *
from adjacency import *
from file_parsers import *
from id_types import *
from kekule import *
import random

def main(argv):

    element,geo,charge = read_lammpstrj('single.lammpstrj')
    dipole = calc_dipole(geo,charge,debye=True)
    unit = 'debye'
    print("dipole from fitted_charges:  {:<12.6f} {:<12.6f} {:<12.6f} {:<12.6f} {:<60s}".format(dipole[0][0],dipole[0][1],dipole[0][2],dipole[1],unit))
    #print(geo)
    print(charge)
    quit()
    parser = argparse.ArgumentParser(description='This program generates CHELPG or RESP charges from potential grids generated by orca.')

    #optional arguments                                                                                                                                                        

    parser.add_argument('-xyz', dest='xyz_file', default=None,
                        help = 'The geometry of the nuclear centers can be supplied in the form of an xyz file (a typical output of orca) with coordinates in angstroms. If the '\
                               '*.xyz file is not supplied, then the element labels for the nuclear centers must be supplied to geometry block of the *.vpot file. (default: None)')

    parser.add_argument('-d', dest='path', default=None,
                        help = 'When filename is a folder, the program operates on all files with the extension *.vpot discovered during a directory walk. Optionally, if this argument is supplied then only *.vpot files '+\
                               'whose path includes the -d argument will be operated on. (default: None)')

    parser.add_argument('-out', dest='out_file', default=None,
                        help = 'For fitting the dipole and/or quadrupole moment, the output file holding these quantities must be supplied (default: None)')


    parser.add_argument('-gens', dest='gens', default=2,
                        help = 'Number of generations for defining atom type uniqueness. (default: 2)')

    parser.add_argument('-seed', dest='seed', default=444,
                        help = 'The seed for the random number generator. (default: 444)')


    parser.add_argument('-FF', dest='FF_db', default="",
                        help = 'A space-delimited string containing taffi force field database(s). Any partial charges contained in the supplied database(s) are held fixed during the fitting procedure. (default: none)')

    parser.add_argument('--keep_min', dest='keep_min', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, partial charges are only written for atomtypes that the xyz corresponds to their minimum fragment. (default: off)')

    parser.add_argument('--debye', dest='debye', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, the output unit is debye (default: A.U)')

    parser.add_argument('--charmm', dest='charmm', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, the calculation is based on the output of CHARMM (default:off)')


    # Parse the inputs
    args=parser.parse_args(argv)
    args.FF_db = args.FF_db.split()
    args.gens = int(args.gens)

    # Use a fixed seed value to ensure reproducibility between runs
    random.seed(int(args.seed))

    # Check if the folder protocol or file protocol is being used
    # the former performs a recursive search for *.vpot files and 
    if os.path.isdir(args.xyz_file) == True:
        folder_protocol = True
    else:
        folder_protocol = False

    # If supplied, check that the FF files exist
    fixed_dict={}
    fixed_dict_alpha = {}
    if args.FF_db != []:
        for i in args.FF_db:
            if os.path.isfile(i) is False:
                print(("ERROR: the file {} supplied to -FF does not exist. Exiting...".format(i)))
                quit()
            else:
                with open(i,'r') as f:
                    for lines in f:
                        fields = lines.split()
                        if len(fields) >= 2 and fields[0] == "charge":
                            fixed_dict[fields[1]] = float(fields[2])
                with open(i,'r') as f:
                    for lines in f:
                        fields = lines.split()
                        if len(fields) >= 2 and fields[0] == "polar":
                            fixed_dict_alpha[fields[1]] = float(fields[2])



    # Print header
    #print(("\n{}".format("*"*140)))
    #print(("* {:^136s} *".format("Parsing Partial Charges in {}".format(args.filename))))
    #print(("{}".format("*"*140)))

    #################################
    # file based consistency checks #
    #################################

    if folder_protocol == False:

        # Initialize lists. These are overkill for the single file but they conform to the directory-based protocol for parsing many files at once.
        outputs  = [args.out_file]
        xyzs     = [args.xyz_file]
        paths    = ['.']

        #  Parse the dipole/quadupole if an output file is supplied
        if args.out_file is not None:
            if os.path.isfile(args.out_file) == False:
                print(("ERROR in extract_charges: the supplied output file for reading dipole/quadrupole data ({}) does not exist. Exiting...".format(args.out_file)))
                quit()
            else:
                outputs = [args.out_file]
                dipole_0,quadrupole_0 = parse_orca_out(args.out_file)
        else:
            dipole_0 = None
            quadrupole_0 = None

        # Check for required files and print warnings for inconsistent parameter specifications
        if args.xyz_file is not None and os.path.isfile(args.xyz_file) == False:
            print(("ERROR in extract_charges: the supplied xyz filename ({}), could not be found. Exiting...".format(args.xyz_file)))

    ###################################
    # folder based consistency checks #
    ###################################
    elif folder_protocol == True:

        # Create a dictionary from the filenames, where each dictionary key corresponds to a filename and each entry is a list
        # of subfiles to be processed as a batch. e.g., molecule.in might show up in twenty subfolders. molecule.in would end
        # up as a key, and the list of individual instances of molecule.in would constitute the entry.
        Files = {}
        if args.path is None:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(args.xyz_file+'/.') for f in filenames if fnmatch.fnmatch(f,"*.xyz") ]
        else:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(args.xyz_file+'/.') for f in filenames if (fnmatch.fnmatch(f,"*.xyz") and args.path in dp)  ]

        # Assemble paths, xyz files, and output files
        paths    = [ "/".join(i.split('/')[:-1]) for i in potfiles ]
        xyzs     = []
        outputs  = []
        for count_i,i in enumerate(paths):
            tmp_out = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.out") ]
            tmp_xyz = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.xyz") ]

            # Populate in a one-to-one path to *.out and *.xyz fashion. Place None in the list if no matching file was found. If multiple matches are found then place the first file in the list.
            if len(tmp_out) > 0:
                outputs += [tmp_out[0]]
            else:
                outputs += [None]
            if len(tmp_xyz) > 0: 
                xyzs    += [tmp_xyz[0]]
            else:
                xyzs    += [None]
                    
        # Check for required files and print warnings for inconsistent parameter specifications
        if None in outputs and args.w_dipole != 0.0:
            print("WARNING in extract_charges: Output files for reading the dipole moment could not be found for all discovered *.vpot files and the dipole weight is set to a non-zero value.")
            print("                            fit_charges will set the dipole weight to zero and continue with the fit.")
            args.w_dipole = 0
        if None in outputs and args.w_quadrupole != 0.0:
            print("WARNING in extract_charges: Output files for reading the quadrupole moment could not be found for all discovered *.vpot files and the quadrupole weight is set to a non-zero value.")
            print("                            fit_charges will set the quadrupole weight to zero and continue with the fit.")
            args.w_quadrupole = 0
    # Print diagnostic
        print(("Number of Configurations Being Parsed: {}\n".format(len(potfiles))))    




    ################
    # All-Atom Fit # 
    ################
    #print(xyzs)
    #print(outputs)
    for count_f,f in enumerate(xyzs):
         elements,geo = read_xyz(f)

         cm = calc_cm(elements,geo*0.52917721067)
         print("center of mass: {}".format(cm))

         # Generate the adjacency matrix
         # NOTE: the units are converted back angstroms
         adj_mat = Table_generator(elements,geo*0.52917721067,File=xyzs[count_f])

         # Generate the atomtypes
         #atomtypes = id_types(elements,adj_mat,args.gens,Hybridization_finder(elements,adj_mat),geo*0.52917721067)
         atomtypes = id_types(elements,adj_mat,args.gens) # id_types v.062520
         
         fix_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i in list(fixed_dict.keys()) ]
         fit_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i not in list(fixed_dict.keys()) ]
         charges_0      = np.array([ 0.0 if count_i in fit_ind else fixed_dict[atomtypes[count_i]] for count_i,i in enumerate(atomtypes) ])

         print(charges_0)
         print(atomtypes)

         if args.debye:
            unit = 'Debye' 
            # Parse dipole/quadrupole
            if outputs[count_f] is not None:
               dipole_0,quadrupole_0 = parse_orca_out(outputs[count_f],debye=True)

            dipole = calc_dipole(geo,charges_0,debye=True)
         else:
            unit = 'A.U'
            if outputs[count_f] is not None:
               dipole_0,quadrupole_0 = parse_orca_out(outputs[count_f])

            dipole = calc_dipole(geo,charges_0,[0,0,0])
         print("dipole from fitted_charges:  {:<12.6f} {:<12.6f} {:<12.6f} {:<12.6f} {:<60s}".format(dipole[0][0],dipole[0][1],dipole[0][2],dipole[1],unit))
         if(dipole_0 is not None):
            print("dipole from DFT: {:<12.6f} {:<60s}".format(norm(dipole_0),unit))
            print("error: (original, not squared) {:<12.6f}".format(dipole-norm(dipole_0)))
            
    # Write the charge database file(s)
    #write_params(args.output_folder+'/chelpg.db',lstsq_dict)
    #write_params(args.output_folder+'/fit_charges.db',fit_dict)

    # Write molecule.db file. This is used for integrating parameters into master database files
    # so that parameters can be linked with the model molecule used to parametrize them.
    #write_molecule_db(args.output_folder,elements,geo,[ np.mean(fit_dict[i]) if i in fit_dict else 0.0 for i in atomtypes ],atomtypes)


    return

# read in xyz file 
# Angstrom is converted to Bohr
def read_xyz(filename):
     atom_count = 0
     with open(filename,'r') as f:
         for lc,lines in enumerate(f):

             # Initialize elements and geometry lists/arrays
             if lc == 0:
                 fields = lines.split()
                 N_elements = ["X"]*int(fields[0])
                 N_geo      = np.zeros([int(fields[0]),3])
                 continue

             # Parse the nuclei
             # With a conversion from angstroms to bohr
             if lc > 1:
                 fields = lines.split()
                 if len(fields) == 0: 
                     continue
                 else:
                     N_elements[atom_count] = fields[0]
                     N_geo[atom_count] = np.array([ float(i)/0.52917721067 for i in fields[1:4] ])
                     #N_geo[atom_count] = np.array([ float(i) for i in fields[1:4] ])
                     atom_count += 1

     return N_elements,N_geo
def read_lammpstrj(filename):
     atom_count = 0
     with open(filename,'r') as f:
         for lc,lines in enumerate(f):

             # Initialize elements and geometry lists/arrays
             if lc == 0:
                 fields = lines.split()
                 N_elements = ["X"]*int(fields[0])
                 N_geo      = np.zeros([int(fields[0]),3])
                 N_charge      = np.zeros(int(fields[0]))
                 continue

             # Parse the nuclei
             # With a conversion from angstroms to bohr
             if lc > 1:
                 fields = lines.split()
                 if len(fields) == 0: 
                     continue
                 else:
                     N_elements[atom_count] = fields[1]
                     N_geo[atom_count] = np.array([ float(i)/0.52917721067 for i in fields[2:5] ])
                     N_charge[atom_count] = float(fields[5])
                     #N_geo[atom_count] = np.array([ float(i) for i in fields[1:4] ])
                     atom_count += 1
     return N_elements,N_geo,N_charge
# Description:   Checks is the supplied geometry corresponds to the minimal structure of the molecule
# 
# Inputs:        atomtype:      The taffi atomtype being checked
#                geo:           Geometry of the molecule
#                elements:      elements, indexed to the geometry 
#                adj_mat:       adj_mat, indexed to the geometry (optional)
#                atomtypes:     atomtypes, indexed to the geometry (optional)
#                gens:          number of generations for determining atomtypes (optional, only used if atomtypes are not supplied)
# 
# Outputs:       Boolean:       True if geo is the minimal structure for the atomtype, False if not.
def minimal_structure(atomtype,geo,elements,adj_mat=None,atomtypes=None,gens=2):

    # If required find the atomtypes for the geometry
    if atomtypes is None or adj_mat is None:
        if len(elements) != len(geo):
            print("ERROR in minimal_structure: While trying to automatically assign atomtypes, the elements argument must have dimensions equal to geo. Exiting...")
            quit()

        # Generate the adjacency matrix
        # NOTE: the units are converted back angstroms
        adj_mat = Table_generator(elements,geo)

        # Generate the atomtypes
        #atomtypes = id_types(elements,adj_mat,gens,Hybridization_finder(elements,adj_mat),geo)
        atomtypes = id_types(elements,adj_mat,gens) # id_types v.062520
        
    # Check minimal conditions
    count = 0
    for count_i,i in enumerate(atomtypes):

        # If the current atomtype matches the atomtype being searched for then proceed with minimal geo check
        if i == atomtype:
            count += 1

            # Initialize lists for holding indices in the structure within "gens" bonds of the seed atom (count_i)
            keep_list = [count_i]
            new_list  = [count_i]
            
            # Carry ount a "gens" bond deep search
            for j in range(gens):

                # Id atoms in the next generation
                tmp_new_list = []                
                for k in new_list:
                    tmp_new_list += [ count_m for count_m,m in enumerate(adj_mat[k]) if m == 1 and count_m not in keep_list ]

                # Update lists
                tmp_new_list = list(set(tmp_new_list))
                if len(tmp_new_list) > 0:
                    keep_list += tmp_new_list
                new_list = tmp_new_list
            
            # Check for the minimal condition
            keep_list = set(keep_list)
            if False in [ elements[j] == "H" for j in range(len(elements)) if j not in keep_list ]:
                minimal_flag = False
            else:
                minimal_flag = True
        
    return minimal_flag



# Calculate the center of mass for the molecule
def calc_cm(elements,geo):

    # Dictionary of masses are needed to apply the CIP rules 
    Masses = {'H':1.00794,'He':4.002602,'Li':6.941,'Be':9.012182,'B':10.811,'C':12.011,'N':14.00674,'O':15.9994,'F':18.9984032,'Ne':20.1797,\
            'Na':22.989768,'Mg':24.3050,'Al':26.981539,'Si':28.0855,'P':30.973762,'S':32.066,'Cl':35.4527,'Ar':39.948,'Ge':72.61,'As':74.92159,\
             'Se':78.96,'Br':79.904,'I':126.90447}
    if set(elements).issubset(list(Masses.keys())) == False:
        print("ERROR in calc_cm: Encountered an element that wasn't in the masses dictionary while trying to calculate the center of mass. Exiting...")
        quit()
    else:
        masses = np.array([ Masses[i] for i in elements ])
        cm = np.sum(masses[:,None] * geo,axis=0)/np.sum(masses)
    return cm

# input   geo        : Nx3 array
#         charges    : Nx1 array
# returns dipole     : 1x3 array
#         dipole mag : scalar
def calc_dipole(geo,charges,r_0=None,debye=False):

    # If an origin is supplied, then perform a consistency check and center the geometry about it.
    if r_0 is not None:
        
        # Consistency check
        if len(r_0) != 3:
            print("ERROR in calc_quadrupole: r_0 must be a 3 element array. Exiting...")
            quit()

        # Center the geometry about the supplied origin
        geo = geo - r_0

    # Center about the centroid by default
    else:
        centroid = np.mean(geo,axis=0)
        geo = geo - centroid

    # Return the dipole moment and magnitude
    dipole =  np.sum(geo*charges[:,None],axis=0)
    if debye:
       dipole = dipole/0.393430307
    return dipole,norm(dipole)

# Description: a function for calculating the quadrupole moment of distribution of point charges
# NOTE: returns units of charge * geo_units**2, if geo is in units of bohr and the charges are partial charges then the quadrupole is in A.U. 
# NOTE: if an origin, r_0, is unsupplied then the function defaults to using the centroid of the geometry. 
#
# input  geo:       Nx3 array
#        charges:   Nx1 array
#        r_0:       1x3 array (origin for calculating the quadrupole)
# returns dipole:   1x3 array
def calc_quadrupole(geo,charges,r_0=None,traceless=True):

    # Check that the traceless option is of the proper type
    if traceless not in [True,False]:
        print("ERROR in calc_quadrupole: traceless option must be a boolean. Exiting...")
        quit()

    # If an origin is supplied, then perform a consistency check and center the geometry about it.
    if r_0 is not None:
        
        # Consistency check
        if len(r_0) != 3:
            print("ERROR in calc_quadrupole: r_0 must be a 3 element array. Exiting...")
            quit()

        # Center the geometry about the supplied origin
        geo = geo - r_0

    # Center about the centroid by default
    else:
        centroid = np.mean(geo,axis=0)
        geo = geo - centroid

    Q = np.zeros([3,3])

    # The traceless quadrupole subtracts off the squared norm of each charge position from the diagonal elements.
    # This guarranteees that the trace sums to zero and has the best agreement with the actual electrical potential.
    if traceless == True:        
        geo_norms = norm(geo,axis=1)**(2.0)
        for i in range(3):
            for j in range(3):
                if i == j:
                    Q[i,j] = np.sum((3.0*geo[:,i]*geo[:,j]-geo_norms)*charges)
                else:
                    Q[i,j] = np.sum(charges*(3.0*geo[:,i]*geo[:,j]))

    # The primitive quadrupole is simply the sum of the squared position components weighted by the charges.
    # This definition is the more obvious mathematical expansion. 
    else:
        for i in range(3):
            for j in range(3):
                Q[i,j] = np.sum(charges*(geo[:,i]*geo[:,j]))
    return Q

# Function for calculating the potential on each grid point using the supplied configuration of charges.
def Calc_Pot(seps,charges_0):
    return np.dot(seps,charges_0.T)


def natural_sort(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ] 
    return sorted(l, key = alphanum_key)

# A function for extracting the dipole and quadrupole from orca files. 
# in A.U
# 1 debye = 0.393430307 A.U
def parse_orca_out(output_file,debye=False):

    # Initialize the dipole and quadrupole to None 
    dipole_0 = None
    quadrupole_0 = None
    complete_flag = 0

    # open file and parse dipole/quadrupole if available
    with open(output_file,'r') as f:
        quad_flag = 0
        for lines in f:
            fields = lines.split()
            
            # dipole parsing commands
            if len(fields) == 7 and fields[0] == "Total" and fields[1] == "Dipole" and fields[2] == "Moment":
                dipole_0 = np.array([ float(i) for i in fields[4:7] ])
                if debye:
                  dipole_0 = dipole_0/0.393430307

            # quadrupole parsing commands
            if quad_flag == 6:
                quadrupole_0      = np.zeros([3,3])
                quadrupole_0[0,:] = [float(fields[1]),float(fields[4]),float(fields[5])]
                quadrupole_0[1,:] = [float(fields[4]),float(fields[2]),float(fields[6])]
                quadrupole_0[2,:] = [float(fields[5]),float(fields[6]),float(fields[3])]
                quad_flag = 0
            elif quad_flag > 0:
                quad_flag += 1
            elif len(fields) == 3 and fields[0] == "QUADRUPOLE" and fields[1] == "MOMENT" and fields[2] == "(A.U.)":
                quad_flag = 1
            
            # check for job completion
            if "****ORCA TERMINATED NORMALLY****" in lines:
                complete_flag = 1

    # Print a warning if the output file is incomplete
    if complete_flag == 0:
        print(("WARNING in parse_orca_out: The file {} is incomplete.".format(output_file)))
            
    return dipole_0,quadrupole_0


# Description: A simple wrapper for the file writing commands for the vdw parameters.
#              The function takes arguments for the filename, fit type (e.g. lj), and
#              united-atom (UA) vs all-atom (AA) style.
def write_params(name,charge_dict):

    # Save charges
    with open(name,'w') as f:

        f.write("\n# Charge definitions\n#\n{:10s} {:41s} {:20s}\n".format("#","Atom_type","Charge"))
        for i in natural_sort(list(charge_dict.keys())):
            if '-UA' not in i:
                f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",str(i),np.mean(charge_dict[i])))
        for i in natural_sort(list(charge_dict.keys())):
            if '-UA' in i:
                f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",str(i),np.mean(charge_dict[i])))

# Wrapper script for the molecule.db writing commands
def write_molecule_db(folder,elements,geo,charges,types):

    # Write examples of each molecule in the sim to a molecule.db file. This is used when
    # adding the intramolecular parameters to the master database. Each parameter in the master is linked
    # to the molecule(s) used to generate it. In the case of intramolecular params, the globally optimized
    # geometry is saved to the db.
    with open(folder+'/molecules.db','w') as f:
        f.write("\nmol {:6d} start\n".format(1))
        # Save an xyz for viewing the configuration in VMD
        f.write('{}\n\n'.format(len(geo)))
        for count_i,i in enumerate(geo):
            f.write('  {:<10s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 12.6f} {:<60s}\n'.\
            format(elements[count_i],i[0],i[1],i[2],charges[count_i],types[count_i]))
        f.write("mol {:6d} end\n".format(1))

    return

# Create logger to save stdout to logfile
class Logger(object):

    def __init__(self,folder):
        self.terminal = sys.stdout
        self.log = open(folder+"/fit_charges.log", "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)  
    def flush(self):
        pass

if __name__ == "__main__":
   main(sys.argv[1:])
