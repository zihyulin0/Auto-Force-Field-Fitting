#!/bin/env python
# Author: Brett Savoie (brettsavoie@gmail.com)

import sys,argparse,os,re,fnmatch
from scipy.optimize import leastsq
from scipy.optimize import minimize
import scipy.optimize
from scipy.spatial.distance import cdist
import numpy as np #from numpy import *
from numpy.linalg import norm
from copy import deepcopy
import time
from itertools import combinations

# Add TAFFY Lib to path
sys.path.append('/'.join(os.path.abspath(__file__).split('/')[:-2])+'/Lib')
from transify import *
from adjacency import *
from file_parsers import *
from id_types import *
from kekule import *
import random
from matplotlib.pyplot import savefig
from matplotlib.pyplot import close

def main(argv):

    parser = argparse.ArgumentParser(description='This program generates CHELPG or RESP charges from potential grids generated by orca.')

    #optional arguments                                                                                                                                                        
    parser.add_argument('filename', help = 'file holding the electric potential')

    parser.add_argument('-xyz', dest='xyz_file', default=None,
                        help = 'The geometry of the nuclear centers can be supplied in the form of an xyz file (a typical output of orca) with coordinates in angstroms. If the '\
                               '*.xyz file is not supplied, then the element labels for the nuclear centers must be supplied to geometry block of the *.vpot file. (default: None)')

    parser.add_argument('-d', dest='path', default=None,
                        help = 'When filename is a folder, the program operates on all files with the extension *.vpot discovered during a directory walk. Optionally, if this argument is supplied then only *.vpot files '+\
                               'whose path includes the -d argument will be operated on. (default: None)')

    parser.add_argument('-out', dest='out_file', default=None,
                        help = 'For fitting the dipole and/or quadrupole moment, the output file holding these quantities must be supplied (default: None)')

    parser.add_argument('-o', dest='output_folder', default='charge_parse',
                        help = 'All outputs from the averaging are saved to a subfolder of the working directory (determined by the -f argument). '+\
                               'This option determines the folder name. (default: charge_parse)') 

    parser.add_argument('-q', dest='qtot', default=0.0,
                        help = 'Total charge constraint on the molecule (default: 0.0)')

    parser.add_argument('-gens', dest='gens', default=2,
                        help = 'Number of generations for defining atom type uniqueness. (default: 2)')

    parser.add_argument('-seed', dest='seed', default=444,
                        help = 'The seed for the random number generator. (default: 444)')

    parser.add_argument('-w_pot', dest='w_pot', default=1.0,
                        help = 'The relative weight in the penalty function for deviations from the electric potential. (default: 1.0)')

    parser.add_argument('-w_qtot', dest='w_qtot', default=1.0,
                        help = 'The relative weight in the penalty function for deviations from the total charge on the molecule. (default: 1.0)')

    parser.add_argument('-w_hyper', dest='w_hyper', default=0.0,
                        help = 'The weight of the hyperbolic penalty term in the fit function. (default: 0.0)')

    parser.add_argument('-b_hyper', dest='b_hyper', default=0.1,
                        help = 'The hyperbolic stiffness parameter in the fit function. (default: 0.1; RESP default)')

    parser.add_argument('-w_dipole', dest='w_dipole', default=0.1,
                        help = 'The relative weight in the penalty function for deviations from the dipole moment. (default: 0.1 or 0 if no output is supplied from which the dipole can be read)')

    parser.add_argument('-w_quad', dest='w_quadrupole', default=0.0,
                        help = 'The relative weight in the penalty function for deviations from the quadrupole moment. (default: 0)')

    parser.add_argument('-FF', dest='FF_db', default="",
                        help = 'A space-delimited string containing taffi force field database(s). Any partial charges contained in the supplied database(s) are held fixed during the fitting procedure. (default: none)')

    parser.add_argument('-N', dest='N_configs', default=None,
                        help = 'Expects an integer. When supplied, only this number of configurations will be used for the fit (default: None)') 

    parser.add_argument('--symmetrize', dest='symmetrize', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, the partial charges on identical atom types are constrained to be equal during the fitting. (default: off)')

    parser.add_argument('--UA', dest='UA_opt', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied all hydrogens attached to carbon are removed from the fitting procedure. (default: off)')

    parser.add_argument('--keep_min', dest='keep_min', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, partial charges are only written for atomtypes that the xyz corresponds to their minimum fragment. (default: off)')

    parser.add_argument('--debye', dest='debye', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, output unit is in Debye. (default: A.U)')

    parser.add_argument('--two_step', dest='two_step', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, the charges are fitted in two steps. In the first step, symmetry is forced on like atomtypes for atoms that are not carbon or a hydrogen attached to carbon. This provides '+\
                               'the highest accuracy when describing the polar atoms in the system. In the second step, the partial charges that were symmetrized in the first step are held fixed and the rest of the atoms are fit '+\
                               'with symmetry constraints. (default: off)')

    # Parse the inputs
    args=parser.parse_args(argv)
    args.qtot = float(args.qtot)
    args.w_pot = float(args.w_pot)
    args.w_qtot = float(args.w_qtot)
    args.w_hyper = float(args.w_hyper)
    args.b_hyper = float(args.b_hyper)
    args.w_dipole = float(args.w_dipole)
    args.w_quadrupole = float(args.w_quadrupole)
    args.output_folder = str(args.output_folder)
    args.FF_db = args.FF_db.split()
    args.gens = int(args.gens)
    if args.N_configs is not None: args.N_configs = int(args.N_configs); 
    if args.N_configs is not None and args.N_configs < 0: print("ERROR: -N option must be an integer greater than 0. Exiting..."); quit()

    # Use a fixed seed value to ensure reproducibility between runs
    random.seed(int(args.seed))

    # Check if the folder protocol or file protocol is being used
    # the former performs a recursive search for *.vpot files and 
    if os.path.isdir(args.filename) == True:
        folder_protocol = True
        args.output_folder = args.filename + '/' + args.output_folder
    else:
        folder_protocol = False

    # If supplied, check that the FF files exist
    fixed_dict={}
    if args.FF_db != []:
        for i in args.FF_db:
            if os.path.isfile(i) is False:
                print(("ERROR: the file {} supplied to -FF does not exist. Exiting...".format(i)))
                quit()
            else:
                with open(i,'r') as f:
                    for lines in f:
                        fields = lines.split()
                        if len(fields) >= 2 and fields[0] == "charge":
                            fixed_dict[fields[1]] = float(fields[2])

    # Check that the output folder doesn't already exist.
    if os.path.isdir(args.output_folder) == True:
        print(("ERROR in exrtact_charges: Requested output folder ({}) already exists. Exiting to avoid overwriting data...".format(args.output_folder)))
        quit()
    else:
        os.makedirs(args.output_folder)
        os.makedirs(args.output_folder+'/figures')
        sys.stdout = Logger(args.output_folder)
        print(("PROGRAM CALL: python extract_charges.py {}\n".format(' '.join([ i for i in argv]))))

    # Print header
    print(("\n{}".format("*"*140)))
    print(("* {:^136s} *".format("Parsing Partial Charges in {}".format(args.filename))))
    print(("{}".format("*"*140)))

    #################################
    # file based consistency checks #
    #################################
    if folder_protocol == False:

        # Initialize lists. These are overkill for the single file but they conform to the directory-based protocol for parsing many files at once.
        potfiles = [args.filename]
        outputs  = [args.out_file]
        xyzs     = [args.xyz_file]
        paths    = ['.']

        #  Parse the dipole/quadupole if an output file is supplied
        if args.out_file is not None:
            if os.path.isfile(args.out_file) == False:
                print(("ERROR in extract_charges: the supplied output file for reading dipole/quadrupole data ({}) does not exist. Exiting...".format(args.out_file)))
                quit()
            else:
                outputs = [args.out_file]
                dipole_0,quadrupole_0 = parse_orca_out(args.out_file)
        else:
            dipole_0 = None
            quadrupole_0 = None

        # Check for required files and print warnings for inconsistent parameter specifications
        if os.path.isfile(args.filename) == False:
            print(("ERROR in extract_charges: could not open file {}. Exiting...".format(args.filename)))
        if args.xyz_file is not None and os.path.isfile(args.xyz_file) == False:
            print(("ERROR in extract_charges: the supplied xyz filename ({}), could not be found. Exiting...".format(args.xyz_file)))
        if ( args.out_file is None or dipole_0 is None ) and args.w_dipole != 0.0:
            print("WARNING in extract_charges: An output file for reading the dipole moment was not supplied but the dipole weight is set to a non-zero value.")
            print("                            fit_charges will set the dipole weight to zero and continue with the fit.")
            args.w_dipole = 0
        if ( args.out_file is None or quadrupole_0 is None ) and args.w_quadrupole != 0.0:
            print("WARNING in extract_charges: An output file for reading the quadrupole moment was not supplied but the quadrupole weight is set to a non-zero value.")
            print("                            fit_charges will set the quadrupole weight to zero and continue with the fit.")
            args.w_quadrupole = 0

    ###################################
    # folder based consistency checks #
    ###################################
    elif folder_protocol == True:

        # Create a dictionary from the filenames, where each dictionary key corresponds to a filename and each entry is a list
        # of subfiles to be processed as a batch. e.g., molecule.in might show up in twenty subfolders. molecule.in would end
        # up as a key, and the list of individual instances of molecule.in would constitute the entry.
        Files = {}
        if args.path is None:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(args.filename+'/.') for f in filenames if fnmatch.fnmatch(f,"*.vpot") ]
        else:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(args.filename+'/.') for f in filenames if (fnmatch.fnmatch(f,"*.vpot") and args.path in dp)  ]

        # Assemble paths, xyz files, and output files
        paths    = [ "/".join(i.split('/')[:-1]) for i in potfiles ]
        xyzs     = []
        outputs  = []
        for count_i,i in enumerate(paths):
            tmp_out = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.out") ]
            tmp_xyz = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.xyz") ]

            # Populate in a one-to-one path to *.out and *.xyz fashion. Place None in the list if no matching file was found. If multiple matches are found then place the first file in the list.
            if len(tmp_out) > 0:
                outputs += [tmp_out[0]]
            else:
                outputs += [None]
            if len(tmp_xyz) > 0: 
                xyzs    += [tmp_xyz[0]]
            else:
                xyzs    += [None]
                    
        # Check for required files and print warnings for inconsistent parameter specifications
        if None in outputs and args.w_dipole != 0.0:
            print("WARNING in extract_charges: Output files for reading the dipole moment could not be found for all discovered *.vpot files and the dipole weight is set to a non-zero value.")
            print("                            fit_charges will set the dipole weight to zero and continue with the fit.")
            args.w_dipole = 0
        if None in outputs and args.w_quadrupole != 0.0:
            print("WARNING in extract_charges: Output files for reading the quadrupole moment could not be found for all discovered *.vpot files and the quadrupole weight is set to a non-zero value.")
            print("                            fit_charges will set the quadrupole weight to zero and continue with the fit.")
            args.w_quadrupole = 0

        # Only use up to N_configs if the argument was supplied by the user
        if args.N_configs is not None and args.N_configs < len(outputs):
            keep_ind = list(range(len(outputs)))
            random.shuffle(keep_ind)
            keep_ind = keep_ind[:args.N_configs]
            potfiles = [ potfiles[i] for i in keep_ind ]
            outputs  = [ outputs[i] for i in keep_ind ]
            xyzs     = [ xyzs[i] for i in keep_ind ]

    # Print diagnostic
    print(("Number of Configurations Being Parsed: {}\n".format(len(potfiles))))    

    ################
    # All-Atom Fit # 
    ################

    for z in [ 'AA' ]:

        # Initialize arrays
        lstsq_D_errs = []
        lstsq_errs   = []
        lstsq_qtot   = []
        fit_D_errs   = []
        fit_errs     = []
        fit_qtot     = []
        avoid_list   = []

        if z == "AA":
            lstsq_dict   = {}
            fit_dict     = {}

        # Iterate over the files being fit
        seps_all = {}
        seps_all_noC = {}
        potential_all = {}
        all_geo_all = {}
        for count_f,f in enumerate(potfiles):
            
            # Parse dipole and quadrupole
            # Parse the geometry, grid locations, and potential from the orca *.vpot file
            # NOTE: the geo is returned in bohr
            elements,geo,grid,potential,all_geo,charges_0,atype_lammps = parse_vpot(f,xyzs[count_f])
   
            

            # Generate the adjacency matrix
            # NOTE: the units are converted back angstroms
            adj_mat = Table_generator(elements,geo*0.52917721067,File=xyzs[count_f])

            # Generate the atomtypes
            atomtypes = id_types(elements,adj_mat,args.gens,Hybridization_finder(elements,adj_mat),geo*0.52917721067)

            # Calculate the center of mass
            cm = calc_cm(elements,geo)    

            # Parse dipole/quadrupole
            # unit: A.U
            if outputs[count_f] is not None:
                dipole_0,quadrupole_0 = parse_orca_out(outputs[count_f])
            else:
                w_dipole = 0.0
                w_quadrupole = 0.0
                dipole_0 = np.array([0.0,0.0,0.0])
                quadrupole_0 = np.array([0.0,0.0,0.0])

            # If no dipole or quadrupole are found then zero out the weight of that component and continue
            if dipole_0 is None:
                w_dipole = 0.0
                dipole_0 = np.array([0.0,0.0,0.0])
            if quadrupole_0 is None:
                w_quadrupole = 0.0
                quadrupole_0 = np.array([0.0,0.0,0.0])

            # Calculate the inverse displacements of each grid point from the charge centers being fit. 
            #seps = 1.0/cdist(grid,geo)
            seps = 1.0/cdist(grid,all_geo)
            seps_noC = 1.0/cdist(grid,all_geo[:-1])
            seps_all[count_f] = seps
            seps_all_noC[count_f] = seps_noC
            potential_all[count_f] = potential
            all_geo_all[count_f] = all_geo

            # Calculate lstsq fit with qtot charge constraint as a reference
            #lstsq_charges = lstsq_potfit(all_geo,grid,args.qtot,seps,potential)

            # Initialize initial guess (charges) and a list of holding the index in charges that each atomic charges corresponds to
            # In the case of no symmetry constraints, charge_mapping simply maps one-to-one to the charges list. When there are symmetry 
            # constraints the charge_mapping elements of like atomtypes will commonly reference some common index in charges array. 
            # NOTE: initial guess is made to satisfy q_tot but distributing the necessary amount to the atoms being fit
            # NOTE: fix_ind and the initial guess are populated with charges from the supplied FF files  
            charge_mapping = list(range(len(geo)))
            #fix_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i in list(fixed_dict.keys()) ]
            # Right now we fit every atoms, this should be modified in the future
            fix_ind = []
            # atom_types have each atoms' type so duplicated ones included
            #fit_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i not in list(fixed_dict.keys()) ]
            # fit everythin except for point charge
            fit_ind = list(range(len(all_geo)-1))
            #charges_0      = np.array([ 0.0 if count_i in fit_ind else fixed_dict[atomtypes[count_i]] for count_i,i in enumerate(atomtypes) ])
            #if len(fit_ind) == 0:
            #    offset = 0.0
            #else:
            #    offset         = (args.qtot-np.sum(charges_0))/float(len(fit_ind))
            #for i in fit_ind: charges_0[i] = offset

         ###################
         # Fit the charges #
         ###################

         # two-step algorithm: first fits the polar atoms with symmetry constraints, then holds the polar atoms fixed and fits the non-polar atoms with symmetry constraints.
        if args.two_step == True:

             # Find non-carbon atoms and hydrogens that aren't attached to carbon
             polar_ind = [ count_i for count_i,i in enumerate(adj_mat) if \
                           ( elements[count_i] != 'C' and elements[count_i] != "H" ) or ( elements[count_i] == "H" and np.sum([ 1 for count_j,j in enumerate(adj_mat[count_i]) if ( j == 1 and elements[count_j] == "C" ) ]) == 0 ) ]

             # Find non-carbon atoms and hydrogens that aren't attached to carbon
             nonpolar_ind = [ i for i in range(len(geo)) if i not in polar_ind ]

             # Remove fixed atoms from fit consideration
             polar_ind    = [ i for i in polar_ind if i not in fix_ind ]
             nonpolar_ind = [ i for i in nonpolar_ind if i not in fix_ind ]


             # polar_ind and nonpolar_ind are unaffected by addition of drude particles


             # During the first step (i) no charges are fixed and (ii) symmetry is only forced on the polar atoms.
             # The polar atomtypes are looped over (outer loop), the indices of all like atomtypes are found (idx), all charge_mapping elements at indices idx are set to point at the first instance of that atom type.
             #charge_mapping = list(range(len(geo)))
             charge_mapping = list(range(len(all_geo)))
             for i in set([ atomtypes[j] for j in polar_ind ]):
                 idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                 for j in idx: charge_mapping[j] = idx[0]


             # Fit the polar atoms                    imposes_symmetry fits_all
             #fit_charges = flex_fit(geo,potential_all,seps_all,charge_mapping,fit_ind,\
             #                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)
             fit_charges = flex_fit(geo,potential_all,seps_all_noC,charge_mapping,fit_ind,\
                                    args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)

             # During the second step (i) the charges on the polar_ind atoms are fixed and (ii) symmetry is forced on the non_polar atoms.
             for i in set([ atomtypes[j] for j in nonpolar_ind ]):
                 idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                 for j in idx: charge_mapping[j] = idx[0]


             # Check to ensure that there is something to fit in this second step
             if len(nonpolar_ind) > 0:

                 # Fit the non-polar atoms                imposes_symmetry fits_only_nonpolar
                 #fit_charges = flex_fit(geo,potential_all,seps_all,charge_mapping,nonpolar_ind,\
                 #                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=fit_charges,traceless_opt=False)
                 fit_charges = flex_fit(geo,potential_all,seps_all_noC,charge_mapping,nonpolar_ind,\
                                        args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=fit_charges,traceless_opt=False)
             
         # symmetrize algorithm: fits all atoms at once with symmetry constraints.
        elif args.symmetrize == True:

             # The atomtypes are looped over (outer loop), the indices of all like atomtypes are found (idx), all charge_mapping elements at indices idx are set to point at the first instance of that atom type.
             charge_mapping = list(range(len(all_geo)))
             for i in set(atomtypes):
                 idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                 for j in idx: charge_mapping[j] = idx[0]

             # Fit the charges                        imposes_symmetry  fits_all_atoms
             #fit_charges = flex_fit(geo,potential_all,seps_all,charge_mapping,fit_ind,\
             #                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)
             fit_charges = flex_fit(geo,potential_all,seps_all_noC,charge_mapping,fit_ind,\
                                    args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)

         # default: perform the fit to all atoms at once without symmetry constraints
        else:

             # Fit the charges
             #fit_charges = flex_fit(geo,potential_all,seps_all,list(range(len(geo))),fit_ind,\
             #                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)
             fit_charges = flex_fit(geo,potential_all,seps_all_noC,list(range(len(geo))),fit_ind,\
                                    args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)
        print("fitted charges\n")
        print(fit_charges)
        print("initial guess\n")
        print(charges_0)
        print(elements)
        write_drudedata(all_geo*0.52917721067,fit_charges,atype_lammps)
        fit_errs_0 = []
        for count_i,i in enumerate(potential_all):
            #fit_errs +=  [np.mean((Calc_Pot(seps_all[count_i],fit_charges)-potential_all[i])**(2.0))]
            #fit_errs_0 += [np.mean((Calc_Pot(seps_all[count_i],charges_0)-potential_all[i])**(2.0))]
            fit_errs +=  [np.mean((Calc_Pot(seps_all_noC[count_i],fit_charges[:-1])-potential_all[i])**(2.0))]
            fit_errs_0 += [np.mean((Calc_Pot(seps_all_noC[count_i],charges_0[:-1])-potential_all[i])**(2.0))]
            
        xhi2 = np.mean(fit_errs)
        xhi2_0 = np.mean(fit_errs_0)
        with open('xhi2.txt','a') as f:
            f.write("initial xhi2 {}\n".format(xhi2_0))
            f.write("final xhi2 {}\n".format(xhi2))
        
        dipole = calc_dipole(all_geo[:-1],fit_charges[:-1])[1]
        dipole_initial = calc_dipole(all_geo[:-1],charges_0[:-1])[1]
        # for ethanol 
        tmp = charges_0[:-4]
        tmp[0] += charges_0[-4]
        tmp[1] += charges_0[-3]
        tmp[2] += charges_0[-2]
        # for methanol 
        #tmp = charges_0[:-3]
        #tmp[0] += charges_0[-3]
        #tmp[1] += charges_0[-2]
        # not polarize dipole
        dipole_NP = calc_dipole(geo,tmp)[1]
        if(args.debye):
           print("initial dipole: {} (Debye)\n".format(dipole_initial/0.393430307))
           print("final fitted dipole: {} (Debye)\n".format(dipole/0.393430307))
           print("initial Non-polarize dipole: {} (Debye)\n".format(dipole_NP/0.393430307))
        else:
           print("initial dipole: {} (A.U)\n".format(dipole_initial))
           print("final fitted dipole: {} (A.U)\n".format(dipole))
           print("initial Non-polarize dipole: {} (A.U)\n".format(dipole_NP))
        #plot_convergence(args.output_folder,potential_all,seps_all,charges_0) 
        plot_convergence(args.output_folder,potential_all,seps_all_noC,fit_charges[:-1]) 

        

         # Update the charges in the dictionaries
        for i in set(atomtypes):

             # When keep_min option is enabled, the program avoids saving any charges for whom this geometry is not a minimal structure
             if args.keep_min is True and minimal_structure(i,geo,elements,adj_mat=adj_mat,atomtypes=atomtypes) is False :                    
                 avoid_list += [i]
                 continue

             #if i not in lstsq_dict:
             #    lstsq_dict[i] = []
             if i not in fit_dict:
                 fit_dict[i] = []
             for count_j,j in enumerate(atomtypes):
                 if i == j:
            #         lstsq_dict[i] += [lstsq_charges[count_j]]
                     fit_dict[i] += [fit_charges[count_j]]

        # Update error dictionaries
        #lstsq_errs += [np.mean((Calc_Pot(seps,lstsq_charges)-potential)**(2.0))]
        #fit_errs += [np.mean((Calc_Pot(seps,fit_charges)-potential)**(2.0))]
        #if dipole_0 is not None:
        #    lstsq_D_errs += [ (norm(dipole_0) - calc_dipole(geo,lstsq_charges)[1])**(2.0) ]
        #    fit_D_errs += [ (norm(dipole_0) - calc_dipole(geo,fit_charges)[1])**(2.0) ]

        # Update qtot lists           
        #lstsq_qtot += [np.sum(lstsq_charges)] 
        #fit_qtot += [np.sum(fit_charges)]

        # Print Charge summary
        #print(("{}".format("*"*140)))
        #print(("* {:^136s} *".format("Final {}-Charges".format(z))))
        #print(("*{:^138s}*".format("-"*138)))
        #print(("* {:<60s}         {:<30s}        {:<19s} {:<10s}*".format("Atomtype","CHELPG","Fit","Status")))
        #print(("{}".format("*"*140)))
        #for i in lstsq_dict:
        #    if z == "UA" and "-UA" not in i: continue
        #    if i in list(fixed_dict.keys()): origin="fixed"
        #    else: origin="fit"
        #    print(("  {:<60s} {:35s} {:30s} {}".format(i,"{:< 8.6f} +/- {:<12.6f}".format(np.mean(lstsq_dict[i]),np.std(lstsq_dict[i])),"{:< 8.6f} +/- {:<12.6f}".format(np.mean(fit_dict[i]),np.std(fit_dict[i])),origin)))

        # Print error summary
        #print(("\n  {:<60s} {:< 35.6g} {:< 35.6g} ".format("<xhi_pot^2> (A.U.^2):",np.mean(lstsq_errs),np.mean(fit_errs))))
        #if len(lstsq_D_errs) > 0:
        #    print(("  {:<60s} {:< 35.6g} {:< 35.6g} ".format("<xhi_D^2> (A.U.^2):",np.mean(lstsq_D_errs),np.mean(fit_D_errs))))
        #print(("  {:<60s} {:< 35.6f} {:< 35.6f} \n".format("total charge (A.U.):",np.mean(lstsq_qtot),np.mean(fit_qtot))))    

        # Print summary of charges not saved due to the --keep_min option
        if len(avoid_list) > 0:
            avoid_list = set(avoid_list)
            print(("{}".format("*"*140)))
            print(("* {:^136s} *".format("Atomtypes that weren't Saved Because this isn't a Minimal Geometry")))
            print(("{}".format("*"*140)))
            print("\nList of atomtypes that weren't saved:\n")
            for i in sorted(avoid_list):
                print(("\t{}".format(i)))
            print(" ")

    # Write the charge database file(s)
    #write_params(args.output_folder+'/chelpg.db',lstsq_dict)
    write_params(args.output_folder+'/fit_charges.db',fit_dict)

    # Write molecule.db file. This is used for integrating parameters into master database files
    # so that parameters can be linked with the model molecule used to parametrize them.
    write_molecule_db(args.output_folder,elements,geo,[ np.mean(fit_dict[i]) if i in fit_dict else 0.0 for i in atomtypes ],atomtypes)

    # Print farewell
    print(("{}".format("*"*140)))
    print(("*{:^138s}*".format("Charge Parse Complete!")))
    print(("{}\n".format("*"*140)))

    return
def write_drudedata(geo,charges,atype_lammps):
   with open('drude/drude.tmp','w') as f:
   #print("Atoms \n")
      f.write("\n")
      for count_i,i in enumerate(charges[:-1]):
         f.write("{0}  0 {1} {2:20.17e} {3:20.17e} {4:20.17e} {5:20.17e} 0 0 0 \n".format(count_i+1,atype_lammps[count_i],i,geo[count_i][0],geo[count_i][1],geo[count_i][2])) 
   with open('fit_charges.txt','a') as f:
      f.write("{}\n".format(charges))
      

# Description:   Checks is the supplied geometry corresponds to the minimal structure of the molecule
# 
# Inputs:        atomtype:      The taffi atomtype being checked
#                geo:           Geometry of the molecule
#                elements:      elements, indexed to the geometry 
#                adj_mat:       adj_mat, indexed to the geometry (optional)
#                atomtypes:     atomtypes, indexed to the geometry (optional)
#                gens:          number of generations for determining atomtypes (optional, only used if atomtypes are not supplied)
# 
# Outputs:       Boolean:       True if geo is the minimal structure for the atomtype, False if not.
def minimal_structure(atomtype,geo,elements,adj_mat=None,atomtypes=None,gens=2):

    # If required find the atomtypes for the geometry
    if atomtypes is None or adj_mat is None:
        if len(elements) != len(geo):
            print("ERROR in minimal_structure: While trying to automatically assign atomtypes, the elements argument must have dimensions equal to geo. Exiting...")
            quit()

        # Generate the adjacency matrix
        # NOTE: the units are converted back angstroms
        adj_mat = Table_generator(elements,geo)

        # Generate the atomtypes
        atomtypes = id_types(elements,adj_mat,gens,Hybridization_finder(elements,adj_mat),geo)
        
    # Check minimal conditions
    count = 0
    for count_i,i in enumerate(atomtypes):

        # If the current atomtype matches the atomtype being searched for then proceed with minimal geo check
        if i == atomtype:
            count += 1

            # Initialize lists for holding indices in the structure within "gens" bonds of the seed atom (count_i)
            keep_list = [count_i]
            new_list  = [count_i]
            
            # Carry ount a "gens" bond deep search
            for j in range(gens):

                # Id atoms in the next generation
                tmp_new_list = []                
                for k in new_list:
                    tmp_new_list += [ count_m for count_m,m in enumerate(adj_mat[k]) if m == 1 and count_m not in keep_list ]

                # Update lists
                tmp_new_list = list(set(tmp_new_list))
                if len(tmp_new_list) > 0:
                    keep_list += tmp_new_list
                new_list = tmp_new_list
            
            # Check for the minimal condition
            keep_list = set(keep_list)
            if False in [ elements[j] == "H" for j in range(len(elements)) if j not in keep_list ]:
                minimal_flag = False
            else:
                minimal_flag = True
        
    return minimal_flag


# Least-squares fit to the potential with a constraint on the total charge
#
# geo:           position of nuclear centers (Nx3 numpy array)
# potential:     potential at grid points (indexed to seps) (Gx1 numpy array)
# seps:          matrix of separations with elements e_ij holding the separation between nuclear center i and grid point j (NxG numpy array)
# dipole_0:      the dipole moment used for fitting (1x3 numpy array)
# quadrupole_0:  the quadrupole moment used for fitting (3x3 numpy array)
# r_0:           the origin used for calculating the dipole and/or quadrupole (1x3 numpy array)
# w_pot:         the weighting value in the cost function for deviations from the potential
# w_hyper:       the weighting value in the cost function for the hyperbolic constraint
# b_hyper:       the hyperbolic stiffness used in the RESP-type term in the cost function
# w_dipole:      the weighting value in the cost function for deviations from the dipole moment.
# w_quadrupole:  the weighting value in the cost function for deviations from the quadrupole moment.
# charges_0:     the initial guess for the partial charge distribution
# traceless_opt: when calculating the quadrupole, this flag controls whether the calculation produces a traceless quadrupole.
def flex_fit(geo,potential,seps,charge_mapping=None,fit_indices=None,\
             qtot=0.0,dipole_0=None,quadrupole_0=None,r_0=None,w_pot=1.0,w_qtot=1.0,w_hyper=0.01,b_hyper=0.1,w_dipole=0.1,w_quadrupole=0.05,charges_0=None,traceless_opt=False):

    # Initialize global objects utilized during the fit
    if charges_0 is None:
        print("ERROR: drude fitting must have an initial guess")
        quit()
        charges = np.zeros(len(geo)) + qtot/float(len(geo))
    else:
        charges = deepcopy(charges_0)
    if charge_mapping is None:
        charge_mapping = list(range(len(charges)))
    if fit_indices is None:
        fit_indices = list(range(len(charges)))

    # Return charges if there is nothing to be fit
    if len(fit_indices) == 0:
        return charges

    # Create anonymous function for use in the fitting
    fit_func = lambda x: flex_fit_func(*x,potential=potential,seps=seps,geo=geo,charges=charges,charge_mapping=charge_mapping,charge_indices=fit_indices,qtot=qtot,dipole_0=dipole_0,quadrupole_0=quadrupole_0,r_0=r_0,\
                                          w_pot=w_pot,w_qtot=w_qtot,w_hyper=w_hyper,b_hyper=b_hyper,w_dipole=w_dipole,w_quadrupole=w_quadrupole,traceless_opt=traceless_opt,charges_0=charges_0)


    #print(len(charges))
    bounds = [ (-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,np.inf),(-np.inf,0),(-np.inf,0),(-np.inf,0)]


    # Fit the charges
    charges[fit_indices] = minimize(fit_func,charges[fit_indices],bounds=bounds,method='L-BFGS-B',tol=1E-12).x
    #charges[fit_indices] = minimize(fit_func,charges[fit_indices],method='L-BFGS-B',tol=1E-12).x
    #print(charges[fit_indices])

    # Generate final list of charges based on charge_mapping
    for count_i,i in enumerate(charge_mapping):
        charges[count_i] = charges[i]

    # Subtract off unwanted residual charge
    # charges -= (np.sum(charges) - qtot)/float(len(charges)) # OLD, new only subtracts from fit_ind
    charges[fit_indices] -= (np.sum(charges) - qtot)/float(len(fit_indices))
    return charges

# Compatible with minimize
# Following the original RESP paper, 0.1 is the recommended value for "b" (the hyperbolic stiffness) and 0.001 is the "stronger" value
# for the weighting coefficient (0.0005 is also suggested as a valid "weaker" option).
#
# charges: partial charges at the nuclear centers (indexed to seps)
# charge_indices: indexed to the supplied q_* variables holding the index in charges that each q_* value should be assigned to
# charge_mapping: indexed to charges, holds indices in charges that each index in charges corresponds to (sounds circular, but it works out for enforcing charge symmetry)
def flex_fit_func(q_0=None, q_1=None, q_2=None, q_3=None, q_4=None, q_5=None, q_6=None, q_7=None, q_8=None, q_9=None,q_10=None,\
                  q_11=None,q_12=None,q_13=None,q_14=None,q_15=None,q_16=None,q_17=None,q_18=None,q_19=None,q_20=None,\
                  q_21=None,q_22=None,q_23=None,q_24=None,q_25=None,q_26=None,q_27=None,q_28=None,q_29=None,q_30=None,\
                  q_31=None,q_32=None,q_33=None,q_34=None,q_35=None,q_36=None,q_37=None,q_38=None,q_39=None,q_40=None,\
                  q_41=None,q_42=None,q_43=None,q_44=None,q_45=None,q_46=None,q_47=None,q_48=None,q_49=None,q_50=None,\
                  q_51=None,q_52=None,q_53=None,q_54=None,q_55=None,q_56=None,q_57=None,q_58=None,q_59=None,q_60=None,\
                  q_61=None,q_62=None,q_63=None,q_64=None,q_65=None,q_66=None,q_67=None,q_68=None,q_69=None,q_70=None,\
                  q_71=None,q_72=None,q_73=None,q_74=None,q_75=None,q_76=None,q_77=None,q_78=None,q_79=None,q_80=None,\
                  q_81=None,q_82=None,q_83=None,q_84=None,q_85=None,q_86=None,q_87=None,q_88=None,q_89=None,q_90=None,\
                  q_91=None,q_92=None,q_93=None,q_94=None,q_95=None,q_96=None,q_97=None,q_98=None,q_99=None,q_100=None,\
                  potential=None,seps=None,geo=None,charges=None,charge_indices=None,charge_mapping=None,qtot=None,dipole_0=None,quadrupole_0=None,\
                  r_0=None,w_pot=0.0,w_qtot=0.0,w_hyper=0.0,b_hyper=0.0,w_dipole=0.0,w_quadrupole=0.0,traceless_opt=False,charges_0=None):

    # Initialize local variable dictionary (used for determining what has been defined)
    local_vars = locals()
    
    # Initialize a list of fit charges
    fit_charges = np.array([ local_vars[j] for j in natural_sort([ i for i in local_vars if 'q_' in i and local_vars[i] is not None ]) ])

    #########################################
    # Consistency checks on input arguments #
    #########################################

    # Check that charges is supplied during the function call
    if charges is None:
        print("ERROR in flex_fit_func: charges must be supplied during the function call. It only appears to be an optional argument for convenience when anonymizing the function.")
        quit()

    # If the charge_indices list is supplied then check that there is a consistent number of supplied charges and supplied indices
    if charge_indices is not None:
        if len(charge_indices) != len(fit_charges):
            print("ERROR in flex_fit_func: the number of supplied q_* variables should match the number of elements in charge_indices. Exiting...")
            quit()

    # Else, default behavior is to assume that all charges are being fit. If that isn't the case then print an error and exit.
    else:
        if len(charges) != len(fit_charges):
            print("ERROR in flex_fit_func: a charge_indices list must be supplied if the number of supplied q_* variables is less than the number of charged centers in the system. Exiting...")
            quit()

        # Initialize one-to-one (default) assigment of charge_indices
        else:
            charge_indices = list(range(len(charges)))

    # Check that the charge_mapping dimensions and charges dimensions match
    if charge_mapping is not None:
        if len(charges) != len(charge_mapping):
            print("ERROR in flex_fit_func: the dimensions of the charge_mapping and charges arrays must match. Exiting...")            
            quit()

    # Initialize one-to-one (default) assigment of charge_mapping
    else:
        charge_mapping = list(range(len(charges)))

    #####################################
    # Perform cost function calculation #
    #####################################

    # Assign the charges being fit to the supplied q_* values
    for count_i,i in enumerate(fit_charges):
        charges[charge_indices[count_i]] = i
    
    # Carry out the mapping procedure (* this is the mechanism for enforcing symmetry)
    for count_i,i in enumerate(charge_mapping):
        charges[count_i] = charges[i]

    penalty_charges = np.array([ i for counti,i in enumerate(charges) if i>charges_0[count_i]+0.1 or i <charges_0[count_i]-0.1 ]) 
    # Return cost function
    #return w_pot * np.mean(( potential - np.dot(seps,charges.T) )**(2.0)) + w_hyper * np.mean( (charges**(2.0) + b_hyper**(2.0) )**(0.5) - b_hyper ) + w_qtot*(np.sum(charges)-qtot)**(2.0) +\
    #       w_dipole*np.mean((calc_dipole(geo,charges,r_0=r_0)[0] - dipole_0)**(2.0)) + w_quadrupole*np.mean(((calc_quadrupole(geo,charges,r_0=r_0,traceless=traceless_opt) - quadrupole_0 )**(2.0)).flat)
    #xhi2 = 0
    #for key in potential:
    #  xhi2 += w_pot * np.mean(( potential[key] - np.dot(seps[key],charges.T) )**(2.0)) + w_hyper * np.mean( (penalty_charges**(2.0) + b_hyper**(2.0) )**(0.5) - b_hyper ) + w_qtot*(np.sum(charges)-qtot)**(2.0) 
    

    return np.sum(np.array([ w_pot * np.mean(( potential[key] - np.dot(seps[key],charges[:-1].T) )**(2.0)) + w_hyper * np.mean( (penalty_charges**(2.0) + b_hyper**(2.0) )**(0.5) - b_hyper ) + w_qtot*(np.sum(charges)-qtot)**(2.0) for key in potential]))
           

# Calculate the center of mass for the molecule
def calc_cm(elements,geo):

    # Dictionary of masses are needed to apply the CIP rules 
    Masses = {'H':1.00794,'He':4.002602,'Li':6.941,'Be':9.012182,'B':10.811,'C':12.011,'N':14.00674,'O':15.9994,'F':18.9984032,'Ne':20.1797,\
            'Na':22.989768,'Mg':24.3050,'Al':26.981539,'Si':28.0855,'P':30.973762,'S':32.066,'Cl':35.4527,'Ar':39.948,'Ge':72.61,'As':74.92159,\
             'Se':78.96,'Br':79.904,'I':126.90447}
    if set(elements).issubset(list(Masses.keys())) == False:
        print("ERROR in calc_cm: Encountered an element that wasn't in the masses dictionary while trying to calculate the center of mass. Exiting...")
        quit()
    else:
        masses = np.array([ Masses[i] for i in elements ])
        cm = np.sum(masses[:,None] * geo,axis=0)/np.sum(masses)
    return cm

# input   geo        : Nx3 array
#         charges    : Nx1 array
# returns dipole     : 1x3 array
#         dipole mag : scalar
def calc_dipole(geo,charges,r_0=None):

    # If an origin is supplied, then perform a consistency check and center the geometry about it.
    if r_0 is not None:
        
        # Consistency check
        if len(r_0) != 3:
            print("ERROR in calc_quadrupole: r_0 must be a 3 element array. Exiting...")
            quit()

        # Center the geometry about the supplied origin
        geo = geo - r_0

    # Center about the centroid by default
    else:
        centroid = np.mean(geo,axis=0)
        #print(centroid)
        geo = geo - centroid

    # Return the dipole moment and magnitude
    dipole =  np.sum(geo*charges[:,None],axis=0)
    return dipole,norm(dipole)

# Description: a function for calculating the quadrupole moment of distribution of point charges
# NOTE: returns units of charge * geo_units**2, if geo is in units of bohr and the charges are partial charges then the quadrupole is in A.U. 
# NOTE: if an origin, r_0, is unsupplied then the function defaults to using the centroid of the geometry. 
#
# input  geo:       Nx3 array
#        charges:   Nx1 array
#        r_0:       1x3 array (origin for calculating the quadrupole)
# returns dipole:   1x3 array
def calc_quadrupole(geo,charges,r_0=None,traceless=True):

    # Check that the traceless option is of the proper type
    if traceless not in [True,False]:
        print("ERROR in calc_quadrupole: traceless option must be a boolean. Exiting...")
        quit()

    # If an origin is supplied, then perform a consistency check and center the geometry about it.
    if r_0 is not None:
        
        # Consistency check
        if len(r_0) != 3:
            print("ERROR in calc_quadrupole: r_0 must be a 3 element array. Exiting...")
            quit()

        # Center the geometry about the supplied origin
        geo = geo - r_0

    # Center about the centroid by default
    else:
        centroid = np.mean(geo,axis=0)
        geo = geo - centroid

    Q = np.zeros([3,3])

    # The traceless quadrupole subtracts off the squared norm of each charge position from the diagonal elements.
    # This guarranteees that the trace sums to zero and has the best agreement with the actual electrical potential.
    if traceless == True:        
        geo_norms = norm(geo,axis=1)**(2.0)
        for i in range(3):
            for j in range(3):
                if i == j:
                    Q[i,j] = np.sum((3.0*geo[:,i]*geo[:,j]-geo_norms)*charges)
                else:
                    Q[i,j] = np.sum(charges*(3.0*geo[:,i]*geo[:,j]))

    # The primitive quadrupole is simply the sum of the squared position components weighted by the charges.
    # This definition is the more obvious mathematical expansion. 
    else:
        for i in range(3):
            for j in range(3):
                Q[i,j] = np.sum(charges*(geo[:,i]*geo[:,j]))
    return Q

# Function for calculating the potential on each grid point using the supplied configuration of charges.
def Calc_Pot(seps,charges_0):
    return np.dot(seps,charges_0.T)

# Read in the nuclear coordinates, electric  potential, and grid coordinates from the *.vpot file
def parse_vpot(filename,xyz_file=None):

    # Toggle the xyz flag 
    if xyz_file != None:
        xyz_flag = 1
    else:
        xyz_flag = 0

    # Loop over the lines in the file
    with open(filename,'r') as f:
        atom_count = 0
        pot_count = 0
        for lc,lines in enumerate(f):
            fields = lines.split()

            # Initialize lists/arrays
            if lc == 0: 
                n_atom    = int(fields[0])
                n_grid    = int(fields[1])
                elements  = ["X"]*n_atom
                geo       = np.zeros([n_atom,3])
                grid      = np.zeros([n_grid,3])
                potential = np.zeros([n_grid])
                flag = 1
                continue

            # Parse the grid and potential
            if flag == 2:
                grid[pot_count] = np.array([ float(i) for i in fields[1:4] ])
                potential[pot_count] = float(fields[0])
                pot_count += 1
                if pot_count == n_grid:
                    break

            # Parse the molecule
            if flag == 1:
                if len(fields) == 0: continue
                # The parse is avoided if the xyz_flag is 1
                if xyz_flag == 0:
                    elements[atom_count] = fields[0]
                    geo[atom_count]      = np.array([ float(i) for i in fields[1:4] ])
                atom_count += 1
                if atom_count == n_atom:
                    flag = 2
                    continue

    # If an xyz file is supplied parse the nuclear centers under the assumption that the units are in angstroms
    # Basic checks are in place for the proper number of atoms and a complete xyz file. 
    if xyz_flag == 1:
        atom_count = 0
        with open(xyz_file,'r') as f:
            for lc,lines in enumerate(f):

                # Initialize elements and geometry lists/arrays
                if lc == 0:
                    fields = lines.split()
                    N_elements = ["X"]*int(fields[0])
                    N_geo      = np.zeros([int(fields[0]),3])
                    continue

                # Parse the nuclei
                # With a conversion from angstroms to bohr
                if lc > 1:
                    fields = lines.split()
                    if len(fields) == 0: 
                        continue
                    else:
                        N_elements[atom_count] = fields[0]
                        N_geo[atom_count] = np.array([ float(i)/0.52917721067 for i in fields[1:4] ])
                        atom_count += 1
        # Perform basic checks on the number of nuclei being parsed
        if len(N_elements) != len(elements):
            print("ERROR in parse_vpot: the number of atoms in the supplied xyz file does not match the number of atoms specified in the vpot file. Exiting...")
            quit()
        if atom_count != len(N_elements):
            print("ERROR in parse_vpot: parsing of the xyz file terminated before finding all nuclear centers. Exiting...")
            quit()
        geo = N_geo
        elements = N_elements

    data_file = 'drude/drude.end.data'
    first_drude = 'drude/drude.data'

    # Get drude label from drude.data (only the very first output from polarizer has this info)
    with open(first_drude,'r') as f:
         flag = 0
         total_atom_count = 0
         for lc,lines in enumerate(f):

             fields = lines.split() 
             if fields != [] and fields[0] == 'Masses':
               # label that matches w/ lammps fix DRUDE command
               # N: not drude C: core atom D: drude particle
               drude_label = {}
               flag = 1
               continue
             if flag == 1 and fields != []:
               if len(fields) == 4:
                  drude_label[fields[0]] = {}
                  drude_label[fields[0]]['mass'] = fields[1]
                  drude_label[fields[0]]['atom_type'] = fields[3]
                  drude_label[fields[0]]['label'] = 'N'
               elif len(fields) == 5:
                  drude_label[fields[0]] = {}
                  drude_label[fields[0]]['mass'] = fields[1]
                  drude_label[fields[0]]['atom_type'] = fields[3]
                  if fields[4] == 'DC' :  
                     drude_label[fields[0]]['label'] = 'C'
                  if fields[4] == 'DP' :  
                     drude_label[fields[0]]['label'] = 'D'
               elif fields[0] == 'Bond':
                  flag = 0
                  continue
             if fields != [] and fields[0] == 'Atoms':
                  flag = 2 
                  continue
             if flag == 2 and fields != []:
                  if fields[0] == 'Bonds':
                     flag = 0
                     continue
                  else:
                     total_atom_count += 1

    N_drude = len([ i for i in drude_label if drude_label[i]['label'] == 'D'])
    N_drude_atom = total_atom_count
    
    # We get geometry of all the atoms (drude included) from drude.end.data(this is data after MD run)           
    with open(data_file,'r') as f:
         for lc,lines in enumerate(f):

             fields = lines.split() 
             if fields != [] and fields[0] == 'Atoms':
               N_geo_D_ND = np.zeros([int(N_drude_atom),3])
               charges_D_ND = np.zeros(N_drude_atom)
               atype_lammps = [0]*N_drude_atom
               flag = 1
               continue
             if flag ==1 and fields != []:

               if fields[0] == 'Velocities':
                  flag = 0
               else: 
                  atom_count = int(fields[0])
                  N_geo_D_ND[atom_count-1] = np.array([ float(i)/0.52917721067 for i in fields[4:7] ])
                  charges_D_ND[atom_count-1] = float(fields[3])
                  atype_lammps[atom_count-1] = fields[2]
                  
                  

    pc_file = '/'.join(filename.split('/')[:-1]) + '/pointcharges.pc'
    charges_pc = np.zeros(1)
    with open(pc_file,'r') as f:
      for lc,lines in enumerate(f):
         fields = lines.split()
         if lc == 1 :
            pc_geo = np.zeros([1,3])
            pc_geo[0] = np.array([ float(i)/0.52917721067 for i in fields[1:4] ])
            charges_pc = float(fields[0])

    

    all_geo = np.vstack((N_geo_D_ND,pc_geo))
    charges_0 = np.hstack((charges_D_ND,charges_pc))

    #print(charges_0)

    #print(all_geo)
    #print(test_geo)
    #print(charges_0)
    #print(test_charge)

    
    

    return elements,geo,grid,potential,all_geo,charges_0,atype_lammps


def natural_sort(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ] 
    return sorted(l, key = alphanum_key)

# A function for extracting the dipole and quadrupole from orca files. 
def parse_orca_out(output_file):

    # Initialize the dipole and quadrupole to None 
    dipole_0 = None
    quadrupole_0 = None
    complete_flag = 0

    # open file and parse dipole/quadrupole if available
    with open(output_file,'r') as f:
        quad_flag = 0
        for lines in f:
            fields = lines.split()
            
            # dipole parsing commands
            if len(fields) == 7 and fields[0] == "Total" and fields[1] == "Dipole" and fields[2] == "Moment":
                dipole_0 = np.array([ float(i) for i in fields[4:7] ])

            # quadrupole parsing commands
            if quad_flag == 6:
                quadrupole_0      = np.zeros([3,3])
                quadrupole_0[0,:] = [float(fields[1]),float(fields[4]),float(fields[5])]
                quadrupole_0[1,:] = [float(fields[4]),float(fields[2]),float(fields[6])]
                quadrupole_0[2,:] = [float(fields[5]),float(fields[6]),float(fields[3])]
                quad_flag = 0
            elif quad_flag > 0:
                quad_flag += 1
            elif len(fields) == 3 and fields[0] == "QUADRUPOLE" and fields[1] == "MOMENT" and fields[2] == "(A.U.)":
                quad_flag = 1
            
            # check for job completion
            if "****ORCA TERMINATED NORMALLY****" in lines:
                complete_flag = 1

    # Print a warning if the output file is incomplete
    if complete_flag == 0:
        print(("WARNING in parse_orca_out: The file {} is incomplete.".format(output_file)))
            
    return dipole_0,quadrupole_0

# Least-squares fit to the potential with a constraint on the total charge
# seps is the inverse displacements of each grid potint from the charge centers being fit
def lstsq_potfit(geo,grid,q_tot,seps,potential):

    A = np.vstack([seps,np.ones(len(geo))*float(len(grid))])
    b = np.hstack([potential,np.array([q_tot * float(len(grid))])])

    # Calculate inverse
    A_inv = np.linalg.pinv(A)

    # Calculate fit coefficients                                                                                                                                                                                                             
    charges_lstsq = np.dot(A_inv,b)
    charges_lstsq = charges_lstsq - ( np.sum(charges_lstsq) - q_tot ) / float(len(charges_lstsq))
    return deepcopy(charges_lstsq)

# Description: A simple wrapper for the file writing commands for the vdw parameters.
#              The function takes arguments for the filename, fit type (e.g. lj), and
#              united-atom (UA) vs all-atom (AA) style.
def write_params(name,charge_dict):

    # Save charges
    with open(name,'w') as f:

        f.write("\n# Charge definitions\n#\n{:10s} {:41s} {:20s}\n".format("#","Atom_type","Charge"))
        for i in natural_sort(list(charge_dict.keys())):
            if '-UA' not in i:
                f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",str(i),np.mean(charge_dict[i])))
        for i in natural_sort(list(charge_dict.keys())):
            if '-UA' in i:
                f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",str(i),np.mean(charge_dict[i])))

# Wrapper script for the molecule.db writing commands
def write_molecule_db(folder,elements,geo,charges,types):

    # Write examples of each molecule in the sim to a molecule.db file. This is used when
    # adding the intramolecular parameters to the master database. Each parameter in the master is linked
    # to the molecule(s) used to generate it. In the case of intramolecular params, the globally optimized
    # geometry is saved to the db.
    with open(folder+'/molecules.db','w') as f:
        f.write("\nmol {:6d} start\n".format(1))
        # Save an xyz for viewing the configuration in VMD
        f.write('{}\n\n'.format(len(geo)))
        for count_i,i in enumerate(geo):
            f.write('  {:<10s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 12.6f} {:<60s}\n'.\
            format(elements[count_i],i[0],i[1],i[2],charges[count_i],types[count_i]))
        f.write("mol {:6d} end\n".format(1))

    return

# Description: This function is a simple wrapper for the matplotlib plotting commands
#              to generate the scatterplot of the correlation between the QC interaction
#              energies and the FF interaction energies. The function also saves the 
#              convergence data to file.
def plot_convergence(folder,potential_all,seps_all,charges):

    # Generate fit plot
    color_list = [(0.05,0.35,0.75),(0.05,0.8,0.6),(0.9,0.3,0.05),(0.35,0.7,0.9),(0.9,0.5,0.7),(0.9,0.6,0.05),(0.95,0.9,0.25),(0.05,0.05,0.05)]*20   # Supposedly more CB-friendly
    fig = plt.figure(figsize=(6,5))
    ax = plt.subplot(111)
    plot_handles = []

    # Generate subset of plot values ("plot_num" argument determines the number of convergence cycles
    # to explicitly plot, although all are saved to the .txt file; e.g. plot_num plots the first and last
    # cycles plus the 1/4 1/2 and 3/4 converged cycles).

    #
    # Plot VDW_fit correlation plot
    #


    # Plot the scatter data
    for count_i,i in enumerate(potential_all):   
        plot_handle, = ax.plot(potential_all[i],np.dot(seps_all[i],charges.T),marker='.',markersize=20,color=color_list[count_i],markeredgewidth=0.0,alpha=0.3,linestyle='None',label='cycle: {}'.format(i))

    # Find min and max based on the final fit_vals
    y_min_fit = 1000000.0
    y_max_fit =-1000000.0
    fit_vals=[]
    for i in seps_all:
        fit_vals.append(np.dot(seps_all[i],charges.T))
    for i in fit_vals:
        if min(i) < y_min_fit: y_min_fit = np.floor(min(i))
        if max(i) > y_min_fit: y_max_fit = np.ceil(max(i))        
            
    # Set limits based on the largest range
    y_min,y_max = ax.get_ylim()
    x_min,x_max = ax.get_xlim()
    
    # If y_min or y_max are impractically larger than the limits of the final fit values, then the y limits are reassigned
    if abs(y_min-y_min_fit) > 10: y_min = y_min_fit
    if abs(y_max-y_max_fit) > 10: y_max = y_max_fit

    if x_min < y_min: y_min = x_min;
    else: x_min = y_min
    if x_max > y_max: y_max = x_max;
    else: x_max = y_max
    ax.set_xlim([x_min,x_max])
    ax.set_ylim([y_min,y_max])

    # Plot the diagonal line
    ax.plot(ax.get_xlim(), ax.get_ylim(), ls="-", c="0")

    # Set Labels and Save Name
    ax.set_ylabel("$\mathrm{E_{FF} \, (kcal \cdot mol^{-1})}$",fontsize=32,labelpad=10,fontweight='bold')
    ax.set_xlabel("$\mathrm{E_{DFT} \, (kcal \cdot mol^{-1})}$",fontsize=32,labelpad=10,fontweight='bold')
    plot_name = 'Drude_convergence.png'
    data_name = 'Drude_vdw_convergence.txt'

    # Generate Legend
    ax.legend(loc='best',frameon=False)
    handles, labels = ax.get_legend_handles_labels()
    lgd = ax.legend(handles, labels, loc='center left', bbox_to_anchor=(1,0.5))

    # Format ticks
    ax.tick_params(axis='both', which='major',labelsize=12,pad=10,direction='out',width=2,length=4)
    ax.tick_params(axis='both', which='minor',labelsize=12,pad=10,direction='out',width=2,length=3)
    [j.set_linewidth(2) for j in ax.spines.values()]

    # Save the figure
    savefig(folder+'/'+plot_name, dpi=300, bbox_extra_artists=(lgd,), bbox_inches='tight')
    close(fig)

    # Save the convergence data to file
    #with open(folder+'/'+data_name,'w') as f:
    #    f.write(' {:<15s} {}\n'.format("E_INT_VDW_DFT",' '.join([ "{:<15s}".format("E_INT_VDW_FF_"+str(count_i)) for count_i,i in enumerate(potential_all) ])))
    #    for count_i,i in enumerate(y_vals):
    #        f.write('{:< 15.8f} {}\n'.format(i,' '.join([ "{:< 15.8f}".format(j[count_i]) for j in fit_vals ])))

    #
# Create logger to save stdout to logfile
class Logger(object):

    def __init__(self,folder):
        self.terminal = sys.stdout
        self.log = open(folder+"/fit_charges.log", "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)  
    def flush(self):
        pass

if __name__ == "__main__":
   main(sys.argv[1:])
