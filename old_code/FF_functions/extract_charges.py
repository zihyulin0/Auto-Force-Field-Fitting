#!/bin/env python
# Author: Brett Savoie (brettsavoie@gmail.com)

import sys,argparse,os,re,fnmatch
from scipy.optimize import leastsq
from scipy.optimize import minimize
import scipy.optimize
from scipy.spatial.distance import cdist
import numpy as np #from numpy import *
from numpy.linalg import norm
from copy import deepcopy
import time
from itertools import combinations

# Add TAFFY Lib to path
sys.path.append('/'.join(os.path.abspath(__file__).split('/')[:-2])+'/Lib')
from transify import *
from adjacency import *
from file_parsers import *
from id_types import *
from kekule import *
import random

def main(argv):

    parser = argparse.ArgumentParser(description='This program generates CHELPG or RESP charges from potential grids generated by orca.')

    #optional arguments                                                                                                                                                        
    parser.add_argument('filename', help = 'file holding the electric potential')

    parser.add_argument('-xyz', dest='xyz_file', default=None,
                        help = 'The geometry of the nuclear centers can be supplied in the form of an xyz file (a typical output of orca) with coordinates in angstroms. If the '\
                               '*.xyz file is not supplied, then the element labels for the nuclear centers must be supplied to geometry block of the *.vpot file. (default: None)')

    parser.add_argument('-d', dest='path', default=None,
                        help = 'When filename is a folder, the program operates on all files with the extension *.vpot discovered during a directory walk. Optionally, if this argument is supplied then only *.vpot files '+\
                               'whose path includes the -d argument will be operated on. (default: None)')

    parser.add_argument('-out', dest='out_file', default=None,
                        help = 'For fitting the dipole and/or quadrupole moment, the output file holding these quantities must be supplied (default: None)')

    parser.add_argument('-o', dest='output_folder', default='charge_parse',
                        help = 'All outputs from the averaging are saved to a subfolder of the working directory (determined by the -f argument). '+\
                               'This option determines the folder name. (default: charge_parse)') 

    parser.add_argument('-q', dest='qtot', default=0.0,
                        help = 'Total charge constraint on the molecule (default: 0.0)')

    parser.add_argument('-gens', dest='gens', default=2,
                        help = 'Number of generations for defining atom type uniqueness. (default: 2)')

    parser.add_argument('-seed', dest='seed', default=444,
                        help = 'The seed for the random number generator. (default: 444)')

    parser.add_argument('-w_pot', dest='w_pot', default=1.0,
                        help = 'The relative weight in the penalty function for deviations from the electric potential. (default: 1.0)')

    parser.add_argument('-w_qtot', dest='w_qtot', default=1.0,
                        help = 'The relative weight in the penalty function for deviations from the total charge on the molecule. (default: 1.0)')

    parser.add_argument('-w_hyper', dest='w_hyper', default=0.0,
                        help = 'The weight of the hyperbolic penalty term in the fit function. (default: 0.0)')

    parser.add_argument('-b_hyper', dest='b_hyper', default=0.1,
                        help = 'The hyperbolic stiffness parameter in the fit function. (default: 0.1; RESP default)')

    parser.add_argument('-w_dipole', dest='w_dipole', default=0.1,
                        help = 'The relative weight in the penalty function for deviations from the dipole moment. (default: 0.1 or 0 if no output is supplied from which the dipole can be read)')

    parser.add_argument('-w_quad', dest='w_quadrupole', default=0.0,
                        help = 'The relative weight in the penalty function for deviations from the quadrupole moment. (default: 0)')

    parser.add_argument('-FF', dest='FF_db', default="",
                        help = 'A space-delimited string containing taffi force field database(s). Any partial charges contained in the supplied database(s) are held fixed during the fitting procedure. (default: none)')

    parser.add_argument('-N', dest='N_configs', default=None,
                        help = 'Expects an integer. When supplied, only this number of configurations will be used for the fit (default: None)') 

    parser.add_argument('--symmetrize', dest='symmetrize', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, the partial charges on identical atom types are constrained to be equal during the fitting. (default: off)')

    parser.add_argument('--UA', dest='UA_opt', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied all hydrogens attached to carbon are removed from the fitting procedure. (default: off)')

    parser.add_argument('--keep_min', dest='keep_min', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, partial charges are only written for atomtypes that the xyz corresponds to their minimum fragment. (default: off)')

    parser.add_argument('--two_step', dest='two_step', default=False, action='store_const', const=True,
                        help = 'When this flag is supplied, the charges are fitted in two steps. In the first step, symmetry is forced on like atomtypes for atoms that are not carbon or a hydrogen attached to carbon. This provides '+\
                               'the highest accuracy when describing the polar atoms in the system. In the second step, the partial charges that were symmetrized in the first step are held fixed and the rest of the atoms are fit '+\
                               'with symmetry constraints. (default: off)')

    # Parse the inputs
    args=parser.parse_args(argv)
    args.qtot = float(args.qtot)
    args.w_pot = float(args.w_pot)
    args.w_qtot = float(args.w_qtot)
    args.w_hyper = float(args.w_hyper)
    args.b_hyper = float(args.b_hyper)
    args.w_dipole = float(args.w_dipole)
    args.w_quadrupole = float(args.w_quadrupole)
    args.output_folder = str(args.output_folder)
    args.FF_db = args.FF_db.split()
    args.gens = int(args.gens)
    if args.N_configs is not None: args.N_configs = int(args.N_configs); 
    if args.N_configs is not None and args.N_configs < 0: print("ERROR: -N option must be an integer greater than 0. Exiting..."); quit()

    # Use a fixed seed value to ensure reproducibility between runs
    random.seed(int(args.seed))

    # Check if the folder protocol or file protocol is being used
    # the former performs a recursive search for *.vpot files and 
    if os.path.isdir(args.filename) == True:
        folder_protocol = True
        args.output_folder = args.filename + '/' + args.output_folder
    else:
        folder_protocol = False

    # If supplied, check that the FF files exist
    fixed_dict={}
    if args.FF_db != []:
        for i in args.FF_db:
            if os.path.isfile(i) is False:
                print(("ERROR: the file {} supplied to -FF does not exist. Exiting...".format(i)))
                quit()
            else:
                with open(i,'r') as f:
                    for lines in f:
                        fields = lines.split()
                        if len(fields) >= 2 and fields[0] == "charge":
                            fixed_dict[fields[1]] = float(fields[2])

    # Check that the output folder doesn't already exist.
    if os.path.isdir(args.output_folder) == True:
        print(("ERROR in exrtact_charges: Requested output folder ({}) already exists. Exiting to avoid overwriting data...".format(args.output_folder)))
        quit()
    else:
        os.makedirs(args.output_folder)
        os.makedirs(args.output_folder+'/figures')
        sys.stdout = Logger(args.output_folder)
        print(("PROGRAM CALL: python extract_charges.py {}\n".format(' '.join([ i for i in argv]))))

    # Print header
    print(("\n{}".format("*"*140)))
    print(("* {:^136s} *".format("Parsing Partial Charges in {}".format(args.filename))))
    print(("{}".format("*"*140)))

    #################################
    # file based consistency checks #
    #################################
    if folder_protocol == False:

        # Initialize lists. These are overkill for the single file but they conform to the directory-based protocol for parsing many files at once.
        potfiles = [args.filename]
        outputs  = [args.out_file]
        xyzs     = [args.xyz_file]
        paths    = ['.']

        #  Parse the dipole/quadupole if an output file is supplied
        if args.out_file is not None:
            if os.path.isfile(args.out_file) == False:
                print(("ERROR in extract_charges: the supplied output file for reading dipole/quadrupole data ({}) does not exist. Exiting...".format(args.out_file)))
                quit()
            else:
                outputs = [args.out_file]
                dipole_0,quadrupole_0 = parse_orca_out(args.out_file)
        else:
            dipole_0 = None
            quadrupole_0 = None

        # Check for required files and print warnings for inconsistent parameter specifications
        if os.path.isfile(args.filename) == False:
            print(("ERROR in extract_charges: could not open file {}. Exiting...".format(args.filename)))
        if args.xyz_file is not None and os.path.isfile(args.xyz_file) == False:
            print(("ERROR in extract_charges: the supplied xyz filename ({}), could not be found. Exiting...".format(args.xyz_file)))
        if ( args.out_file is None or dipole_0 is None ) and args.w_dipole != 0.0:
            print("WARNING in extract_charges: An output file for reading the dipole moment was not supplied but the dipole weight is set to a non-zero value.")
            print("                            fit_charges will set the dipole weight to zero and continue with the fit.")
            args.w_dipole = 0
        if ( args.out_file is None or quadrupole_0 is None ) and args.w_quadrupole != 0.0:
            print("WARNING in extract_charges: An output file for reading the quadrupole moment was not supplied but the quadrupole weight is set to a non-zero value.")
            print("                            fit_charges will set the quadrupole weight to zero and continue with the fit.")
            args.w_quadrupole = 0

    ###################################
    # folder based consistency checks #
    ###################################
    elif folder_protocol == True:

        # Create a dictionary from the filenames, where each dictionary key corresponds to a filename and each entry is a list
        # of subfiles to be processed as a batch. e.g., molecule.in might show up in twenty subfolders. molecule.in would end
        # up as a key, and the list of individual instances of molecule.in would constitute the entry.
        Files = {}
        if args.path is None:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(args.filename+'/.') for f in filenames if fnmatch.fnmatch(f,"*.vpot") ]
        else:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(args.filename+'/.') for f in filenames if (fnmatch.fnmatch(f,"*.vpot") and args.path in dp)  ]

        # Assemble paths, xyz files, and output files
        paths    = [ "/".join(i.split('/')[:-1]) for i in potfiles ]
        xyzs     = []
        outputs  = []
        for count_i,i in enumerate(paths):
            tmp_out = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.out") ]
            tmp_xyz = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.xyz") ]

            # Populate in a one-to-one path to *.out and *.xyz fashion. Place None in the list if no matching file was found. If multiple matches are found then place the first file in the list.
            if len(tmp_out) > 0:
                outputs += [tmp_out[0]]
            else:
                outputs += [None]
            if len(tmp_xyz) > 0: 
                xyzs    += [tmp_xyz[0]]
            else:
                xyzs    += [None]
                    
        # Check for required files and print warnings for inconsistent parameter specifications
        if None in outputs and args.w_dipole != 0.0:
            print("WARNING in extract_charges: Output files for reading the dipole moment could not be found for all discovered *.vpot files and the dipole weight is set to a non-zero value.")
            print("                            fit_charges will set the dipole weight to zero and continue with the fit.")
            args.w_dipole = 0
        if None in outputs and args.w_quadrupole != 0.0:
            print("WARNING in extract_charges: Output files for reading the quadrupole moment could not be found for all discovered *.vpot files and the quadrupole weight is set to a non-zero value.")
            print("                            fit_charges will set the quadrupole weight to zero and continue with the fit.")
            args.w_quadrupole = 0

        # Only use up to N_configs if the argument was supplied by the user
        if args.N_configs is not None and args.N_configs < len(outputs):
            keep_ind = list(range(len(outputs)))
            random.shuffle(keep_ind)
            keep_ind = keep_ind[:args.N_configs]
            potfiles = [ potfiles[i] for i in keep_ind ]
            outputs  = [ outputs[i] for i in keep_ind ]
            xyzs     = [ xyzs[i] for i in keep_ind ]

    # Print diagnostic
    print(("Number of Configurations Being Parsed: {}\n".format(len(potfiles))))    

    ################
    # All-Atom Fit # 
    ################

    for z in [ 'AA', 'UA' ]:

        # Initialize arrays
        lstsq_D_errs = []
        lstsq_errs   = []
        lstsq_qtot   = []
        fit_D_errs   = []
        fit_errs     = []
        fit_qtot     = []
        avoid_list   = []

        if z == "AA":
            lstsq_dict   = {}
            fit_dict     = {}

        # Iterate over the files being fit
        for count_f,f in enumerate(potfiles):
            
            # Parse dipole and quadrupole
            # Parse the geometry, grid locations, and potential from the orca *.vpot file
            # NOTE: the geo,grid are returned in bohr
            elements,geo,grid,potential = parse_vpot(f,xyzs[count_f])

            # Generate the adjacency matrix
            # NOTE: the units are converted back angstroms
            adj_mat = Table_generator(elements,geo*0.52917721067,File=xyzs[count_f])

            # Generate the atomtypes
            #atomtypes = id_types(elements,adj_mat,args.gens,Hybridization_finder(elements,adj_mat),geo*0.52917721067)
            atomtypes = id_types(elements,adj_mat,args.gens) # id_types v.062520

            # Calculate the center of mass
            cm = calc_cm(elements,geo)    

            # Parse dipole/quadrupole
            if outputs[count_f] is not None:
                dipole_0,quadrupole_0 = parse_orca_out(outputs[count_f])
            else:
                w_dipole = 0.0
                w_quadrupole = 0.0
                dipole_0 = np.array([0.0,0.0,0.0])
                quadrupole_0 = np.array([0.0,0.0,0.0])

            # If no dipole or quadrupole are found then zero out the weight of that component and continue
            if dipole_0 is None:
                w_dipole = 0.0
                dipole_0 = np.array([0.0,0.0,0.0])
            if quadrupole_0 is None:
                w_quadrupole = 0.0
                quadrupole_0 = np.array([0.0,0.0,0.0])

            # Prune united-atom hydrogens if the option is enabled
            if z == "UA":
                del_ind=[ count_i for count_i,i in enumerate(adj_mat) if elements[count_i] == "H" and len([ j for count_j,j in enumerate(adj_mat[count_i]) if j == 1 and elements[count_j] == "C" and np.sum(adj_mat[count_j]) == 4 ]) > 0 ]
                keep_ind = [ i for i in range(len(adj_mat)) if i not in del_ind ]
                # keep_ind = [ count_i for count_i,i in enumerate(adj_mat) if elements[count_i] != "H" or "C" not in [ elements[count_j] for count_j,j in enumerate(i) if j == 1 ] ]
                geo = geo[keep_ind]
                elements = [ elements[i] for i in keep_ind ]
                adj_mat = adj_mat[keep_ind,:][:,keep_ind]
                atomtypes = [ atomtypes[i]+'-UA' for i in keep_ind ]

            # Calculate the inverse displacements of each grid point from the charge centers being fit. 
            seps = 1.0/cdist(grid,geo)

            # Calculate lstsq fit with qtot charge constraint as a reference
            lstsq_charges = lstsq_potfit(geo,grid,args.qtot,seps,potential)

            # Initialize initial guess (charges) and a list of holding the index in charges that each atomic charges corresponds to
            # In the case of no symmetry constraints, charge_mapping simply maps one-to-one to the charges list. When there are symmetry 
            # constraints the charge_mapping elements of like atomtypes will commonly reference some common index in charges array. 
            # NOTE: initial guess is made to satisfy q_tot but distributing the necessary amount to the atoms being fit
            # NOTE: fix_ind and the initial guess are populated with charges from the supplied FF files  
            charge_mapping = list(range(len(geo)))
            fix_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i in list(fixed_dict.keys()) ]
            fit_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i not in list(fixed_dict.keys()) ]
            charges_0      = np.array([ 0.0 if count_i in fit_ind else fixed_dict[atomtypes[count_i]] for count_i,i in enumerate(atomtypes) ])
            if len(fit_ind) == 0:
                offset = 0.0
            else:
                offset         = (args.qtot-np.sum(charges_0))/float(len(fit_ind))
            for i in fit_ind: charges_0[i] = offset

            ###################
            # Fit the charges #
            ###################

            # two-step algorithm: first fits the polar atoms with symmetry constraints, then holds the polar atoms fixed and fits the non-polar atoms with symmetry constraints.
            if args.two_step == True:

                # Find non-carbon atoms and hydrogens that aren't attached to carbon
                polar_ind = [ count_i for count_i,i in enumerate(adj_mat) if \
                              ( elements[count_i] != 'C' and elements[count_i] != "H" ) or ( elements[count_i] == "H" and np.sum([ 1 for count_j,j in enumerate(adj_mat[count_i]) if ( j == 1 and elements[count_j] == "C" ) ]) == 0 ) ]

                # Find non-carbon atoms and hydrogens that aren't attached to carbon
                nonpolar_ind = [ i for i in range(len(geo)) if i not in polar_ind ]

                # Remove fixed atoms from fit consideration
                polar_ind    = [ i for i in polar_ind if i not in fix_ind ]
                nonpolar_ind = [ i for i in nonpolar_ind if i not in fix_ind ]

                # During the first step (i) no charges are fixed and (ii) symmetry is only forced on the polar atoms.
                # The polar atomtypes are looped over (outer loop), the indices of all like atomtypes are found (idx), all charge_mapping elements at indices idx are set to point at the first instance of that atom type.
                charge_mapping = list(range(len(geo)))
                for i in set([ atomtypes[j] for j in polar_ind ]):
                    idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                    for j in idx: charge_mapping[j] = idx[0]

                # Fit the polar atoms                    imposes_symmetry fits_all
                fit_charges = flex_fit(geo,potential,seps,charge_mapping,fit_ind,\
                                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)

                # During the second step (i) the charges on the polar_ind atoms are fixed and (ii) symmetry is forced on the non_polar atoms.
                for i in set([ atomtypes[j] for j in nonpolar_ind ]):
                    idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                    for j in idx: charge_mapping[j] = idx[0]

                # Check to ensure that there is something to fit in this second step
                if len(nonpolar_ind) > 0:

                    # Fit the non-polar atoms                imposes_symmetry fits_only_nonpolar
                    fit_charges = flex_fit(geo,potential,seps,charge_mapping,nonpolar_ind,\
                                           args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=fit_charges,traceless_opt=False)
                
            # symmetrize algorithm: fits all atoms at once with symmetry constraints.
            elif args.symmetrize == True:

                # The atomtypes are looped over (outer loop), the indices of all like atomtypes are found (idx), all charge_mapping elements at indices idx are set to point at the first instance of that atom type.
                for i in set(atomtypes):
                    idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                    for j in idx: charge_mapping[j] = idx[0]

                # Fit the charges                        imposes_symmetry  fits_all_atoms
                fit_charges = flex_fit(geo,potential,seps,charge_mapping,fit_ind,\
                                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)

            # default: perform the fit to all atoms at once without symmetry constraints
            else:

                # Fit the charges
                fit_charges = flex_fit(geo,potential,seps,list(range(len(geo))),fit_ind,\
                                       args.qtot,dipole_0,quadrupole_0,cm,args.w_pot,args.w_qtot,args.w_hyper,args.b_hyper,args.w_dipole,args.w_quadrupole,charges_0=charges_0,traceless_opt=False)

            # Update the charges in the dictionaries
            for i in set(atomtypes):

                # When keep_min option is enabled, the program avoids saving any charges for whom this geometry is not a minimal structure
                if args.keep_min is True and minimal_structure(i,geo,elements,adj_mat=adj_mat,atomtypes=atomtypes) is False :                    
                    avoid_list += [i]
                    continue

                if i not in lstsq_dict:
                    lstsq_dict[i] = []
                if i not in fit_dict:
                    fit_dict[i] = []
                for count_j,j in enumerate(atomtypes):
                    if i == j:
                        lstsq_dict[i] += [lstsq_charges[count_j]]
                        fit_dict[i] += [fit_charges[count_j]]

            # Update error dictionaries
            lstsq_errs += [np.mean((Calc_Pot(seps,lstsq_charges)-potential)**(2.0))]
            fit_errs += [np.mean((Calc_Pot(seps,fit_charges)-potential)**(2.0))]
            if dipole_0 is not None:
                lstsq_D_errs += [ (norm(dipole_0) - calc_dipole(geo,lstsq_charges)[1])**(2.0) ]
                fit_D_errs += [ (norm(dipole_0) - calc_dipole(geo,fit_charges)[1])**(2.0) ]

            # Update qtot lists           
            lstsq_qtot += [np.sum(lstsq_charges)] 
            fit_qtot += [np.sum(fit_charges)]

        # Print Charge summary
        print(("{}".format("*"*140)))
        print(("* {:^136s} *".format("Final {}-Charges".format(z))))
        print(("*{:^138s}*".format("-"*138)))
        print(("* {:<60s}         {:<30s}        {:<19s} {:<10s}*".format("Atomtype","CHELPG","Fit","Status")))
        print(("{}".format("*"*140)))
        for i in lstsq_dict:
            if z == "UA" and "-UA" not in i: continue
            if i in list(fixed_dict.keys()): origin="fixed"
            else: origin="fit"
            print(("  {:<60s} {:35s} {:30s} {}".format(i,"{:< 8.6f} +/- {:<12.6f}".format(np.mean(lstsq_dict[i]),np.std(lstsq_dict[i])),"{:< 8.6f} +/- {:<12.6f}".format(np.mean(fit_dict[i]),np.std(fit_dict[i])),origin)))

        # Print error summary
        print(("\n  {:<60s} {:< 35.6g} {:< 35.6g} ".format("<xhi_pot^2> (A.U.^2):",np.mean(lstsq_errs),np.mean(fit_errs))))
        if len(lstsq_D_errs) > 0:
            print(("  {:<60s} {:< 35.6g} {:< 35.6g} ".format("<xhi_D^2> (A.U.^2):",np.mean(lstsq_D_errs),np.mean(fit_D_errs))))
        print(("  {:<60s} {:< 35.6f} {:< 35.6f} \n".format("total charge (A.U.):",np.mean(lstsq_qtot),np.mean(fit_qtot))))    

        # Print summary of charges not saved due to the --keep_min option
        if len(avoid_list) > 0:
            avoid_list = set(avoid_list)
            print(("{}".format("*"*140)))
            print(("* {:^136s} *".format("Atomtypes that weren't Saved Because this isn't a Minimal Geometry")))
            print(("{}".format("*"*140)))
            print("\nList of atomtypes that weren't saved:\n")
            for i in sorted(avoid_list):
                print(("\t{}".format(i)))
            print(" ")

    # Write the charge database file(s)
    write_params(args.output_folder+'/chelpg.db',lstsq_dict)
    write_params(args.output_folder+'/fit_charges.db',fit_dict)

    # Write molecule.db file. This is used for integrating parameters into master database files
    # so that parameters can be linked with the model molecule used to parametrize them.
    write_molecule_db(args.output_folder,elements,geo,[ np.mean(fit_dict[i]) if i in fit_dict else 0.0 for i in atomtypes ],atomtypes)

    # Print farewell
    print(("{}".format("*"*140)))
    print(("*{:^138s}*".format("Charge Parse Complete!")))
    print(("{}\n".format("*"*140)))

    return


# Description:   Checks is the supplied geometry corresponds to the minimal structure of the molecule
# 
# Inputs:        atomtype:      The taffi atomtype being checked
#                geo:           Geometry of the molecule
#                elements:      elements, indexed to the geometry 
#                adj_mat:       adj_mat, indexed to the geometry (optional)
#                atomtypes:     atomtypes, indexed to the geometry (optional)
#                gens:          number of generations for determining atomtypes (optional, only used if atomtypes are not supplied)
# 
# Outputs:       Boolean:       True if geo is the minimal structure for the atomtype, False if not.
def minimal_structure(atomtype,geo,elements,adj_mat=None,atomtypes=None,gens=2):

    # If required find the atomtypes for the geometry
    if atomtypes is None or adj_mat is None:
        if len(elements) != len(geo):
            print("ERROR in minimal_structure: While trying to automatically assign atomtypes, the elements argument must have dimensions equal to geo. Exiting...")
            quit()

        # Generate the adjacency matrix
        # NOTE: the units are converted back angstroms
        adj_mat = Table_generator(elements,geo)

        # Generate the atomtypes
        #atomtypes = id_types(elements,adj_mat,gens,Hybridization_finder(elements,adj_mat),geo)
        atomtypes = id_types(elements,adj_mat,gens) # id_types v.062520
        
    # Check minimal conditions
    count = 0
    for count_i,i in enumerate(atomtypes):

        # If the current atomtype matches the atomtype being searched for then proceed with minimal geo check
        if i == atomtype:
            count += 1

            # Initialize lists for holding indices in the structure within "gens" bonds of the seed atom (count_i)
            keep_list = [count_i]
            new_list  = [count_i]
            
            # Carry ount a "gens" bond deep search
            for j in range(gens):

                # Id atoms in the next generation
                tmp_new_list = []                
                for k in new_list:
                    tmp_new_list += [ count_m for count_m,m in enumerate(adj_mat[k]) if m == 1 and count_m not in keep_list ]

                # Update lists
                tmp_new_list = list(set(tmp_new_list))
                if len(tmp_new_list) > 0:
                    keep_list += tmp_new_list
                new_list = tmp_new_list
            
            # Check for the minimal condition
            keep_list = set(keep_list)
            if False in [ elements[j] == "H" for j in range(len(elements)) if j not in keep_list ]:
                minimal_flag = False
            else:
                minimal_flag = True
        
    return minimal_flag

# Replicates the main block, but removes the dependence on argparse, suppresses all print calls, and returns a 
# dictionary with the fit charges
# 
# Inputs:        filename:      the filename of the *.vpot file
#
#                xyz_file:      optional argument holding the xyz file that has the elements of the fit geometry
#
#                path:          When filename is a folder, the program operates on all files with the extension *.vpot discovered during a directory walk. Optionally, if this argument is supplied then only *.vpot files 
#                               whose path includes the -d argument will be operated on. (default: None)
#
#                out_file:      For fitting the dipole and/or quadrupole moment, the output file holding these quantities must be supplied (default: None)
#
#                qtot:          Total charge constraint on the molecule (default: 0.0)    
#
#                gens:          Number of generations for defining atom type uniqueness. (default: 2)
#
#                w_pot:         The relative weight in the penalty function for deviations from the electric potential. (default: 1.0)
#
#                w_qtot:        The relative weight in the penalty function for deviations from the total charge on the molecule. (default: 1.0)
#
#                w_hyper:       The weight of the hyperbolic penalty term in the fit function. (default: 0.0)
# 
#                b_hyper:       The hyperbolic stiffness parameter in the fit function. (default: 0.1; RESP default)
#
#                w_dipole:      The relative weight in the penalty function for deviations from the dipole moment. (default: 0.1 or 0 if no output is supplied from which the dipole can be read)
#
#                w_quadrupole:  The relative weight in the penalty function for deviations from the quadrupole moment. (default: 0)
#
#                UA_opt:        When this bool is set to True, all hydrogens attached to carbon are removed from the fitting procedure. (Not implemented: by default both UA and AA fits are performed)
# 
#                symmetrize:    When this bool is set ot True, the partial charges on identical atom types are constrained to be equal during the fitting. (default: False)
# 
#                two_step:      When this bool is set to True, the charges are fit with the default TAFFI two step protocol. In the first step, symmetry is forced on like atomtypes for atoms that are not 
#                               carbon or a hydrogen attached to carbon. This provides the highest accuracy when describing the polar atoms in the system. In the second step, the 
#                               partial charges that were symmetrized in the first step are held fixed and the rest of the atoms are fit with symmetry constraints. (default: False)
#
#                keep_min:      When this bool is set to True, the charges are fit as usual but only the atomtypes for whom the supplied geometry is a minimal structure will be returned. 
#
# Returns:       AA_charges:    A dictionary of all-atom charges with atom types as the keys and the charges as the elements
#
#                UA_charges:    A dictionary of united-atom charges with the atom types as the keys and the charges as the elements
#
def fit_charges(filename,xyz_file=None,path=None,out_file=None,qtot=0.0,gens=2,w_pot=1.0,w_qtot=1.0,w_hyper=0.0,b_hyper=0.1,w_dipole=0.1,w_quadrupole=0.0,FF_db='',N_configs=None,seed=444,\
                UA_opt=False,symmetrize=False,two_step=False,keep_min=False,verbose=False):

    # Consistency checks
    if UA_opt not in [ True, False ]: 
        print("ERROR in fit_charges: UA_opt must be set to a bool (True, False). Exiting...")
        quit()
    if symmetrize not in [ True, False ]: 
        print("ERROR in fit_charges: symmetrize must be set to a bool (True, False). Exiting...")
        quit()
    if two_step not in [ True, False ]: 
        print("ERROR in fit_charges: two_step must be set to a bool (True, False). Exiting...")
    if verbose not in [ True, False ]: 
        print("ERROR in fit_charges: verbose must be set to a bool (True, False). Exiting...")
    if symmetrize is True and two_step is True:
        print("WARNING in fit_charges: both symmetrize and two_step cannot simulataneously be set to True. Defaulting to two_step = True.")
        symmetrize = False
    if keep_min not in [ True, False ]: 
        print("ERROR in fit_charges: keep_min must be set to a bool (True, False). Exiting...")
        quit()
    if N_configs is not None: N_configs = int(N_configs); 
    if N_configs is not None and N_configs < 0: 
        print("ERROR: -N option must be an integer greater than 0. Exiting...")
        quit()

    # Use a fixed seed value to ensure reproducibility between runs
    random.seed(int(seed))

    # If FF_db argument is supplied then check the existence of the force-fields databases
    FF_db = FF_db.split()
    fixed_dict={}
    if FF_db != []:
        for i in FF_db:
            if os.path.isfile(i) is False:
                print(("ERROR: the file {} supplied to -FF does not exist. Exiting...".format(i)))
                quit()
            else:
                with open(i,'r') as f:
                    for lines in f:
                        fields = lines.split()
                        if len(fields) >= 2 and fields[0] == "charge":
                            fixed_dict[fields[1]] = float(fields[2])

    # Check if the folder protocol or file protocol is being used
    # the former performs a recursive search for *.vpot files and 
    if os.path.isdir(filename) == True:
        folder_protocol = True
    else:
        folder_protocol = False

    #################################
    # file based consistency checks #
    #################################
    if folder_protocol == False:

        # Initialize lists. These are overkill for the single file but they conform to the directory-based protocol for parsing many files at once.
        potfiles = [filename]
        outputs  = [out_file]
        xyzs     = [xyz_file]
        paths    = ['.']

        #  Parse the dipole/quadupole if an output file is supplied
        if out_file is not None:
            if os.path.isfile(out_file) == False:
                print(("ERROR in fit_charges: the supplied output file for reading dipole/quadrupole data ({}) does not exist. Exiting...".format(out_file)))
                quit()
            else:
                outputs = [out_file]
                dipole_0,quadrupole_0 = parse_orca_out(out_file)
        else:
            dipole_0 = None
            quadrupole_0 = None

        # Check for required files and print warnings for inconsistent parameter specifications
        if os.path.isfile(filename) == False:
            print(("ERROR: could not open file {}. Exiting...".format(filename)))
        if xyz_file is not None and os.path.isfile(xyz_file) == False:
            print(("ERROR: the supplied xyz filename ({}), could not be found. Exiting...".format(xyz_file)))
        if ( out_file is None or dipole_0 is None ) and w_dipole != 0.0:
            print("WARNING in fit_charges: An output file for reading the dipole moment was not supplied but the dipole weight is set to a non-zero value.")
            print("                        fit_charges will set the dipole weight to zero and continue with the fit.")
            w_dipole = 0
        if ( out_file is None or quadrupole_0 is None ) and w_quadrupole != 0.0:
            print("WARNING in fit_charges: An output file for reading the quadrupole moment was not supplied but the quadrupole weight is set to a non-zero value.")
            print("                        fit_charges will set the quadrupole weight to zero and continue with the fit.")
            w_quadrupole = 0

    ###################################
    # folder based consistency checks #
    ###################################
    elif folder_protocol == True:

        # Create a dictionary from the filenames, where each dictionary key corresponds to a filename and each entry is a list
        # of subfiles to be processed as a batch. e.g., molecule.in might show up in twenty subfolders. molecule.in would end
        # up as a key, and the list of individual instances of molecule.in would constitute the entry.
        Files = {}
        if path is None:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(filename+'/.') for f in filenames if fnmatch.fnmatch(f,"*.vpot") ]
        else:
            potfiles = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(filename+'/.') for f in filenames if (fnmatch.fnmatch(f,"*.vpot") and path in dp)  ]

        # Assemble paths, xyz files, and output files
        paths    = [ "/".join(i.split('/')[:-1]) for i in potfiles ]
        xyzs     = []
        outputs  = []
        for count_i,i in enumerate(paths):
            tmp_out = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.out") ]
            tmp_xyz = [ '/'.join([i,j]) for j in os.listdir(i) if fnmatch.fnmatch(j,"*.xyz") ]

            # Populate in a one-to-one path to *.out and *.xyz fashion. Place None in the list if no matching file was found. If multiple matches are found then place the first file in the list.
            if len(tmp_out) > 0:
                outputs += [tmp_out[0]]
            else:
                outputs += [None]
            if len(tmp_xyz) > 0: 
                xyzs    += [tmp_xyz[0]]
            else:
                xyzs    += [None]
                    
        # Check for required files and print warnings for inconsistent parameter specifications
        if None in outputs and w_dipole != 0.0:
            print("WARNING in fit_charges: Output files for reading the dipole moment could not be found for all discovered *.vpot files and the dipole weight is set to a non-zero value.")
            print("                        fit_charges will set the dipole weight to zero and continue with the fit.")
            w_dipole = 0
        if None in outputs and w_quadrupole != 0.0:
            print("WARNING in fit_charges: Output files for reading the quadrupole moment could not be found for all discovered *.vpot files and the quadrupole weight is set to a non-zero value.")
            print("                        fit_charges will set the quadrupole weight to zero and continue with the fit.")
            w_quadrupole = 0

        # Only use up to N_configs if the argument was supplied by the user
        if N_configs is not None and N_configs < len(outputs):
            keep_ind = list(range(len(outputs)))
            random.shuffle(keep_ind)
            keep_ind = keep_ind[:N_configs]
            potfiles = [ potfiles[i] for i in keep_ind ]
            outputs  = [ outputs[i] for i in keep_ind ]
            xyzs     = [ xyzs[i] for i in keep_ind ]

    ################
    # All-Atom Fit # 
    ################

    for z in [ 'AA', 'UA' ]:

        # Initialize arrays
        lstsq_D_errs = []
        lstsq_errs   = []
        lstsq_qtot   = []
        fit_D_errs   = []
        fit_errs     = []
        fit_qtot     = []
        avoid_list   = []

        if z == "AA":
            lstsq_dict   = {}
            fit_dict     = {}

        # Iterate over the files being fit
        for count_f,f in enumerate(potfiles):

            # Parse dipole and quadrupole
            # Parse the geometry, grid locations, and potential from the orca *.vpot file
            # NOTE: the geo is returned in bohr
            elements,geo,grid,potential = parse_vpot(f,xyzs[count_f])

            # Generate the adjacency matrix
            # NOTE: the units are converted back angstroms
            adj_mat = Table_generator(elements,geo*0.52917721067,File=xyzs[count_f])

            # Generate the atomtypes
            #atomtypes = id_types(elements,adj_mat,gens,Hybridization_finder(elements,adj_mat),geo*0.52917721067) ### OLD ID_TYPES CALL, HYBRID AND GEO AREN'T USED ANYMORE
            atomtypes = id_types(elements,adj_mat,gens)

            # Calculate the center of mass
            cm = calc_cm(elements,geo)    

            # Parse dipole/quadrupole
            if outputs[count_f] is not None:
                dipole_0,quadrupole_0 = parse_orca_out(outputs[count_f])
            else:
                w_dipole = 0.0
                w_quadrupole = 0.0
                dipole_0 = np.array([0.0,0.0,0.0])
                quadrupole_0 = np.array([0.0,0.0,0.0])

            # If no dipole or quadrupole are found then zero out the weight of that component and continue
            if dipole_0 is None:
                w_dipole = 0.0
                dipole_0 = np.array([0.0,0.0,0.0])
            if quadrupole_0 is None:
                w_quadrupole = 0.0
                quadrupole_0 = np.array([0.0,0.0,0.0])

            # Prune united-atom hydrogens if the option is enabled
            if z == "UA":
                del_ind=[ count_i for count_i,i in enumerate(adj_mat) if elements[count_i] == "H" and len([ j for count_j,j in enumerate(adj_mat[count_i]) if j == 1 and elements[count_j] == "C" and np.sum(adj_mat[count_j]) == 4 ]) > 0 ]
                keep_ind = [ i for i in range(len(adj_mat)) if i not in del_ind ]
                #keep_ind = [ count_i for count_i,i in enumerate(adj_mat) if elements[count_i] != "H" or "C" not in [ elements[count_j] for count_j,j in enumerate(i) if j == 1 ] ]
                geo = geo[keep_ind]
                elements = [ elements[i] for i in keep_ind ]
                adj_mat = adj_mat[keep_ind,:][:,keep_ind]
                atomtypes = [ atomtypes[i]+'-UA' for i in keep_ind ]

            # Calculate the inverse displacements of each grid point from the charge centers being fit. 
            seps = 1.0/cdist(grid,geo)

            # Calculate lstsq fit with qtot charge constraint as a reference
            lstsq_charges = lstsq_potfit(geo,grid,qtot,seps,potential)

            # Initialize initial guess (charges) and a list of holding the index in charges that each atomic charges corresponds to
            # In the case of no symmetry constraints, charge_mapping simply maps one-to-one to the charges list. When there are symmetry 
            # constraints the charge_mapping elements of like atomtypes will commonly reference some common index in charges array. 
            # NOTE: initial guess is made to satisfy q_tot but distributing the necessary amount to the atoms being fit
            # NOTE: fix_ind and the initial guess are populated with charges from the supplied FF files  
            charge_mapping = list(range(len(geo)))
            fix_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i in list(fixed_dict.keys()) ]
            fit_ind        = [ count_i for count_i,i in enumerate(atomtypes) if i not in list(fixed_dict.keys()) ]
            charges_0      = np.array([ 0.0 if count_i in fit_ind else fixed_dict[atomtypes[count_i]] for count_i,i in enumerate(atomtypes) ])
            if len(fit_ind) == 0:
                offset = 0.0
            else:
                offset         = (qtot-np.sum(charges_0))/float(len(fit_ind))
            for i in fit_ind: charges_0[i] = offset

            ###################
            # Fit the charges #
            ###################

            # two-step algorithm: first fits the polar atoms with symmetry constraints, then holds the polar atoms fixed and fits the non-polar atoms with symmetry constraints.
            if two_step == True:

                # Find non-carbon atoms and hydrogens that aren't attached to carbon
                polar_ind = [ count_i for count_i,i in enumerate(adj_mat) \
                              if ( elements[count_i] != 'C' and elements[count_i] != "H" ) or ( elements[count_i] == "H" and np.sum([ 1 for count_j,j in enumerate(adj_mat[count_i]) if ( j == 1 and elements[count_j] == "C" ) ]) == 0 ) ]

                # Find non-carbon atoms and hydrogens that aren't attached to carbon
                nonpolar_ind = [ i for i in range(len(geo)) if i not in polar_ind ]

                # Remove fixed atoms from fit consideration
                polar_ind    = [ i for i in polar_ind if i not in fix_ind ]
                nonpolar_ind = [ i for i in nonpolar_ind if i not in fix_ind ]

                # During the first step (i) no charges are fixed and (ii) symmetry is only forced on the polar atoms.
                # The polar atomtypes are looped over (outer loop), the indices of all like atomtypes are found (idx), all charge_mapping elements at indices idx are set to point at the first instance of that atom type.
                charge_mapping = list(range(len(geo)))
                for i in set([ atomtypes[j] for j in polar_ind ]):
                    idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                    for j in idx: charge_mapping[j] = idx[0]

                # Fit the polar atoms                    imposes_symmetry fits_only_polar
                fit_charges = flex_fit(geo,potential,seps,charge_mapping,fit_ind,\
                                       qtot,dipole_0,quadrupole_0,cm,w_pot,w_qtot,w_hyper,b_hyper,w_dipole,w_quadrupole,charges_0=charges_0,traceless_opt=False)

                # During the second step (i) the charges on the polar_ind atoms are fixed and (ii) symmetry is forced on the non_polar atoms.
                for i in set([ atomtypes[j] for j in nonpolar_ind ]):
                    idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                    for j in idx: charge_mapping[j] = idx[0]

                # Check to ensure that there is something to fit in this second step
                if len(nonpolar_ind) > 0:

                    # Fit the non-polar atoms                imposes_symmetry fits_only_nonpolar
                    fit_charges = flex_fit(geo,potential,seps,charge_mapping,nonpolar_ind,\
                                           qtot,dipole_0,quadrupole_0,cm,w_pot,w_qtot,w_hyper,b_hyper,w_dipole,w_quadrupole,charges_0=fit_charges,traceless_opt=False)

            # symmetrize algorithm: fits all atoms at once with symmetry constraints.
            elif symmetrize == True:

                # The atomtypes are looped over (outer loop), the indices of all like atomtypes are found (idx), all charge_mapping elements at indices idx are set to point at the first instance of that atom type.
                for i in set(atomtypes):
                    idx = [ count_k for count_k,k in enumerate(atomtypes) if k == i ]
                    for j in idx: charge_mapping[j] = idx[0]

                # Fit the charges                        imposes_symmetry  fits_all_atoms
                fit_charges = flex_fit(geo,potential,seps,charge_mapping,fit_ind,\
                                       qtot,dipole_0,quadrupole_0,cm,w_pot,w_qtot,w_hyper,b_hyper,w_dipole,w_quadrupole,charges_0=charges_0,traceless_opt=False)

            # default: perform the fit to all atoms at once without symmetry constraints
            else:

                # Fit the charges
                fit_charges = flex_fit(geo,potential,seps,list(range(len(geo))),fit_ind,\
                                       qtot,dipole_0,quadrupole_0,cm,w_pot,w_qtot,w_hyper,b_hyper,w_dipole,w_quadrupole,charges_0=charges_0,traceless_opt=False)

            # Update the charges in the dictionary
            for i in set(atomtypes):

                # When keep_min option is enabled, the program avoids saving any charges for whom this geometry is not a minimal structure
                if keep_min is True and minimal_structure(i,geo,elements,adj_mat=adj_mat,atomtypes=atomtypes) is False :                    
                    avoid_list += [i]
                    continue

                if i not in lstsq_dict:
                    lstsq_dict[i] = []
                if i not in fit_dict:
                    fit_dict[i] = []
                for count_j,j in enumerate(atomtypes):
                    if i == j:
                        lstsq_dict[i] += [lstsq_charges[count_j]]
                        fit_dict[i] += [fit_charges[count_j]]

            # Update error dictionaries
            lstsq_errs += [np.mean((Calc_Pot(seps,lstsq_charges)-potential)**(2.0))]
            fit_errs += [np.mean((Calc_Pot(seps,fit_charges)-potential)**(2.0))]
            if dipole_0 is not None:
                lstsq_D_errs += [ (norm(dipole_0) - calc_dipole(geo,lstsq_charges)[1])**(2.0) ]
                fit_D_errs += [ (norm(dipole_0) - calc_dipole(geo,fit_charges)[1])**(2.0) ]

            # Update qtot lists           
            lstsq_qtot += [np.sum(lstsq_charges)] 
            fit_qtot += [np.sum(fit_charges)]

        # Print Charge summary
        if verbose is True:
            print(("{}".format("*"*140)))
            print(("* {:^136s} *".format("Final {}-Charges".format(z))))
            print(("*{:^138s}*".format("-"*138)))
            print(("* {:<60s}         {:<30s}        {:<19s} {:<10s}*".format("Atomtype","CHELPG","Fit","Status")))
            print(("{}".format("*"*140)))
            for i in lstsq_dict:
                if z == "UA" and "-UA" not in i: continue
                if i in list(fixed_dict.keys()): origin="fixed"
                else: origin="fit"
                print(("  {:<60s} {:35s} {:30s} {}".format(i,"{:< 8.6f} +/- {:<12.6f}".format(np.mean(lstsq_dict[i]),np.std(lstsq_dict[i])),"{:< 8.6f} +/- {:<12.6f}".format(np.mean(fit_dict[i]),np.std(fit_dict[i])),origin)))

            # Print error summary
            print(("\n  {:<60s} {:< 35.6g} {:< 35.6g} ".format("<xhi_pot^2> (A.U.^2):",np.mean(lstsq_errs),np.mean(fit_errs))))
            if len(lstsq_D_errs) > 0:
                print(("  {:<60s} {:< 35.6g} {:< 35.6g} ".format("<xhi_D^2> (A.U.^2):",np.mean(lstsq_D_errs),np.mean(fit_D_errs))))
            print(("  {:<60s} {:< 35.6f} {:< 35.6f} \n".format("total charge (A.U.):",np.mean(lstsq_qtot),np.mean(fit_qtot))))

            # Print summary of charges not saved due to the --keep_min option
            if len(avoid_list) > 0:
                avoid_list = set(avoid_list)
                print(("{}".format("*"*140)))
                print(("* {:^136s} *".format("Atomtypes that weren't Saved Because this isn't a Minimal Geometry")))
                print(("{}".format("*"*140)))
                print("\nList of atomtypes that weren't saved:\n")
                for i in sorted(avoid_list):
                    print(("\t{}".format(i)))
                print(" ")

    charges = { i:(np.mean(fit_dict[i]),np.std(fit_dict[i])) for i in fit_dict }
    errs    = { "xhi_pot":np.mean(fit_errs) }
    if len(fit_D_errs) > 0:
        errs["xhi_D"] = np.mean(fit_D_errs)

    return charges, errs

# Least-squares fit to the potential with a constraint on the total charge
#
# geo:           position of nuclear centers (Nx3 numpy array)
# potential:     potential at grid points (indexed to seps) (Gx1 numpy array)
# seps:          matrix of separations with elements e_ij holding the separation between nuclear center i and grid point j (NxG numpy array)
# dipole_0:      the dipole moment used for fitting (1x3 numpy array)
# quadrupole_0:  the quadrupole moment used for fitting (3x3 numpy array)
# r_0:           the origin used for calculating the dipole and/or quadrupole (1x3 numpy array)
# w_pot:         the weighting value in the cost function for deviations from the potential
# w_hyper:       the weighting value in the cost function for the hyperbolic constraint
# b_hyper:       the hyperbolic stiffness used in the RESP-type term in the cost function
# w_dipole:      the weighting value in the cost function for deviations from the dipole moment.
# w_quadrupole:  the weighting value in the cost function for deviations from the quadrupole moment.
# charges_0:     the initial guess for the partial charge distribution
# traceless_opt: when calculating the quadrupole, this flag controls whether the calculation produces a traceless quadrupole.
def flex_fit(geo,potential,seps,charge_mapping=None,fit_indices=None,\
             qtot=0.0,dipole_0=None,quadrupole_0=None,r_0=None,w_pot=1.0,w_qtot=1.0,w_hyper=0.01,b_hyper=0.1,w_dipole=0.1,w_quadrupole=0.05,charges_0=None,traceless_opt=False):

    # Initialize global objects utilized during the fit
    if charges_0 is None:
        charges = np.zeros(len(geo)) + qtot/float(len(geo))
    else:
        charges = deepcopy(charges_0)
    if charge_mapping is None:
        charge_mapping = list(range(len(charges)))
    if fit_indices is None:
        fit_indices = list(range(len(charges)))

    # Return charges if there is nothing to be fit
    if len(fit_indices) == 0:
        return charges

    # Create anonymous function for use in the fitting
    fit_func = lambda x: flex_fit_func(*x,potential=potential,seps=seps,geo=geo,charges=charges,charge_mapping=charge_mapping,charge_indices=fit_indices,qtot=qtot,dipole_0=dipole_0,quadrupole_0=quadrupole_0,r_0=r_0,\
                                          w_pot=w_pot,w_qtot=w_qtot,w_hyper=w_hyper,b_hyper=b_hyper,w_dipole=w_dipole,w_quadrupole=w_quadrupole,traceless_opt=traceless_opt)

    # Fit the charges
    charges[fit_indices] = minimize(fit_func,charges[fit_indices],tol=1E-12).x

    # Generate final list of charges based on charge_mapping
    for count_i,i in enumerate(charge_mapping):
        charges[count_i] = charges[i]

    # Subtract off unwanted residual charge
    # charges -= (np.sum(charges) - qtot)/float(len(charges)) # OLD, new only subtracts from fit_ind
    charges[fit_indices] -= (np.sum(charges) - qtot)/float(len(fit_indices))
    return charges

# Compatible with minimize
# Following the original RESP paper, 0.1 is the recommended value for "b" (the hyperbolic stiffness) and 0.001 is the "stronger" value
# for the weighting coefficient (0.0005 is also suggested as a valid "weaker" option).
#
# charges: partial charges at the nuclear centers (indexed to seps)
# charge_indices: indexed to the supplied q_* variables holding the index in charges that each q_* value should be assigned to
# charge_mapping: indexed to charges, holds indices in charges that each index in charges corresponds to (sounds circular, but it works out for enforcing charge symmetry)
def flex_fit_func(q_0=None, q_1=None, q_2=None, q_3=None, q_4=None, q_5=None, q_6=None, q_7=None, q_8=None, q_9=None,q_10=None,\
                  q_11=None,q_12=None,q_13=None,q_14=None,q_15=None,q_16=None,q_17=None,q_18=None,q_19=None,q_20=None,\
                  q_21=None,q_22=None,q_23=None,q_24=None,q_25=None,q_26=None,q_27=None,q_28=None,q_29=None,q_30=None,\
                  q_31=None,q_32=None,q_33=None,q_34=None,q_35=None,q_36=None,q_37=None,q_38=None,q_39=None,q_40=None,\
                  q_41=None,q_42=None,q_43=None,q_44=None,q_45=None,q_46=None,q_47=None,q_48=None,q_49=None,q_50=None,\
                  q_51=None,q_52=None,q_53=None,q_54=None,q_55=None,q_56=None,q_57=None,q_58=None,q_59=None,q_60=None,\
                  q_61=None,q_62=None,q_63=None,q_64=None,q_65=None,q_66=None,q_67=None,q_68=None,q_69=None,q_70=None,\
                  q_71=None,q_72=None,q_73=None,q_74=None,q_75=None,q_76=None,q_77=None,q_78=None,q_79=None,q_80=None,\
                  q_81=None,q_82=None,q_83=None,q_84=None,q_85=None,q_86=None,q_87=None,q_88=None,q_89=None,q_90=None,\
                  q_91=None,q_92=None,q_93=None,q_94=None,q_95=None,q_96=None,q_97=None,q_98=None,q_99=None,q_100=None,\
                  potential=None,seps=None,geo=None,charges=None,charge_indices=None,charge_mapping=None,qtot=None,dipole_0=None,quadrupole_0=None,\
                  r_0=None,w_pot=0.0,w_qtot=0.0,w_hyper=0.0,b_hyper=0.0,w_dipole=0.0,w_quadrupole=0.0,traceless_opt=False):

    # Initialize local variable dictionary (used for determining what has been defined)
    local_vars = locals()
    
    # Initialize a list of fit charges
    fit_charges = np.array([ local_vars[j] for j in natural_sort([ i for i in local_vars if 'q_' in i and local_vars[i] is not None ]) ])

    #########################################
    # Consistency checks on input arguments #
    #########################################

    # Check that charges is supplied during the function call
    if charges is None:
        print("ERROR in flex_fit_func: charges must be supplied during the function call. It only appears to be an optional argument for convenience when anonymizing the function.")
        quit()

    # If the charge_indices list is supplied then check that there is a consistent number of supplied charges and supplied indices
    if charge_indices is not None:
        if len(charge_indices) != len(fit_charges):
            print("ERROR in flex_fit_func: the number of supplied q_* variables should match the number of elements in charge_indices. Exiting...")
            quit()

    # Else, default behavior is to assume that all charges are being fit. If that isn't the case then print an error and exit.
    else:
        if len(charges) != len(fit_charges):
            print("ERROR in flex_fit_func: a charge_indices list must be supplied if the number of supplied q_* variables is less than the number of charged centers in the system. Exiting...")
            quit()

        # Initialize one-to-one (default) assigment of charge_indices
        else:
            charge_indices = list(range(len(charges)))

    # Check that the charge_mapping dimensions and charges dimensions match
    if charge_mapping is not None:
        if len(charges) != len(charge_mapping):
            print("ERROR in flex_fit_func: the dimensions of the charge_mapping and charges arrays must match. Exiting...")            
            quit()

    # Initialize one-to-one (default) assigment of charge_mapping
    else:
        charge_mapping = list(range(len(charges)))

    #####################################
    # Perform cost function calculation #
    #####################################

    # Assign the charges being fit to the supplied q_* values
    for count_i,i in enumerate(fit_charges):
        charges[charge_indices[count_i]] = i
    
    # Carry out the mapping procedure (* this is the mechanism for enforcing symmetry)
    for count_i,i in enumerate(charge_mapping):
        charges[count_i] = charges[i]


        
    # Return cost function
    return w_pot * np.mean(( potential - np.dot(seps,charges.T) )**(2.0)) + w_hyper * np.mean( (charges**(2.0) + b_hyper**(2.0) )**(0.5) - b_hyper ) + w_qtot*(np.sum(charges)-qtot)**(2.0) +\
           w_dipole*np.mean((calc_dipole(geo,charges,r_0=r_0)[0] - dipole_0)**(2.0)) + w_quadrupole*np.mean(((calc_quadrupole(geo,charges,r_0=r_0,traceless=traceless_opt) - quadrupole_0 )**(2.0)).flat)

# Calculate the center of mass for the molecule
def calc_cm(elements,geo):

    # Dictionary of masses are needed to apply the CIP rules 
    Masses = {'H':1.00794,'He':4.002602,'Li':6.941,'Be':9.012182,'B':10.811,'C':12.011,'N':14.00674,'O':15.9994,'F':18.9984032,'Ne':20.1797,\
            'Na':22.989768,'Mg':24.3050,'Al':26.981539,'Si':28.0855,'P':30.973762,'S':32.066,'Cl':35.4527,'Ar':39.948,'Ge':72.61,'As':74.92159,\
             'Se':78.96,'Br':79.904,'I':126.90447}
    if set(elements).issubset(list(Masses.keys())) == False:
        print("ERROR in calc_cm: Encountered an element that wasn't in the masses dictionary while trying to calculate the center of mass. Exiting...")
        quit()
    else:
        masses = np.array([ Masses[i] for i in elements ])
        cm = np.sum(masses[:,None] * geo,axis=0)/np.sum(masses)
    return cm

# input   geo        : Nx3 array
#         charges    : Nx1 array
# returns dipole     : 1x3 array
#         dipole mag : scalar
def calc_dipole(geo,charges,r_0=None):

    # If an origin is supplied, then perform a consistency check and center the geometry about it.
    if r_0 is not None:
        
        # Consistency check
        if len(r_0) != 3:
            print("ERROR in calc_quadrupole: r_0 must be a 3 element array. Exiting...")
            quit()

        # Center the geometry about the supplied origin
        geo = geo - r_0

    # Center about the centroid by default
    else:
        centroid = np.mean(geo,axis=0)
        geo = geo - centroid

    # Return the dipole moment and magnitude
    dipole =  np.sum(geo*charges[:,None],axis=0)
    return dipole,norm(dipole)

# Description: a function for calculating the quadrupole moment of distribution of point charges
# NOTE: returns units of charge * geo_units**2, if geo is in units of bohr and the charges are partial charges then the quadrupole is in A.U. 
# NOTE: if an origin, r_0, is unsupplied then the function defaults to using the centroid of the geometry. 
#
# input  geo:       Nx3 array
#        charges:   Nx1 array
#        r_0:       1x3 array (origin for calculating the quadrupole)
# returns dipole:   1x3 array
def calc_quadrupole(geo,charges,r_0=None,traceless=True):

    # Check that the traceless option is of the proper type
    if traceless not in [True,False]:
        print("ERROR in calc_quadrupole: traceless option must be a boolean. Exiting...")
        quit()

    # If an origin is supplied, then perform a consistency check and center the geometry about it.
    if r_0 is not None:
        
        # Consistency check
        if len(r_0) != 3:
            print("ERROR in calc_quadrupole: r_0 must be a 3 element array. Exiting...")
            quit()

        # Center the geometry about the supplied origin
        geo = geo - r_0

    # Center about the centroid by default
    else:
        centroid = np.mean(geo,axis=0)
        geo = geo - centroid

    Q = np.zeros([3,3])

    # The traceless quadrupole subtracts off the squared norm of each charge position from the diagonal elements.
    # This guarranteees that the trace sums to zero and has the best agreement with the actual electrical potential.
    if traceless == True:        
        geo_norms = norm(geo,axis=1)**(2.0)
        for i in range(3):
            for j in range(3):
                if i == j:
                    Q[i,j] = np.sum((3.0*geo[:,i]*geo[:,j]-geo_norms)*charges)
                else:
                    Q[i,j] = np.sum(charges*(3.0*geo[:,i]*geo[:,j]))

    # The primitive quadrupole is simply the sum of the squared position components weighted by the charges.
    # This definition is the more obvious mathematical expansion. 
    else:
        for i in range(3):
            for j in range(3):
                Q[i,j] = np.sum(charges*(geo[:,i]*geo[:,j]))
    return Q

# Function for calculating the potential on each grid point using the supplied configuration of charges.
def Calc_Pot(seps,charges_0):
    return np.dot(seps,charges_0.T)

# Read in the nuclear coordinates, electric  potential, and grid coordinates from the *.vpot file
def parse_vpot(filename,xyz_file=None):

    # Toggle the xyz flag 
    if xyz_file != None:
        xyz_flag = 1
    else:
        xyz_flag = 0

    # Loop over the lines in the file
    with open(filename,'r') as f:
        atom_count = 0
        pot_count = 0
        for lc,lines in enumerate(f):
            fields = lines.split()

            # Initialize lists/arrays
            if lc == 0: 
                n_atom    = int(fields[0])
                n_grid    = int(fields[1])
                elements  = ["X"]*n_atom
                geo       = np.zeros([n_atom,3])
                grid      = np.zeros([n_grid,3])
                potential = np.zeros([n_grid])
                flag = 1
                continue

            # Parse the grid and potential
            if flag == 2:
                grid[pot_count] = np.array([ float(i) for i in fields[1:4] ])
                potential[pot_count] = float(fields[0])
                pot_count += 1
                if pot_count == n_grid:
                    break

            # Parse the molecule
            if flag == 1:
                if len(fields) == 0: continue
                # The parse is avoided if the xyz_flag is 1
                if xyz_flag == 0:
                    elements[atom_count] = fields[0]
                    geo[atom_count]      = np.array([ float(i) for i in fields[1:4] ])
                atom_count += 1
                if atom_count == n_atom:
                    flag = 2
                    continue

    # If an xyz file is supplied parse the nuclear centers under the assumption that the units are in angstroms
    # Basic checks are in place for the proper number of atoms and a complete xyz file. 
    if xyz_flag == 1:
        atom_count = 0
        with open(xyz_file,'r') as f:
            for lc,lines in enumerate(f):

                # Initialize elements and geometry lists/arrays
                if lc == 0:
                    fields = lines.split()
                    N_elements = ["X"]*int(fields[0])
                    N_geo      = np.zeros([int(fields[0]),3])
                    continue

                # Parse the nuclei
                # With a conversion from angstroms to bohr
                if lc > 1:
                    fields = lines.split()
                    if len(fields) == 0: 
                        continue
                    else:
                        N_elements[atom_count] = fields[0]
                        N_geo[atom_count] = np.array([ float(i)/0.52917721067 for i in fields[1:4] ])
                        atom_count += 1

        # Perform basic checks on the number of nuclei being parsed
        if len(N_elements) != len(elements):
            print("ERROR in parse_vpot: the number of atoms in the supplied xyz file does not match the number of atoms specified in the vpot file. Exiting...")
            quit()
        if atom_count != len(N_elements):
            print("ERROR in parse_vpot: parsing of the xyz file terminated before finding all nuclear centers. Exiting...")
            quit()
        geo = N_geo
        elements = N_elements

    return elements,geo,grid,potential

def natural_sort(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ] 
    return sorted(l, key = alphanum_key)

# A function for extracting the dipole and quadrupole from orca files. 
def parse_orca_out(output_file):

    # Initialize the dipole and quadrupole to None 
    dipole_0 = None
    quadrupole_0 = None
    complete_flag = 0

    # open file and parse dipole/quadrupole if available
    with open(output_file,'r') as f:
        quad_flag = 0
        for lines in f:
            fields = lines.split()
            
            # dipole parsing commands
            if len(fields) == 7 and fields[0] == "Total" and fields[1] == "Dipole" and fields[2] == "Moment":
                dipole_0 = np.array([ float(i) for i in fields[4:7] ])

            # quadrupole parsing commands
            if quad_flag == 6:
                quadrupole_0      = np.zeros([3,3])
                quadrupole_0[0,:] = [float(fields[1]),float(fields[4]),float(fields[5])]
                quadrupole_0[1,:] = [float(fields[4]),float(fields[2]),float(fields[6])]
                quadrupole_0[2,:] = [float(fields[5]),float(fields[6]),float(fields[3])]
                quad_flag = 0
            elif quad_flag > 0:
                quad_flag += 1
            elif len(fields) == 3 and fields[0] == "QUADRUPOLE" and fields[1] == "MOMENT" and fields[2] == "(A.U.)":
                quad_flag = 1
            
            # check for job completion
            if "****ORCA TERMINATED NORMALLY****" in lines:
                complete_flag = 1

    # Print a warning if the output file is incomplete
    if complete_flag == 0:
        print(("WARNING in parse_orca_out: The file {} is incomplete.".format(output_file)))
            
    return dipole_0,quadrupole_0

# Least-squares fit to the potential with a constraint on the total charge
# seps is the inverse displacements of each grid potint from the charge centers being fit
def lstsq_potfit(geo,grid,q_tot,seps,potential):

    A = np.vstack([seps,np.ones(len(geo))*float(len(grid))])
    b = np.hstack([potential,np.array([q_tot * float(len(grid))])])

    # Calculate inverse
    A_inv = np.linalg.pinv(A)

    # Calculate fit coefficients                                                                                                                                                                                                             
    charges_lstsq = np.dot(A_inv,b)
    charges_lstsq = charges_lstsq - ( np.sum(charges_lstsq) - q_tot ) / float(len(charges_lstsq))
    return deepcopy(charges_lstsq)

# Description: A simple wrapper for the file writing commands for the vdw parameters.
#              The function takes arguments for the filename, fit type (e.g. lj), and
#              united-atom (UA) vs all-atom (AA) style.
def write_params(name,charge_dict):

    # Save charges
    with open(name,'w') as f:

        f.write("\n# Charge definitions\n#\n{:10s} {:41s} {:20s}\n".format("#","Atom_type","Charge"))
        for i in natural_sort(list(charge_dict.keys())):
            if '-UA' not in i:
                f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",str(i),np.mean(charge_dict[i])))
        for i in natural_sort(list(charge_dict.keys())):
            if '-UA' in i:
                f.write("{:10s} {:40s} {:< 20.6f}\n".format("charge",str(i),np.mean(charge_dict[i])))

# Wrapper script for the molecule.db writing commands
def write_molecule_db(folder,elements,geo,charges,types):

    # Write examples of each molecule in the sim to a molecule.db file. This is used when
    # adding the intramolecular parameters to the master database. Each parameter in the master is linked
    # to the molecule(s) used to generate it. In the case of intramolecular params, the globally optimized
    # geometry is saved to the db.
    with open(folder+'/molecules.db','w') as f:
        f.write("\nmol {:6d} start\n".format(1))
        # Save an xyz for viewing the configuration in VMD
        f.write('{}\n\n'.format(len(geo)))
        for count_i,i in enumerate(geo):
            f.write('  {:<10s} {:< 20.6f} {:< 20.6f} {:< 20.6f} {:< 12.6f} {:<60s}\n'.\
            format(elements[count_i],i[0],i[1],i[2],charges[count_i],types[count_i]))
        f.write("mol {:6d} end\n".format(1))

    return

# Create logger to save stdout to logfile
class Logger(object):

    def __init__(self,folder):
        self.terminal = sys.stdout
        self.log = open(folder+"/fit_charges.log", "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)  
    def flush(self):
        pass

if __name__ == "__main__":
   main(sys.argv[1:])
